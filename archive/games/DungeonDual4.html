<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>ë°°í‹€ë§í¬</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    html, body { height:100%; margin:0; padding:0; }
    body { font-family: sans-serif; background: #fff; color: #222; text-align: center; margin:0; padding:0;}
    #stats { margin: 5px 0 10px; font-size:0.98em;}
    #stats span { margin: 0 10px; }
    #stats2 { margin: 5px 0 10px; font-size:0.98em;}
    #stats2 span { margin: 0 10px; }
    #turn-indicator { font-size:1.1em; margin:8px 0; }
    #board-wrap { position: relative; display: flex; justify-content: center; align-items: center; }
    #board {
      position: relative;
      display: grid;
      margin: 0 auto;
      background: #eee;
      border-radius: 12px;
      padding: 8px;
      box-sizing: border-box;
      overflow: visible;
      border: 2px solid #eee;
    }
    .cell {
      background: #fafafa;
      border-radius: 6px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      user-select: none;
      transition: background 0.2s;
      border: 1px solid #ccc;
      position: relative;
      z-index: 2;
      overflow: hidden;
      font-size: 1em;
    }
    .cell.hero1 {
      background: #b7ffb7 !important;
    }
    .cell.hero2 {
      background: #ffb7e3 !important;
    }
    .cell .info {
      font-size: 0.28em;
      color: #444;
      line-height: 1.0;
      margin-top: -3px;
      letter-spacing: -1px;
      word-break: keep-all;
    }
    .selected { 
      background: #ffe066 !important; 
      position: relative;
    }
    .selected::after {
      content: '';
      position: absolute;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      pointer-events: none;
      border: 2px solid transparent;
    }
    .selected.p1-path::after {
      border-color: #4CAF50;
    }
    .selected.p2-path::after {
      border-color: #f44336;
    }
    .path-line {
      position: absolute;
      height: 3px;
      transform-origin: left center;
      pointer-events: none;
      z-index: 3;
      border-radius: 1.5px;
    }
    .p1-line {
      background: rgba(76, 175, 80, 0.8);
      box-shadow: 0 0 4px rgba(76, 175, 80, 0.5);
    }
    .p2-line {
      background: rgba(244, 67, 54, 0.8);
      box-shadow: 0 0 4px rgba(244, 67, 54, 0.5);
    }
    #actions { margin: 8px 0; }
    #message { min-height: 1.5em; margin: 8px 0 0 0; font-size:0.98em;}
    button { margin: 6px 5px 0 5px; padding: 6px 14px; font-size: 0.98em; border-radius: 8px; border: none; background: #ffe066; color: #222; font-weight: bold; cursor: pointer; }
    button:active { background: #ffd700; }
    #setup-modal {
      display: flex; flex-direction:column; align-items:center; justify-content:center;
      position: fixed; left:0; top:0; width:100vw; height:100vh;
      background: rgba(0,0,0,0.2); z-index: 99;
    }
    #setup-modal .modal-box {
      background:#fff; border-radius:12px; padding:28px 18px 18px 18px; min-width:220px; box-shadow:0 2px 16px #0003;
      display:inline-block;
    }
    #setup-modal .modal-box h3 { margin-top:0; margin-bottom:10px;}
    #setup-modal label { font-size:1.1em; }
    #setup-modal select { font-size:1.1em; margin-left:8px; }
    #timer {
      display: none !important;
    }
    @media (max-width: 700px) {
      #board { max-width: 98vw; }
    }
  </style>
</head>
<body>
  <!-- ìë™ë§¤ë§¤ ì œì‘ì˜ë¢° ë§í¬ -->
  <div style="position: fixed; top: 10px; left: 50%; transform: translateX(-50%); z-index: 100;">
      <a href="https://open.kakao.com/o/sy2UErbd" 
         style="display: inline-block; 
                background: #ff6b6b; 
                color: white; 
                padding: 8px 15px; 
                border-radius: 20px; 
                text-decoration: none; 
                font-weight: bold; 
                font-size: 0.9rem;
                box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
                transition: all 0.3s ease;">
          ğŸ¤– ìë™ë§¤ë§¤ ì œì‘ì˜ë¢°
      </a>
  </div>
  <div style="height: 60px;"></div> <!-- ë§í¬ì™€ ì œëª© ì‚¬ì´ ì—¬ë°± -->
  <h2 style="margin-top: 0; margin-bottom: 24px; text-align: center;">ë°°í‹€ë§í¬</h2>
  <!-- ëª¨ë‹¬ë“¤ì€ ì œëª© ë°”ë¡œ ì•„ë˜ì— ìœ„ì¹˜í•˜ë„ë¡ êµ¬ì¡° ì´ë™ -->
  <div id="setup-modal" style="display: flex; flex-direction:column; align-items:center; justify-content:center; position: relative; width:100vw; min-height: 300px; margin-bottom: 0;">
    <div class="modal-box">
      <h3>ê²Œì„ ëª¨ë“œë¥¼ ì„ íƒí•˜ì„¸ìš”</h3>
      <div style="margin: 20px 0;">
        <button onclick="selectMode('single')" style="margin: 10px; padding: 15px 25px; font-size: 1.1em; background: #4CAF50; color: white; border: none; border-radius: 8px; cursor: pointer;">
          1ì¸ìš© ëª¨ë“œ
        </button>
        <button onclick="selectMode('multi')" style="margin: 10px; padding: 15px 25px; font-size: 1.1em; background: #2196F3; color: white; border: none; border-radius: 8px; cursor: pointer;">
          2ì¸ìš© ëª¨ë“œ
        </button>
      </div>
      <div id="mode-description" style="margin: 15px 0; padding: 10px; background: #f5f5f5; border-radius: 5px; font-size: 0.9em;">
        ê²Œì„ ëª¨ë“œë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”
      </div>
    </div>
  </div>
  <div id="size-modal" style="display: none; flex-direction:column; align-items:center; justify-content:center; position: relative; width:100vw; min-height: 300px; margin-bottom: 0;">
    <div class="modal-box" style="text-align: center;">
      <h3>ë³´ë“œ í¬ê¸°ë¥¼ ì„ íƒí•˜ì„¸ìš”</h3>
      <label style="display: block; margin: 15px 0;">
        <select id="sizeSelect" style="font-size: 1.1em; padding: 8px; border-radius: 5px; border: 1px solid #ccc;">
          <option value="6">6 Ã— 6 (ì•„ì£¼ ì‘ìŒ)</option>
          <option value="8">8 Ã— 8 (ì‘ìŒ)</option>
          <option value="10">10 Ã— 10 (ì¤‘ê°„)</option>
          <option value="13" selected>13 Ã— 13 (í¼)</option>
          <option value="16">16 Ã— 16 (ëŒ€í˜•)</option>
          <option value="19">19 Ã— 19 (ì´ˆëŒ€í˜•)</option>
        </select>
      </label>
      <div style="margin: 15px 0;">
        <button onclick="startGame()">ê²Œì„ ì‹œì‘</button>
        <button onclick="backToModeSelect()" style="margin-left: 10px; background: #666;">ë’¤ë¡œê°€ê¸°</button>
      </div>
    </div>
  </div>
  <div id="turn-indicator" style="display:none;"></div>
  <div id="stats" style="display:none;">
    <b>í”Œë ˆì´ì–´1</b>
    <span>â¤ï¸ <span id="hp1">1000</span></span>
    <span>ğŸ›¡ï¸ <span id="shield1">0</span></span>
    <span>ğŸ—¡ï¸ <span id="atk1">1</span></span>
    <span>ğŸ’° <span id="gold1">0</span></span>
    <span>â­ <span id="exp1">0</span></span>
    <span>ë ˆë²¨ <span id="level1">1</span></span>
  </div>
  <div id="stats2" style="display:none;">
    <b>í”Œë ˆì´ì–´2</b>
    <span>â¤ï¸ <span id="hp2">1000</span></span>
    <span>ğŸ›¡ï¸ <span id="shield2">0</span></span>
    <span>ğŸ—¡ï¸ <span id="atk2">1</span></span>
    <span>ğŸ’° <span id="gold2">0</span></span>
    <span>â­ <span id="exp2">0</span></span>
    <span>ë ˆë²¨ <span id="level2">1</span></span>
  </div>
  <div id="board-wrap" style="display:none;">
    <div id="board"></div>
  </div>
  <div id="actions" style="display:none;">
    <button onclick="initGame()">ë‹¤ì‹œ ì‹œì‘</button>
  </div>
  <div id="message"></div>
  <script>
    const TILES = [
      {type:"shield", emoji:"ğŸ›¡ï¸"},
      {type:"potion", emoji:"ğŸ§ª"},
      {type:"coin", emoji:"ğŸ’°"},
      {type:"sword", emoji:"ğŸ—¡ï¸"},
    ];
    const PLAYER1 = {type: "player1", emoji: "ğŸ¤º"};
    const PLAYER2 = {type: "player2", emoji: "ğŸ¤º"};
    let SIZE = 13;
    let board = [];
    let selectedPath = [];
    let stats1 = {};
    let stats2 = {};
    let message = "";
    let player1Pos = [0, 0];
    let player2Pos = [0, 0];
    let turn = 1;
    let turnTimer = null;
    let timeLeft = 10;
    let gameMode = 'multi'; // 'single' ë˜ëŠ” 'multi'

    // ë ˆë²¨ì—… ì˜µì…˜ ì •ì˜
    const LEVEL_UP_OPTIONS = [
      {
        type: "stat",
        name: "ì²´ë ¥ ê°•í™”",
        effect: "ìµœëŒ€ ì²´ë ¥ +200",
        apply: (stats) => { stats.maxHp += 200; stats.hp = stats.maxHp; }
      },
      {
        type: "stat",
        name: "ê³µê²©ë ¥ ê°•í™”",
        effect: "ê¸°ë³¸ ê³µê²©ë ¥ +1",
        apply: (stats) => { stats.atk += 1; }
      },
      {
        type: "stat",
        name: "ë°©ì–´ë ¥ ê°•í™”",
        effect: "ê¸°ë³¸ ë°©ì–´ë ¥ +1",
        apply: (stats) => { stats.shield += 1; }
      },
      {
        type: "skill",
        name: "í¡í˜ˆ",
        effect: "ëª¬ìŠ¤í„° ì²˜ì¹˜ ì‹œ ì²´ë ¥ íšŒë³µ +10",
        apply: (stats) => { stats.vampiric = (stats.vampiric || 0) + 10; }
      },
      {
        type: "skill",
        name: "ê³¨ë“œ ëŸ¬ì‹œ",
        effect: "ì½”ì¸ íšë“ëŸ‰ 2ë°°",
        apply: (stats) => { stats.goldMultiplier = (stats.goldMultiplier || 1) * 2; }
      },
      {
        type: "skill",
        name: "ê²½í—˜ ì¶•ì ",
        effect: "ê²½í—˜ì¹˜ íšë“ëŸ‰ 2ë°°",
        apply: (stats) => { stats.expMultiplier = (stats.expMultiplier || 1) * 2; }
      }
    ];

    function randomMonster(type) {
      const r = Math.random();
      if(type === "troll") {
        if(r < 0.5) { // 50% - ì‰¬ìš´ ë‚œì´ë„ (ê¸°ë³¸ ê³µê²©ë ¥ìœ¼ë¡œ ì²˜ì¹˜ ê°€ëŠ¥)
          return {
            hp: 1,
            atk: 1,
            emoji: "ğŸ²"
          };
        } else if(r < 0.9) { // 40% - ì¤‘ê°„ ë‚œì´ë„ (ì¹¼ 1ê°œ í•„ìš”)
          return {
            hp: 2,
            atk: 1,
            emoji: "ğŸ²"
          };
        } else { // 10% - ì–´ë ¤ìš´ ë‚œì´ë„ (ì¹¼ 2ê°œ ì´ìƒ í•„ìš”)
          return {
            hp: 3 + Math.floor(Math.random() * 2), // 3~4 HP
            atk: 2,
            emoji: "ğŸ²"
          };
        }
      } else { // vampire
        if(r < 0.5) { // 50% - ì‰¬ìš´ ë‚œì´ë„
          return {
            hp: 1,
            atk: 1,
            emoji: "ğŸ§›â€â™€ï¸"
          };
        } else if(r < 0.9) { // 40% - ì¤‘ê°„ ë‚œì´ë„
          return {
            hp: 2,
            atk: 1,
            emoji: "ğŸ§›â€â™€ï¸"
          };
        } else { // 10% - ì–´ë ¤ìš´ ë‚œì´ë„
          return {
            hp: 3 + Math.floor(Math.random() * 2), // 3~4 HP
            atk: 2,
            emoji: "ğŸ§›â€â™€ï¸"
          };
        }
      }
    }

    function randomTile() {
      let r = Math.random();
      if(r < 0.18) return {...TILES[0]}; // ë°©íŒ¨
      if(r < 0.36) return {...TILES[1]}; // í¬ì…˜
      if(r < 0.54) return {...TILES[2]}; // ì½”ì¸
      if(r < 0.72) return {...TILES[3]}; // ì¹¼
      if(r < 0.86) {
        // 1ì¸ìš© ëª¨ë“œì¼ ë•ŒëŠ” íŠ¸ë¡¤ ìƒì„±í•˜ì§€ ì•ŠìŒ
        if(gameMode === 'single') {
          let mon = randomMonster("vampire");
          return {type:"vampire", emoji:"ğŸ§›â€â™€ï¸", mon};
        } else {
          let mon = randomMonster("troll");
          return {type:"troll", emoji:"ğŸ²", mon};
        }
      }
      else {
        let mon = randomMonster("vampire");
        return {type:"vampire", emoji:"ğŸ§›â€â™€ï¸", mon};
      }
    }

    function getCellSize() {
      const boardPadding = 8 * 2;
      const boardBorder = 2 * 2;
      const boardGap = (SIZE - 1) * 1;
      const h = window.innerHeight - 250 - boardPadding - boardBorder - boardGap;
      const w = window.innerWidth - 32 - boardPadding - boardBorder - boardGap;
      const cell = Math.floor(Math.min(w, h) / SIZE);
      return Math.max(cell, 16);
    }
    function updateBoardGrid() {
      const boardDiv = document.getElementById("board");
      const cellSize = getCellSize();
      boardDiv.style.gridTemplateColumns = `repeat(${SIZE}, ${cellSize}px)`;
      boardDiv.style.gridTemplateRows = `repeat(${SIZE}, ${cellSize}px)`;
    }
    function startTurnTimer() {
      clearTimeout(turnTimer);
      timeLeft = 10;
      updateTimer();
      
      function tick() {
        timeLeft--;
        updateTimer();
        
        if(timeLeft <= 0) {
          // ì‹œê°„ ì´ˆê³¼ ì‹œ í„´ ë„˜ê¸°ê¸°
          selectedPath = [];
          turn = turn === 1 ? 2 : 1;
          timeLeft = 10;
          updateTimer();
          updateTurnIndicator();
          render();
          startTurnTimer();
          showMessage("ì‹œê°„ ì´ˆê³¼! ë‹¤ìŒ í”Œë ˆì´ì–´ì˜ í„´ì…ë‹ˆë‹¤.");
        } else {
          turnTimer = setTimeout(tick, 1000);
        }
      }
      
      turnTimer = setTimeout(tick, 1000);
    }

    function updateTimer() {
      const timerDiv = document.getElementById("timer");
      timerDiv.textContent = timeLeft;
      timerDiv.style.display = "";
    }

    function selectMode(mode) {
      gameMode = mode;
      const description = document.getElementById("mode-description");
      
      if (mode === 'single') {
        description.innerHTML = "ğŸ® 1ì¸ìš© ëª¨ë“œ: í”Œë ˆì´ì–´1ë§Œ ì¡°ì‘í•˜ì—¬ ë±€íŒŒì´ì–´(ğŸ§›â€â™€ï¸)ì™€ ì‹¸ìš°ì„¸ìš”!<br>í„´ ì „í™˜ ì—†ì´ ì—°ì†ìœ¼ë¡œ í”Œë ˆì´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.";
      } else {
        description.innerHTML = "ğŸ‘¥ 2ì¸ìš© ëª¨ë“œ: í”Œë ˆì´ì–´1ê³¼ í”Œë ˆì´ì–´2ê°€ ë²ˆê°ˆì•„ê°€ë©° í”Œë ˆì´í•©ë‹ˆë‹¤!<br>ë“œë˜ê³¤(ğŸ²)ê³¼ ë±€íŒŒì´ì–´(ğŸ§›â€â™€ï¸)ê°€ ëª¨ë‘ ë“±ì¥í•©ë‹ˆë‹¤.";
      }
      
      // ì ì‹œ í›„ í¬ê¸° ì„ íƒ í™”ë©´ìœ¼ë¡œ ì´ë™
      setTimeout(() => {
        document.getElementById("setup-modal").style.display = "none";
        document.getElementById("size-modal").style.display = "flex";
      }, 1000);
    }
    
    function backToModeSelect() {
      document.getElementById("size-modal").style.display = "none";
      document.getElementById("setup-modal").style.display = "flex";
    }
    
    function startGame() {
      SIZE = parseInt(document.getElementById("sizeSelect").value, 10);
      document.getElementById("size-modal").style.display = "none";
      document.getElementById("stats").style.display = "";
      
      // 1ì¸ìš© ëª¨ë“œì¼ ë•ŒëŠ” í”Œë ˆì´ì–´2 ì •ë³´ ìˆ¨ê¹€
      if (gameMode === 'single') {
        document.getElementById("stats2").style.display = "none";
      } else {
        document.getElementById("stats2").style.display = "";
      }
      
      document.getElementById("board-wrap").style.display = "";
      document.getElementById("actions").style.display = "";
      document.getElementById("turn-indicator").style.display = "";
      initGame();
    }
    function initGame() {
      stats1 = {
        hp: 1000,
        maxHp: 1000,
        shield: 0,
        atk: 1,
        gold: 0,
        exp: 0,
        level: 1,
        expNext: 10,
        goldMultiplier: 1,
        expMultiplier: 1
      };
      
      // 2ì¸ìš© ëª¨ë“œì¼ ë•Œë§Œ í”Œë ˆì´ì–´2 ìŠ¤íƒ¯ ì´ˆê¸°í™”
      if (gameMode === 'multi') {
        stats2 = {
          hp: 1000,
          maxHp: 1000,
          shield: 0,
          atk: 1,
          gold: 0,
          exp: 0,
          level: 1,
          expNext: 10,
          goldMultiplier: 1,
          expMultiplier: 1
        };
      }
      
      message = "ìì‹ ì˜ ì˜ì›…(ğŸ¤º)ì—ì„œ ì‹œì‘í•´ ê²½ë¡œë¥¼ ë§Œë“¤ê³  ë§ˆì§€ë§‰ íƒ€ì¼ì„ í•œë²ˆ ë” í´ë¦­í•˜ì„¸ìš”!<br>ğŸ›¡ï¸ë°©ì–´ë§‰ ğŸ§ªí¬ì…˜ ğŸ’°ì½”ì¸ ğŸ—¡ï¸ê²€ì„ ìˆ˜ì§‘í•˜ì—¬ ëª¬ìŠ¤í„°ì™€ ì‹¸ìš°ì„¸ìš”!";
      board = [];
      let px1 = Math.floor(Math.random() * SIZE);
      let py1 = Math.floor(Math.random() * SIZE);
      
      // 1ì¸ìš© ëª¨ë“œì¼ ë•ŒëŠ” í”Œë ˆì´ì–´2 ìœ„ì¹˜ ì„¤ì •í•˜ì§€ ì•ŠìŒ
      let px2, py2;
      if (gameMode === 'multi') {
        do {
          px2 = Math.floor(Math.random() * SIZE);
          py2 = Math.floor(Math.random() * SIZE);
        } while (px1 === px2 && py1 === py2);
      }
      
      for(let i=0; i<SIZE; i++) {
        board[i] = [];
        for(let j=0; j<SIZE; j++) {
          if(i === px1 && j === py1) {
            board[i][j] = {...PLAYER1};
          } else if(gameMode === 'multi' && i === px2 && j === py2) {
            board[i][j] = {...PLAYER2};
          } else {
            let tile = randomTile();
            board[i][j] = tile;
          }
        }
      }
      player1Pos = [px1, py1];
      if (gameMode === 'multi') {
        player2Pos = [px2, py2];
      }
      selectedPath = [];
      turn = 1;
      updateStats();
      render();
      showMessage(message);
      updateBoardGrid();
      updateTurnIndicator();
    }
    function updateStats() {
      document.getElementById("hp1").textContent = stats1.hp;
      document.getElementById("shield1").textContent = stats1.shield;
      document.getElementById("atk1").textContent = stats1.atk;
      document.getElementById("gold1").textContent = stats1.gold;
      document.getElementById("exp1").textContent = stats1.exp;
      document.getElementById("level1").textContent = stats1.level;
      
      // 2ì¸ìš© ëª¨ë“œì¼ ë•Œë§Œ í”Œë ˆì´ì–´2 ìŠ¤íƒ¯ ì—…ë°ì´íŠ¸
      if (gameMode === 'multi') {
        document.getElementById("hp2").textContent = stats2.hp;
        document.getElementById("shield2").textContent = stats2.shield;
        document.getElementById("atk2").textContent = stats2.atk;
        document.getElementById("gold2").textContent = stats2.gold;
        document.getElementById("exp2").textContent = stats2.exp;
        document.getElementById("level2").textContent = stats2.level;
      }
    }
    function showMessage(msg) {
      document.getElementById("message").innerHTML = msg;
    }
    function updateTurnIndicator() {
      document.getElementById("turn-indicator").style.display = "";
      if (gameMode === 'single') {
        document.getElementById("turn-indicator").textContent = "í”Œë ˆì´ì–´1 í„´ - ì¤‘ë ¥ â†“";
      } else {
        document.getElementById("turn-indicator").textContent =
          turn === 1 ? "í”Œë ˆì´ì–´1(ì—°ë‘) í„´ - ì¤‘ë ¥ â†“" : "í”Œë ˆì´ì–´2(í•‘í¬) í„´ - ì¤‘ë ¥ â†‘";
      }
    }
    function drawPath() {
      // ì´ì „ ê²½ë¡œ ì œê±°
      const oldLines = document.querySelectorAll('.path-line');
      oldLines.forEach(line => line.remove());

      // ìƒˆ ê²½ë¡œ ê·¸ë¦¬ê¸°
      const board = document.getElementById('board');
      const boardRect = board.getBoundingClientRect();

      for(let i = 0; i < selectedPath.length - 1; i++) {
        const [x1, y1] = selectedPath[i];
        const [x2, y2] = selectedPath[i + 1];
        
        const cell1 = document.querySelector(`[data-i="${x1}"][data-j="${y1}"]`);
        const cell2 = document.querySelector(`[data-i="${x2}"][data-j="${y2}"]`);
        
        if(!cell1 || !cell2) continue;
        
        const rect1 = cell1.getBoundingClientRect();
        const rect2 = cell2.getBoundingClientRect();
        
        const line = document.createElement('div');
        line.className = `path-line ${turn === 1 ? 'p1-line' : 'p2-line'}`;
        
        // ë³´ë“œ ë‚´ë¶€ì˜ ìƒëŒ€ì  ìœ„ì¹˜ ê³„ì‚°
        const startX = rect1.left + (rect1.width / 2) - boardRect.left;
        const startY = rect1.top + (rect1.height / 2) - boardRect.top;
        
        // ì„ ì˜ ê¸¸ì´ì™€ ê°ë„ ê³„ì‚°
        const dx = rect2.left - rect1.left;
        const dy = rect2.top - rect1.top;
        const length = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx) * 180 / Math.PI;
        
        // ì„  ìŠ¤íƒ€ì¼ ì„¤ì •
        line.style.width = `${length}px`;
        line.style.left = `${startX}px`;
        line.style.top = `${startY}px`;
        line.style.transform = `rotate(${angle}deg)`;
        
        board.appendChild(line);
      }
    }
    function render() {
      const boardDiv = document.getElementById("board");
      boardDiv.innerHTML = "";
      const cellSize = getCellSize();
      
      boardDiv.style.position = "relative";
      
      for(let i=0; i<SIZE; i++) {
        for(let j=0; j<SIZE; j++) {
          const cell = document.createElement("div");
          cell.className = "cell";
          if(board[i][j].type === "player1") cell.classList.add("hero1");
          if(board[i][j].type === "player2") cell.classList.add("hero2");
          
          // ì„ íƒëœ ê²½ë¡œ í‘œì‹œ
          if(selectedPath.find(([x,y]) => x===i && y===j)) {
            cell.classList.add("selected");
            cell.classList.add(turn === 1 ? "p1-path" : "p2-path");
          }
          
          cell.style.width = cell.style.height = cellSize + "px";
          cell.style.fontSize = (cellSize * 0.68) + "px";
          
          if(board[i][j].type === "troll" || board[i][j].type === "vampire") {
            cell.innerHTML = `${board[i][j].emoji}<div class="info" style="font-size:${Math.max(10,cellSize*0.23)}px">${board[i][j].mon.hp}/${board[i][j].mon.atk}</div>`;
          } else if(board[i][j].type === "player1") {
            cell.innerHTML = `ğŸ¤º<div class="info" style="font-size:${Math.max(10,cellSize*0.23)}px">${stats1.hp}</div>`;
          } else if(gameMode === 'multi' && board[i][j].type === "player2") {
            cell.innerHTML = `ğŸ¤º<div class="info" style="font-size:${Math.max(10,cellSize*0.23)}px">${stats2.hp}</div>`;
          } else if(board[i][j].type === "empty") {
            cell.innerHTML = "";
          } else {
            cell.innerHTML = board[i][j].emoji;
          }
          
          cell.onclick = () => handleSelect(i, j);
          cell.dataset.i = i;
          cell.dataset.j = j;
          boardDiv.appendChild(cell);
        }
      }
      
      updateBoardGrid();
      drawPath();
    }
    function isAdjacent(a, b) {
      return Math.abs(a[0]-b[0]) <= 1 && Math.abs(a[1]-b[1]) <= 1;
    }
    function isSword(i, j) {
      return board[i][j].type === "sword";
    }
    function isTroll(i, j) {
      return board[i][j].type === "troll";
    }
    function isVampire(i, j) {
      return board[i][j].type === "vampire";
    }
    function isMonster(i, j) {
      return isTroll(i, j) || isVampire(i, j);
    }
    function isPlayer1(i, j) {
      return board[i][j].type === "player1";
    }
    function isPlayer2(i, j) {
      return board[i][j].type === "player2";
    }
    function isAllyMonster(i, j) {
      return (turn === 1 && isTroll(i, j)) || (turn === 2 && isVampire(i, j));
    }
    function isEnemyMonster(i, j) {
      return (turn === 1 && isVampire(i, j)) || (turn === 2 && isTroll(i, j));
    }

    // ê²½ë¡œ ì—°ê²° ê·œì¹™ + ìê¸° ë§ë§Œ ì„ íƒ + ì‹¤ì‹œê°„ ê³µê²©ë ¥ ê²€ì‚¬
    function handleSelect(i, j) {
      if(stats1.hp <= 0 || stats2.hp <= 0) return;
      const pos = [i, j];

      // ì²« ì„ íƒì€ ë°˜ë“œì‹œ ìê¸° í”Œë ˆì´ì–´ ìœ„ì¹˜ì—ì„œë§Œ!
      if(selectedPath.length === 0) {
        if((turn === 1 && !isPlayer1(i, j)) || (turn === 2 && !isPlayer2(i, j))) return;
        selectedPath.push(pos);
        render();
        return;
      }

      // ì´ë¯¸ ì„ íƒëœ ìœ„ì¹˜ëŠ” ì„ íƒ ì·¨ì†Œ ë˜ëŠ” ê²½ë¡œ ì‹¤í–‰
      const existingIndex = selectedPath.findIndex(([x,y]) => x===i && y===j);
      if(existingIndex !== -1) {
        // ë§ˆì§€ë§‰ íƒ€ì¼ì„ ë‹¤ì‹œ í´ë¦­í•œ ê²½ìš° ê²½ë¡œ ì‹¤í–‰
        if(existingIndex === selectedPath.length - 1 && selectedPath.length >= 2) {
          // ê²½ë¡œê°€ ìœ íš¨í•œì§€ í™•ì¸ (ê¸°ì¡´ updateActionBtn ë¡œì§ ì¼ë¶€ ì‚¬ìš©)
          const validStart = (turn === 1 && isPlayer1(selectedPath[0][0], selectedPath[0][1])) ||
                            (turn === 2 && isPlayer2(selectedPath[0][0], selectedPath[0][1]));
          
          if(validStart) {
            applySelection();
            return;
          }
        }
        // ë§ˆì§€ë§‰ì´ ì•„ë‹Œ íƒ€ì¼ í´ë¦­ ì‹œ í•´ë‹¹ íƒ€ì¼ê¹Œì§€ë§Œ ê²½ë¡œ ìœ ì§€
        selectedPath = selectedPath.slice(0, existingIndex + 1);
        render();
        return;
      }

      // ì¸ì ‘í•œ ìœ„ì¹˜ë§Œ ì„ íƒ ê°€ëŠ¥
      const last = selectedPath[selectedPath.length-1];
      if(!isAdjacent(last, pos)) return;

      // ì²« ë²ˆì§¸ ì•„ì´í…œ ì¢…ë¥˜ ì²´í¬ (í”Œë ˆì´ì–´ ì„ íƒ ì´í›„ì˜ ì²« ì•„ì´í…œ)
      if(selectedPath.length === 1) {
        // ì•„êµ° ëª¬ìŠ¤í„°ë‚˜ ì  ëª¬ìŠ¤í„° ì²« ì„ íƒ í—ˆìš©
        if(isAllyMonster(i, j) || isEnemyMonster(i, j)) {
          selectedPath.push(pos);
          render();
          return;
        }
      } else if(selectedPath.length > 1) {
        // ë‘ ë²ˆì§¸ ì„ íƒë¶€í„°ëŠ” ì²« ë²ˆì§¸ ì„ íƒí•œ ì•„ì´í…œ ì¢…ë¥˜ì— ë”°ë¼ ë‹¤ë¥´ê²Œ ì²˜ë¦¬
        const firstSelectedType = board[selectedPath[1][0]][selectedPath[1][1]].type;
        const currentType = board[i][j].type;
        
        // ì²« ì„ íƒì´ ì•„êµ° ëª¬ìŠ¤í„°ì˜€ë‹¤ë©´ ë” ì´ìƒ ì„ íƒ ë¶ˆê°€
        if(isAllyMonster(selectedPath[1][0], selectedPath[1][1])) {
          showMessage("ì•„êµ° ëª¬ìŠ¤í„°ëŠ” ì²« ì´ë™ìœ¼ë¡œë§Œ ì„ íƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!");
          return;
        }

        // ì²« ì„ íƒì´ ì  ëª¬ìŠ¤í„°ì¸ ê²½ìš°
        if(isEnemyMonster(selectedPath[1][0], selectedPath[1][1])) {
          // ì¹¼ì´ë‚˜ ë‹¤ë¥¸ ì  ëª¬ìŠ¤í„°ë§Œ ì„ íƒ ê°€ëŠ¥
          if(currentType !== "sword" && !isEnemyMonster(i, j)) {
            showMessage("ëª¬ìŠ¤í„°ë¥¼ ì²˜ì¹˜í•˜ê¸° ìœ„í•´ì„œëŠ” ì¹¼ì„ ëª¨ìœ¼ê±°ë‚˜ ë‹¤ë¥¸ ëª¬ìŠ¤í„°ë¥¼ ì„ íƒí•˜ì„¸ìš”!");
            return;
          }
        }
        // ì²« ì„ íƒì´ ì¹¼ì¸ ê²½ìš°
        if(firstSelectedType === "sword") {
          // ì¹¼ì´ë‚˜ ì  ëª¬ìŠ¤í„°ë§Œ ì„ íƒ ê°€ëŠ¥
          if(currentType !== "sword" && !isEnemyMonster(i, j)) {
            showMessage("ì¹¼ì„ ì„ íƒí•œ í›„ì—ëŠ” ë‹¤ë¥¸ ì¹¼ì´ë‚˜ ì  ëª¬ìŠ¤í„°ë§Œ ì„ íƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!");
            return;
          }
        } 
        // ì²« ì„ íƒì´ ë‹¤ë¥¸ ì•„ì´í…œì¸ ê²½ìš° (ì¹¼ì´ë‚˜ ëª¬ìŠ¤í„°ê°€ ì•„ë‹Œ ê²½ìš°)
        if(!isEnemyMonster(selectedPath[1][0], selectedPath[1][1]) && 
           firstSelectedType !== "sword") {
          // ì²« ë²ˆì§¸ ì„ íƒí•œ ì•„ì´í…œê³¼ ê°™ì€ ì¢…ë¥˜ë§Œ ì„ íƒ ê°€ëŠ¥
          if(currentType !== firstSelectedType) {
            showMessage("ê°™ì€ ì¢…ë¥˜ì˜ ì•„ì´í…œë§Œ ì„ íƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!");
            return;
          }
        }
      }

      selectedPath.push(pos);
      render();
    }

    function applyGravity() {
      let moved;
      do {
        moved = false;
        if(turn === 1) { // í”Œë ˆì´ì–´1 í„´ ì¢…ë£Œ í›„ - ì•„ë˜ë¡œ ì¤‘ë ¥
          // ê¸°ì¡´ íƒ€ì¼ ì•„ë˜ë¡œ ì´ë™
          for(let i = SIZE-2; i >= 0; i--) {
            for(let j = 0; j < SIZE; j++) {
              if(board[i][j].type !== "empty" && 
                 board[i][j].type !== "player1" && 
                 board[i][j].type !== "player2" && 
                 board[i+1][j].type === "empty") {
                board[i+1][j] = board[i][j];
                board[i][j] = {type: "empty"};
                moved = true;
              }
            }
          }
          // ë§¨ ìœ„ ë¹ˆ ê³µê°„ ìƒˆë¡œìš´ íƒ€ì¼ë¡œ ì±„ìš°ê¸°
          if(!moved) {
            for(let j = 0; j < SIZE; j++) {
              if(board[0][j].type === "empty") {
                board[0][j] = randomTile();
                moved = true;
              }
            }
          }
        } else { // í”Œë ˆì´ì–´2 í„´ ì¢…ë£Œ í›„ - ìœ„ë¡œ ì¤‘ë ¥
          // ê¸°ì¡´ íƒ€ì¼ ìœ„ë¡œ ì´ë™
          for(let i = 1; i < SIZE; i++) {
            for(let j = 0; j < SIZE; j++) {
              if(board[i][j].type !== "empty" && 
                 board[i][j].type !== "player1" && 
                 board[i][j].type !== "player2" && 
                 board[i-1][j].type === "empty") {
                board[i-1][j] = board[i][j];
                board[i][j] = {type: "empty"};
                moved = true;
              }
            }
          }
          // ë§¨ ì•„ë˜ ë¹ˆ ê³µê°„ ìƒˆë¡œìš´ íƒ€ì¼ë¡œ ì±„ìš°ê¸°
          if(!moved) {
            for(let j = 0; j < SIZE; j++) {
              if(board[SIZE-1][j].type === "empty") {
                board[SIZE-1][j] = randomTile();
                moved = true;
              }
            }
          }
        }
      } while(moved);

      // ë§ˆì§€ë§‰ìœ¼ë¡œ í•œë²ˆ ë” ë¹ˆ ê³µê°„ í™•ì¸í•˜ê³  ì±„ìš°ê¸°
      if(turn === 1) {
        for(let j = 0; j < SIZE; j++) {
          for(let i = 0; i < SIZE; i++) {
            if(board[i][j].type === "empty") {
              board[i][j] = randomTile();
            }
          }
        }
      } else {
        for(let j = 0; j < SIZE; j++) {
          for(let i = SIZE-1; i >= 0; i--) {
            if(board[i][j].type === "empty") {
              board[i][j] = randomTile();
            }
          }
        }
      }
    }
    function showLevelUpModal(playerStats) {
      // ì´ë¯¸ ë ˆë²¨ì—… ëª¨ë‹¬ì´ ì—´ë ¤ìˆìœ¼ë©´ ì¤‘ë³µ ë°©ì§€
      if (document.querySelector('.levelup-modal')) {
        return;
      }
      
      // ëœë¤í•˜ê²Œ 3ê°œ ì˜µì…˜ ì„ íƒ
      let options = [...LEVEL_UP_OPTIONS]
        .sort(() => Math.random() - 0.5)
        .slice(0, 3);
      
      const modal = document.createElement('div');
      modal.className = 'levelup-modal';
      modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0,0,0,0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
      `;
      
      const content = document.createElement('div');
      content.style.cssText = `
        background: white;
        padding: 20px;
        border-radius: 10px;
        text-align: center;
      `;
      
      content.innerHTML = `
        <h2>ë ˆë²¨ ì—…!</h2>
        <p>ì›í•˜ëŠ” ê°•í™” íš¨ê³¼ë¥¼ ì„ íƒí•˜ì„¸ìš”:</p>
        ${options.map((opt, i) => `
          <button onclick="applyLevelUpOption(${i})" style="display:block; width:100%; margin:10px 0; padding:10px;">
            ${opt.name}<br>
            <small>${opt.effect}</small>
          </button>
        `).join('')}
      `;
      
      modal.appendChild(content);
      document.body.appendChild(modal);
      
      // ESC í‚¤ë¡œ ëª¨ë‹¬ ë‹«ê¸°
      const handleEscape = (e) => {
        if (e.key === 'Escape') {
          document.body.removeChild(modal);
          delete window.applyLevelUpOption;
          document.removeEventListener('keydown', handleEscape);
        }
      };
      document.addEventListener('keydown', handleEscape);
      
      // ëª¨ë‹¬ ì™¸ë¶€ í´ë¦­ìœ¼ë¡œ ë‹«ê¸°
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          document.body.removeChild(modal);
          delete window.applyLevelUpOption;
          document.removeEventListener('keydown', handleEscape);
        }
      });
      
      // ì „ì—­ í•¨ìˆ˜ë¡œ ì„ íƒ í•¸ë“¤ëŸ¬ ì¶”ê°€
      window.applyLevelUpOption = (index) => {
        const selectedOption = options[index];
        selectedOption.apply(playerStats);
        
        // ëª¨ë‹¬ ì œê±°
        document.body.removeChild(modal);
        
        // ì „ì—­ í•¨ìˆ˜ ì •ë¦¬
        delete window.applyLevelUpOption;
        
        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì •ë¦¬
        document.removeEventListener('keydown', handleEscape);
        
        updateStats();
        showMessage(`ë ˆë²¨ ${playerStats.level}: ${selectedOption.name} íš¨ê³¼ê°€ ì ìš©ë˜ì—ˆìŠµë‹ˆë‹¤!`);
      };
    }

    function checkLevelUp(stats) {
      if(stats.exp >= stats.expNext) {
        stats.level += 1;
        stats.exp -= stats.expNext;
        stats.expNext = Math.floor(stats.expNext * 1.5); // ë‹¤ìŒ ë ˆë²¨ì—…ì— í•„ìš”í•œ ê²½í—˜ì¹˜ 1.5ë°°
        showLevelUpModal(stats);
        return true;
      }
      return false;
    }

    function applySelection() {
      if(selectedPath.length < 2) return;
      
      let messages = [];
      let currentStats = turn === 1 ? stats1 : stats2;
      let totalAttackPower = currentStats.atk;
      
      // ê²½ë¡œìƒì˜ ì¹¼ ìˆ˜ì§‘ìœ¼ë¡œ ì¸í•œ ê³µê²©ë ¥ ì¦ê°€ ê³„ì‚°
      for(let i = 0; i < selectedPath.length; i++) {
        const [x, y] = selectedPath[i];
        if(isSword(x, y)) {
          totalAttackPower++;
        }
      }

      // ê²½ë¡œ ì‹¤í–‰ - ì‹œì‘ ìœ„ì¹˜ë¥¼ ë¹„ì›€
      if(turn === 1) {
        board[player1Pos[0]][player1Pos[1]] = {type: "empty"};
      } else if(gameMode === 'multi') {
        board[player2Pos[0]][player2Pos[1]] = {type: "empty"};
      }

      let lastValidPosition = null;  // ë§ˆì§€ë§‰ìœ¼ë¡œ ì´ë™ ê°€ëŠ¥í•œ ìœ„ì¹˜

      // ê²½ë¡œìƒì˜ ì•„ì´í…œ ì²˜ë¦¬
      for(let i = 0; i < selectedPath.length; i++) {
        const [x, y] = selectedPath[i];
        const tile = board[x][y];

        if(tile.type !== "player1" && tile.type !== "player2") {
          // ì•„ì´í…œ íš¨ê³¼ ì ìš©
          if(tile.type === "potion") {
            currentStats.hp = Math.min(currentStats.maxHp, currentStats.hp + 100);
            messages.push("í¬ì…˜ìœ¼ë¡œ ì²´ë ¥ì„ íšŒë³µí–ˆìŠµë‹ˆë‹¤! (+100)");
          } else if(tile.type === "shield") {
            currentStats.shield += 1;
            messages.push("ë°©íŒ¨ë¡œ ë°©ì–´ë ¥ì´ ì¦ê°€í–ˆìŠµë‹ˆë‹¤! (+1)");
          } else if(tile.type === "coin") {
            const goldAmount = 10 * currentStats.goldMultiplier;
            currentStats.gold += goldAmount;
            messages.push(`ì½”ì¸ì„ íšë“í–ˆìŠµë‹ˆë‹¤! (+${goldAmount})`);
          }
          
          // ëª¬ìŠ¤í„° ì²˜ë¦¬
          if(isEnemyMonster(x, y)) {
            const monster = tile.mon;
            const damage = Math.min(totalAttackPower, monster.hp);
            monster.hp -= damage;
            
            if(monster.hp <= 0) {
              // ëª¬ìŠ¤í„° ì²˜ì¹˜
              const expAmount = 2 * currentStats.expMultiplier;
              currentStats.exp += expAmount;
              messages.push(`ëª¬ìŠ¤í„°ë¥¼ ì²˜ì¹˜í•˜ê³  ê²½í—˜ì¹˜ë¥¼ íšë“í–ˆìŠµë‹ˆë‹¤! (+${expAmount})`);
              
              // í¡í˜ˆ íš¨ê³¼ ì ìš©
              if(currentStats.vampiric) {
                const healAmount = currentStats.vampiric;
                currentStats.hp = Math.min(currentStats.maxHp, currentStats.hp + healAmount);
                messages.push(`í¡í˜ˆ íš¨ê³¼ë¡œ ì²´ë ¥ì„ íšŒë³µí–ˆìŠµë‹ˆë‹¤! (+${healAmount})`);
              }

              // ë ˆë²¨ì—… ì²´í¬ (í•œ ë²ˆì— ì—¬ëŸ¬ ë ˆë²¨ì—… ê°€ëŠ¥í•˜ë„ë¡)
              let levelUpCount = 0;
              while(checkLevelUp(currentStats)) {
                levelUpCount++;
              }
              if(levelUpCount > 0) {
                messages.push(`ë ˆë²¨ ${currentStats.level - levelUpCount + 1}ì—ì„œ ${currentStats.level}ë¡œ ë ˆë²¨ì—…!`);
              }
              
              board[x][y] = {type: "empty"};
              lastValidPosition = [x, y];
            } else {
              // ëª¬ìŠ¤í„°ê°€ ì‚´ì•„ìˆìœ¼ë©´ ì—¬ê¸°ì„œ ê²½ë¡œ ì¢…ë£Œ
              messages.push(`ëª¬ìŠ¤í„°ì—ê²Œ ${damage}ì˜ ë°ë¯¸ì§€ë¥¼ ì…í˜”ìŠµë‹ˆë‹¤! (ë‚¨ì€ HP: ${monster.hp})`);
              break;
            }
          } else {
            // ëª¬ìŠ¤í„°ê°€ ì•„ë‹Œ íƒ€ì¼ì€ ë¹„ìš°ê³  ì´ë™ ê°€ëŠ¥ ìœ„ì¹˜ë¡œ í‘œì‹œ
            board[x][y] = {type: "empty"};
            lastValidPosition = [x, y];
          }
        }
      }

      // ë§ˆì§€ë§‰ ìœ íš¨ ìœ„ì¹˜ë¡œ í”Œë ˆì´ì–´ ì´ë™
      if(lastValidPosition) {
        const [lastX, lastY] = lastValidPosition;
        if(turn === 1) {
          board[lastX][lastY] = {...PLAYER1};
          player1Pos = [lastX, lastY];
        } else if(gameMode === 'multi') {
          board[lastX][lastY] = {...PLAYER2};
          player2Pos = [lastX, lastY];
        }
      }

      // ì¤‘ë ¥ ì ìš©
      applyGravity();

      // ë‚¨ì•„ìˆëŠ” ì  ëª¬ìŠ¤í„°ì˜ ê³µê²© ì²˜ë¦¬
      let totalEnemyAttack = 0;
      for(let i = 0; i < SIZE; i++) {
        for(let j = 0; j < SIZE; j++) {
          if(gameMode === 'single') {
            // 1ì¸ìš© ëª¨ë“œ: ë±€íŒŒì´ì–´ë§Œ ê³µê²©
            if(board[i][j].type === "vampire" && board[i][j].mon && board[i][j].mon.hp > 0) {
              const damage = Math.max(0, board[i][j].mon.atk - stats1.shield);
              totalEnemyAttack += damage;
            }
          } else {
            // 2ì¸ìš© ëª¨ë“œ: ê¸°ì¡´ ë¡œì§
            if(turn === 1 && board[i][j].type === "vampire") {
              totalEnemyAttack += Math.max(0, board[i][j].mon.atk - currentStats.shield);
            } else if(turn === 2 && board[i][j].type === "troll") {
              totalEnemyAttack += Math.max(0, board[i][j].mon.atk - currentStats.shield);
            }
          }
        }
      }
      
      if(totalEnemyAttack > 0) {
        if(gameMode === 'single') {
          stats1.hp = Math.max(0, stats1.hp - totalEnemyAttack);
          messages.push(`ë‚¨ì•„ìˆëŠ” ë±€íŒŒì´ì–´ë“¤ì˜ ê³µê²©ìœ¼ë¡œ ${totalEnemyAttack}ì˜ í”¼í•´ë¥¼ ì…ì—ˆìŠµë‹ˆë‹¤!`);
          
          // ì²´ë ¥ì´ 0ì´ ë˜ë©´ ê²Œì„ ì¢…ë£Œ
          if(stats1.hp <= 0) {
            showMessage("ê²Œì„ ì˜¤ë²„! ë‹¤ì‹œ ì‹œì‘í•´ì£¼ì„¸ìš”.");
            return;
          }
        } else {
          currentStats.hp = Math.max(0, currentStats.hp - totalEnemyAttack);
          messages.push(`ë‚¨ì•„ìˆëŠ” ì  ëª¬ìŠ¤í„°ë“¤ì˜ ê³µê²©ìœ¼ë¡œ ${totalEnemyAttack}ì˜ í”¼í•´ë¥¼ ì…ì—ˆìŠµë‹ˆë‹¤!`);
          
          // ì²´ë ¥ì´ 0ì´ ë˜ë©´ ê²Œì„ ì¢…ë£Œ
          if(currentStats.hp <= 0) {
            const winner = turn === 1 ? "í”Œë ˆì´ì–´2" : "í”Œë ˆì´ì–´1";
            showMessage(`ê²Œì„ ì¢…ë£Œ! ${winner}ì˜ ìŠ¹ë¦¬!`);
            return;
          }
        }
      }

      // ìƒíƒœ ì—…ë°ì´íŠ¸
      selectedPath = [];
      
      // 1ì¸ìš© ëª¨ë“œì¼ ë•ŒëŠ” í„´ ì „í™˜í•˜ì§€ ì•ŠìŒ
      if (gameMode === 'multi') {
        turn = turn === 1 ? 2 : 1;
      }
      
      updateStats();
      render();
      if(messages.length > 0) {
        showMessage(messages.join(" "));
      } else {
        showMessage("ì´ë™ ì™„ë£Œ!");
      }
      updateTurnIndicator();
    }

    window.addEventListener('resize', function() {
      render();
      updateBoardGrid();
    });
  </script>
</body>
</html>