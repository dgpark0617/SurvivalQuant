<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>ì£¼í‚¤í¼ ë§¤ì¹˜3</title>
  <style>
    body { 
      font-family: 'Segoe UI Emoji', sans-serif;
      background: #fff;
      color: #333;
      text-align: center;
      margin: 0;
      padding: 20px;
    }
    h1 { 
      margin-top: 20px; 
      color: #764ba2;
    }
    #score { 
      font-size: 1.5em; 
      margin: 10px; 
      color: #4e54c8;
      font-weight: bold;
    }
    #board { 
      display: inline-grid; 
      grid-template-columns: repeat(8, 50px); 
      grid-gap: 3px; 
      margin-top: 20px;
      user-select: none;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
      padding: 10px;
      border-radius: 10px;
      background: #f8f9fa;
    }
    .cell {
      width: 50px; height: 50px; 
      background: #eee;
      border-radius: 8px;
      font-size: 2em;
      display: flex; align-items: center; justify-content: center;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }
    .cell:hover {
      transform: scale(1.05);
      box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
    }
    .selected { 
      background: #fb0; 
      color: #222; 
      transform: scale(1.1);
      box-shadow: 0 0 10px rgba(251, 176, 0, 0.7);
    }
    .hint {
      background: #c7f0d8;
      animation: pulse 1.5s infinite;
    }
    .exploding {
      animation: explode 0.5s forwards;
    }
    @keyframes pulse {
      0% { background-color: #c7f0d8; }
      50% { background-color: #8ed1ab; }
      100% { background-color: #c7f0d8; }
    }
    @keyframes explode {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.3); opacity: 0.8; }
      100% { transform: scale(0.5); opacity: 0; }
    }
    button {
      background: linear-gradient(45deg, #667eea, #764ba2);
      color: white;
      border: none;
      padding: 12px 25px;
      border-radius: 25px;
      cursor: pointer;
      font-size: 1rem;
      font-weight: 500;
      transition: all 0.3s;
      margin-top: 20px;
    }
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
    }
    #timer {
      margin: 10px;
      font-size: 1.2em;
      color: #666;
    }
    #message {
      margin: 10px;
      font-size: 1.2em;
      color: #764ba2;
      height: 1.5em;
    }
    .shuffle-effect {
      animation: shuffle 0.8s;
    }
    @keyframes shuffle {
      0% { transform: rotate(0deg) scale(1); }
      25% { transform: rotate(-5deg) scale(0.95); }
      50% { transform: rotate(5deg) scale(1.05); }
      75% { transform: rotate(-5deg) scale(0.95); }
      100% { transform: rotate(0deg) scale(1); }
    }
  </style>
</head>
<body>
  <h1>ì£¼í‚¤í¼ ë§¤ì¹˜3 ğŸ¦ğŸ¼ğŸ¸</h1>
  <div id="score">ì ìˆ˜: 0</div>
  <div id="timer">ì›€ì§ì„ íŒíŠ¸ê¹Œì§€: 10ì´ˆ</div>
  <div id="message"></div>
  <div id="board"></div>
  <button onclick="restart()">ë‹¤ì‹œ ì‹œì‘</button>
  <script>
    const animals = ["ğŸ¶", "ğŸ±", "ğŸµ", "ğŸ¦", "ğŸ¸", "ğŸ¼", "ğŸ¦Š", "ğŸ¨"];
    const explosionEmojis = ["ğŸ’¥", "ğŸ’«", "âœ¨", "ğŸ‡", "ğŸ†", "âš¡"];
    const N = 8; // ë³´ë“œ í¬ê¸° í™•ì¥
    let board = [];
    let selected = null;
    let score = 0;
    let lastMoveTime = Date.now();
    let hintTimer = null;
    let animating = false;

    function randomAnimal() {
      return animals[Math.floor(Math.random() * animals.length)];
    }

    function randomExplosion() {
      return explosionEmojis[Math.floor(Math.random() * explosionEmojis.length)];
    }

    function makeBoard() {
      board = [];
      for (let y = 0; y < N; y++) {
        let row = [];
        for (let x = 0; x < N; x++) {
          row.push(randomAnimal());
        }
        board.push(row);
      }
      // ì‹œì‘ë¶€í„° ë§¤ì¹˜ê°€ ìˆìœ¼ë©´ ë‹¤ì‹œ ìƒì„±
      while (findMatches().length > 0) {
        for (let y = 0; y < N; y++)
          for (let x = 0; x < N; x++)
            board[y][x] = randomAnimal();
      }
    }

    function drawBoard() {
      const boardDiv = document.getElementById('board');
      boardDiv.innerHTML = '';
      boardDiv.style.gridTemplateColumns = `repeat(${N}, 50px)`;
      
      for (let y = 0; y < N; y++) {
        for (let x = 0; x < N; x++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          if (selected && selected.x === x && selected.y === y) {
            cell.classList.add('selected');
          }
          cell.textContent = board[y][x];
          cell.onclick = () => selectCell(x, y);
          cell.dataset.x = x;
          cell.dataset.y = y;
          boardDiv.appendChild(cell);
        }
      }
      document.getElementById('score').textContent = `ì ìˆ˜: ${score}`;
    }

    function adjacent(a, b) {
      return Math.abs(a.x - b.x) + Math.abs(a.y - b.y) === 1;
    }

    function selectCell(x, y) {
      if (animating) return; // ì• ë‹ˆë©”ì´ì…˜ ì¤‘ì—ëŠ” ì„ íƒ ë¶ˆê°€
      
      clearHints();
      
      if (selected) {
        if (selected.x === x && selected.y === y) {
          selected = null;
        } else if (adjacent(selected, {x, y})) {
          swap(selected, {x, y});
          if (findMatches().length > 0) {
            // ë§¤ì¹˜ ì„±ê³µ ì‹œ íŒíŠ¸ ì‹œê°„ ì´ˆê¸°í™”
            lastMoveTime = Date.now();
            resolveMatches();
          } else {
            swap(selected, {x, y}); // ë˜ëŒë¦¬ê¸°
          }
          selected = null;
        } else {
          selected = {x, y};
        }
      } else {
        selected = {x, y};
      }
      drawBoard();
    }

    function swap(a, b) {
      const tmp = board[a.y][a.x];
      board[a.y][a.x] = board[b.y][b.x];
      board[b.y][b.x] = tmp;
    }

    function findMatches() {
      const matches = [];
      
      // ê°€ë¡œ ê²€ì‚¬ (3ê°œ ì´ìƒ)
      for (let y = 0; y < N; y++) {
        let cnt = 1;
        for (let x = 1; x < N; x++) {
          if (board[y][x] === board[y][x-1]) {
            cnt++;
          } else {
            if (cnt >= 3) matches.push({y, x1:x-cnt, x2:x-1});
            cnt = 1;
          }
        }
        if (cnt >= 3) matches.push({y, x1:N-cnt, x2:N-1});
      }
      
      // ì„¸ë¡œ ê²€ì‚¬ (3ê°œ ì´ìƒ)
      for (let x = 0; x < N; x++) {
        let cnt = 1;
        for (let y = 1; y < N; y++) {
          if (board[y][x] === board[y-1][x]) {
            cnt++;
          } else {
            if (cnt >= 3) matches.push({x, y1:y-cnt, y2:y-1, vertical:true});
            cnt = 1;
          }
        }
        if (cnt >= 3) matches.push({x, y1:N-cnt, y2:N-1, vertical:true});
      }
      
      // 2x2 ì •ì‚¬ê°í˜• íŒ¨í„´ ê²€ì‚¬ ì¶”ê°€
      for (let y = 0; y < N-1; y++) {
        for (let x = 0; x < N-1; x++) {
          const current = board[y][x];
          if (current === board[y][x+1] && 
              current === board[y+1][x] && 
              current === board[y+1][x+1]) {
            matches.push({square: true, x, y});
          }
        }
      }
      
      return matches;
    }

    function resolveMatches() {
      animating = true;
      
      // ì›ë˜ ë¡œì§ê³¼ ìœ ì‚¬í•˜ê²Œ do-while ë£¨í”„ ì‚¬ìš©
      let matched, anyMatch = false;
      do {
        matched = Array.from(Array(N), () => Array(N).fill(false));
        const matches = findMatches();
        anyMatch = matches.length > 0;
        
        if (!anyMatch) {
          animating = false;
          break;
        }
        
        // ë§¤ì¹˜ëœ ì…€ í‘œì‹œ
        for (const m of matches) {
          if (m.vertical) {
            for (let y = m.y1; y <= m.y2; y++) matched[y][m.x] = true;
          } else if (m.square) {
            matched[m.y][m.x] = true;
            matched[m.y][m.x+1] = true;
            matched[m.y+1][m.x] = true;
            matched[m.y+1][m.x+1] = true;
          } else {
            for (let x = m.x1; x <= m.x2; x++) matched[m.y][x] = true;
          }
        }
        
        // ë§¤ì¹˜ëœ íƒ€ì¼ì„ í­ë°œ ì´ëª¨í‹°ì½˜ìœ¼ë¡œ ë³€ê²½í•˜ê³  ì• ë‹ˆë©”ì´ì…˜ íš¨ê³¼ ì ìš©
        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            if (matched[y][x]) {
              const cell = document.querySelector(`.cell[data-x="${x}"][data-y="${y}"]`);
              if (cell) {
                cell.textContent = randomExplosion();
                cell.classList.add('exploding');
              }
            }
          }
        }
        
        // ì ìˆ˜ ê³„ì‚°
        let removed = 0;
        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            if (matched[y][x]) {
              removed++;
            }
          }
        }
        
        score += removed * 10;
        document.getElementById('score').textContent = `ì ìˆ˜: ${score}`;
        
        // ì ì‹œ ëŒ€ê¸° í›„ íƒ€ì¼ ì œê±° ë° ë‚´ë¦¬ê¸°
        setTimeout(() => {
          // ë§¤ì¹˜ëœ ì…€ ì œê±°
          for (let y = 0; y < N; y++) {
            for (let x = 0; x < N; x++) {
              if (matched[y][x]) {
                board[y][x] = null;
              }
            }
          }
          
          // ì•„ë˜ë¡œ ë‚´ë¦¬ê¸°
          for (let x = 0; x < N; x++) {
            let col = [];
            for (let y = N-1; y >= 0; y--) {
              if (board[y][x]) col.push(board[y][x]);
            }
            while (col.length < N) col.push(randomAnimal());
            for (let y = N-1; y >= 0; y--) board[y][x] = col[N-1-y];
          }
          
          drawBoard();
          
          // ì—°ì‡„ ë§¤ì¹˜ í™•ì¸
          if (findMatches().length > 0) {
            resolveMatches();
          } else {
            // ê°€ëŠ¥í•œ ì›€ì§ì„ì´ ì—†ëŠ”ì§€ í™•ì¸
            if (findPossibleMoves().length === 0) {
              shuffleBoard();
            } else {
              animating = false;
            }
          }
        }, 600);
        
        return; // setTimeout ë‚´ì—ì„œ ì²˜ë¦¬í•˜ë¯€ë¡œ ì—¬ê¸°ì„œ ì¢…ë£Œ
        
      } while (false); // setTimeoutìœ¼ë¡œ ëŒ€ì²´í–ˆìœ¼ë¯€ë¡œ ë£¨í”„ëŠ” í•œ ë²ˆë§Œ ì‹¤í–‰
    }

    function shuffleBoard() {
      showMessage("ê°€ëŠ¥í•œ ì›€ì§ì„ì´ ì—†ìŠµë‹ˆë‹¤. íƒ€ì¼ì„ ì„ìŠµë‹ˆë‹¤!");
      
      // ë³´ë“œì— ì„ëŠ” íš¨ê³¼ ì ìš©
      const boardDiv = document.getElementById('board');
      boardDiv.classList.add('shuffle-effect');
      
      setTimeout(() => {
        // íƒ€ì¼ ëœë¤ ì¬ë°°ì¹˜
        makeBoard();
        drawBoard();
        boardDiv.classList.remove('shuffle-effect');
        
        // ê°€ëŠ¥í•œ ì›€ì§ì„ì´ ìˆëŠ”ì§€ í™•ì¸
        if (findPossibleMoves().length === 0) {
          // ë‹¤ì‹œ ì„ê¸°
          shuffleBoard();
        } else {
          animating = false;
        }
      }, 800);
    }

    function findPossibleMoves() {
      const possibleMoves = [];
      
      // ëª¨ë“  ì¸ì ‘í•œ ì…€ ìŒì„ í™•ì¸
      for (let y = 0; y < N; y++) {
        for (let x = 0; x < N; x++) {
          // ì˜¤ë¥¸ìª½ê³¼ êµí™˜
          if (x < N-1) {
            swap({x, y}, {x: x+1, y});
            if (findMatches().length > 0) {
              possibleMoves.push({x1: x, y1: y, x2: x+1, y2: y});
            }
            swap({x, y}, {x: x+1, y}); // ë˜ëŒë¦¬ê¸°
          }
          
          // ì•„ë˜ì™€ êµí™˜
          if (y < N-1) {
            swap({x, y}, {x, y: y+1});
            if (findMatches().length > 0) {
              possibleMoves.push({x1: x, y1: y, x2: x, y2: y+1});
            }
            swap({x, y}, {x, y: y+1}); // ë˜ëŒë¦¬ê¸°
          }
        }
      }
      
      return possibleMoves;
    }

    function showHints() {
      if (Date.now() - lastMoveTime < 10000) return; // 10ì´ˆ ë¯¸ë§Œì´ë©´ íŒíŠ¸ í‘œì‹œ ì•ˆí•¨
      
      clearHints();
      const moves = findPossibleMoves();
      
      if (moves.length > 0) {
        // ëœë¤í•˜ê²Œ í•˜ë‚˜ì˜ ê°€ëŠ¥í•œ ì›€ì§ì„ ì„ íƒ
        const move = moves[Math.floor(Math.random() * moves.length)];
        
        // íŒíŠ¸ í‘œì‹œ
        const cell1 = document.querySelector(`.cell[data-x="${move.x1}"][data-y="${move.y1}"]`);
        const cell2 = document.querySelector(`.cell[data-x="${move.x2}"][data-y="${move.y2}"]`);
        
        if (cell1) cell1.classList.add('hint');
        if (cell2) cell2.classList.add('hint');
      } else {
        // ê°€ëŠ¥í•œ ì›€ì§ì„ì´ ì—†ìœ¼ë©´ íƒ€ì¼ ì„ê¸°
        shuffleBoard();
      }
    }

    function clearHints() {
      const hints = document.querySelectorAll('.hint');
      hints.forEach(hint => hint.classList.remove('hint'));
    }

    function showMessage(msg) {
      const messageEl = document.getElementById('message');
      messageEl.textContent = msg;
      
      // 3ì´ˆ í›„ ë©”ì‹œì§€ ì œê±°
      setTimeout(() => {
        messageEl.textContent = '';
      }, 3000);
    }

    function updateTimer() {
      const elapsed = Math.floor((Date.now() - lastMoveTime) / 1000);
      const remaining = Math.max(0, 10 - elapsed);
      document.getElementById('timer').textContent = `ì›€ì§ì„ íŒíŠ¸ê¹Œì§€: ${remaining}ì´ˆ`;
      
      if (elapsed >= 10) {
        showHints();
      }
    }

    function restart() {
      score = 0;
      selected = null;
      lastMoveTime = Date.now();
      clearHints();
      makeBoard();
      drawBoard();
    }

    // ì´ˆê¸°í™”
    restart();
    
    // íƒ€ì´ë¨¸ ì„¤ì •
    setInterval(updateTimer, 1000);
  </script>
</body>
</html> 