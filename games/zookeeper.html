<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>ì£¼í‚¤í¼ ë§¤ì¹˜3</title>
  <style>
    body { 
      font-family: 'Segoe UI Emoji', sans-serif;
      background: #fff;
      color: #333;
      text-align: center;
      margin: 0;
      padding: 20px;
    }
    h1 { 
      margin-top: 20px; 
      color: #764ba2;
    }
    #score { 
      font-size: 1.5em; 
      margin: 10px; 
      color: #4e54c8;
      font-weight: bold;
    }
    #board { 
      display: inline-grid; 
      grid-template-columns: repeat(8, 50px); 
      grid-gap: 3px; 
      margin-top: 20px;
      user-select: none;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
      padding: 10px;
      border-radius: 10px;
      background: #f8f9fa;
    }
    .cell {
      width: 50px; height: 50px; 
      background: #eee;
      border-radius: 8px;
      font-size: 2em;
      display: flex; align-items: center; justify-content: center;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }
    .cell:hover {
      transform: scale(1.05);
      box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
    }
    .selected { 
      background: #fb0; 
      color: #222; 
      transform: scale(1.1);
      box-shadow: 0 0 10px rgba(251, 176, 0, 0.7);
    }
    .hint {
      background: #c7f0d8;
      animation: pulse 1.5s infinite;
    }
    .removing {
      animation: pop 0.5s;
      opacity: 0;
    }
    .falling {
      animation: fall 0.5s;
    }
    .new-tile {
      animation: drop-in 0.5s;
    }
    @keyframes pulse {
      0% { background-color: #c7f0d8; }
      50% { background-color: #8ed1ab; }
      100% { background-color: #c7f0d8; }
    }
    @keyframes pop {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.2); opacity: 0.5; }
      100% { transform: scale(0); opacity: 0; }
    }
    @keyframes fall {
      0% { transform: translateY(-50px); }
      100% { transform: translateY(0); }
    }
    @keyframes drop-in {
      0% { transform: translateY(-50px); opacity: 0; }
      100% { transform: translateY(0); opacity: 1; }
    }
    button {
      background: linear-gradient(45deg, #667eea, #764ba2);
      color: white;
      border: none;
      padding: 12px 25px;
      border-radius: 25px;
      cursor: pointer;
      font-size: 1rem;
      font-weight: 500;
      transition: all 0.3s;
      margin-top: 20px;
    }
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
    }
    #timer {
      margin: 10px;
      font-size: 1.2em;
      color: #666;
    }
  </style>
</head>
<body>
  <h1>ì£¼í‚¤í¼ ë§¤ì¹˜3 ğŸ¦ğŸ¼ğŸ¸</h1>
  <div id="score">ì ìˆ˜: 0</div>
  <div id="timer">ì›€ì§ì„ íŒíŠ¸ê¹Œì§€: 10ì´ˆ</div>
  <div id="board"></div>
  <button onclick="restart()">ë‹¤ì‹œ ì‹œì‘</button>
  <script>
    const animals = ["ğŸ¶", "ğŸ±", "ğŸµ", "ğŸ¦", "ğŸ¸", "ğŸ¼", "ğŸ¦Š", "ğŸ¨"];
    const N = 8; // ë³´ë“œ í¬ê¸° í™•ì¥
    let board = [];
    let selected = null;
    let score = 0;
    let lastMoveTime = Date.now();
    let hintTimer = null;
    let animating = false;

    function randomAnimal() {
      return animals[Math.floor(Math.random() * animals.length)];
    }

    function makeBoard() {
      board = [];
      for (let y = 0; y < N; y++) {
        let row = [];
        for (let x = 0; x < N; x++) {
          row.push(randomAnimal());
        }
        board.push(row);
      }
      // ì‹œì‘ë¶€í„° ë§¤ì¹˜ê°€ ìˆìœ¼ë©´ ë‹¤ì‹œ ìƒì„±
      while (findMatches().length > 0) {
        for (let y = 0; y < N; y++)
          for (let x = 0; x < N; x++)
            board[y][x] = randomAnimal();
      }
    }

    function drawBoard() {
      const boardDiv = document.getElementById('board');
      boardDiv.innerHTML = '';
      boardDiv.style.gridTemplateColumns = `repeat(${N}, 50px)`;
      
      for (let y = 0; y < N; y++) {
        for (let x = 0; x < N; x++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          if (selected && selected.x === x && selected.y === y) {
            cell.classList.add('selected');
          }
          cell.textContent = board[y][x];
          cell.onclick = () => selectCell(x, y);
          cell.dataset.x = x;
          cell.dataset.y = y;
          boardDiv.appendChild(cell);
        }
      }
      document.getElementById('score').textContent = `ì ìˆ˜: ${score}`;
    }

    function adjacent(a, b) {
      return Math.abs(a.x - b.x) + Math.abs(a.y - b.y) === 1;
    }

    function selectCell(x, y) {
      if (animating) return; // ì• ë‹ˆë©”ì´ì…˜ ì¤‘ì—ëŠ” ì„ íƒ ë¶ˆê°€
      
      lastMoveTime = Date.now();
      clearHints();
      
      if (selected) {
        if (selected.x === x && selected.y === y) {
          selected = null;
        } else if (adjacent(selected, {x, y})) {
          swap(selected, {x, y});
          if (findMatches().length > 0) {
            resolveMatches();
          } else {
            swap(selected, {x, y}); // ë˜ëŒë¦¬ê¸°
          }
          selected = null;
        } else {
          selected = {x, y};
        }
      } else {
        selected = {x, y};
      }
      drawBoard();
    }

    function swap(a, b) {
      const tmp = board[a.y][a.x];
      board[a.y][a.x] = board[b.y][b.x];
      board[b.y][b.x] = tmp;
    }

    function findMatches() {
      const matches = [];
      
      // ê°€ë¡œ ê²€ì‚¬ (3ê°œ ì´ìƒ)
      for (let y = 0; y < N; y++) {
        let cnt = 1;
        for (let x = 1; x < N; x++) {
          if (board[y][x] === board[y][x-1]) {
            cnt++;
          } else {
            if (cnt >= 3) matches.push({y, x1:x-cnt, x2:x-1});
            cnt = 1;
          }
        }
        if (cnt >= 3) matches.push({y, x1:N-cnt, x2:N-1});
      }
      
      // ì„¸ë¡œ ê²€ì‚¬ (3ê°œ ì´ìƒ)
      for (let x = 0; x < N; x++) {
        let cnt = 1;
        for (let y = 1; y < N; y++) {
          if (board[y][x] === board[y-1][x]) {
            cnt++;
          } else {
            if (cnt >= 3) matches.push({x, y1:y-cnt, y2:y-1, vertical:true});
            cnt = 1;
          }
        }
        if (cnt >= 3) matches.push({x, y1:N-cnt, y2:N-1, vertical:true});
      }
      
      // 2x2 ì •ì‚¬ê°í˜• íŒ¨í„´ ê²€ì‚¬ ì¶”ê°€
      for (let y = 0; y < N-1; y++) {
        for (let x = 0; x < N-1; x++) {
          const current = board[y][x];
          if (current === board[y][x+1] && 
              current === board[y+1][x] && 
              current === board[y+1][x+1]) {
            matches.push({square: true, x, y});
          }
        }
      }
      
      return matches;
    }

    function resolveMatches() {
      animating = true;
      
      let matched = Array.from(Array(N), () => Array(N).fill(false));
      const matches = findMatches();
      let anyMatch = matches.length > 0;
      
      if (!anyMatch) {
        animating = false;
        return;
      }
      
      // ë§¤ì¹˜ëœ ì…€ í‘œì‹œ
      for (const m of matches) {
        if (m.vertical) {
          for (let y = m.y1; y <= m.y2; y++) matched[y][m.x] = true;
        } else if (m.square) {
          matched[m.y][m.x] = true;
          matched[m.y][m.x+1] = true;
          matched[m.y+1][m.x] = true;
          matched[m.y+1][m.x+1] = true;
        } else {
          for (let x = m.x1; x <= m.x2; x++) matched[m.y][x] = true;
        }
      }
      
      // ì• ë‹ˆë©”ì´ì…˜ íš¨ê³¼ì™€ ì ìˆ˜ ê³„ì‚°
      let removed = 0;
      for (let y = 0; y < N; y++) {
        for (let x = 0; x < N; x++) {
          if (matched[y][x]) {
            const cell = document.querySelector(`.cell[data-x="${x}"][data-y="${y}"]`);
            if (cell) {
              cell.classList.add('removing');
              removed++;
            }
          }
        }
      }
      
      score += removed * 10;
      document.getElementById('score').textContent = `ì ìˆ˜: ${score}`;
      
      // ì• ë‹ˆë©”ì´ì…˜ í›„ ì²˜ë¦¬
      setTimeout(() => {
        // ë§¤ì¹˜ëœ ì…€ ì œê±° ë° ìƒˆ ë³´ë“œ ìƒíƒœ ê³„ì‚°
        let newBoard = Array.from(Array(N), () => Array(N).fill(null));
        let newTiles = Array.from(Array(N), () => Array(N).fill(false));
        
        // ê° ì—´ì— ëŒ€í•´ ì²˜ë¦¬
        for (let x = 0; x < N; x++) {
          let destRow = N - 1; // ì•„ë˜ë¶€í„° ì±„ìš°ê¸°
          
          // ê¸°ì¡´ íƒ€ì¼ ì¤‘ ë§¤ì¹˜ë˜ì§€ ì•Šì€ ê²ƒë“¤ì„ ì•„ë˜ë¶€í„° ì±„ì›€
          for (let y = N - 1; y >= 0; y--) {
            if (!matched[y][x]) {
              newBoard[destRow][x] = board[y][x];
              destRow--;
            }
          }
          
          // ë¹ˆ ê³µê°„ì„ ìƒˆ íƒ€ì¼ë¡œ ì±„ì›€
          for (let y = destRow; y >= 0; y--) {
            newBoard[y][x] = randomAnimal();
            newTiles[y][x] = true; // ìƒˆë¡œ ìƒì„±ëœ íƒ€ì¼ í‘œì‹œ
          }
        }
        
        // ë³´ë“œ ìƒíƒœ ì—…ë°ì´íŠ¸
        board = newBoard;
        drawBoard();
        
        // ì• ë‹ˆë©”ì´ì…˜ ì ìš©
        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            const cell = document.querySelector(`.cell[data-x="${x}"][data-y="${y}"]`);
            if (cell) {
              if (newTiles[y][x]) {
                cell.classList.add('new-tile'); // ìƒˆ íƒ€ì¼ì€ ìœ„ì—ì„œ ë–¨ì–´ì§€ëŠ” ì• ë‹ˆë©”ì´ì…˜
              } else {
                cell.classList.add('falling'); // ê¸°ì¡´ íƒ€ì¼ì€ ì•„ë˜ë¡œ ì´ë™í•˜ëŠ” ì• ë‹ˆë©”ì´ì…˜
              }
            }
          }
        }
        
        // ì—°ì‡„ ë§¤ì¹˜ í™•ì¸
        setTimeout(() => {
          if (findMatches().length > 0) {
            resolveMatches();
          } else {
            animating = false;
          }
        }, 500);
      }, 500);
    }

    function findPossibleMoves() {
      const possibleMoves = [];
      
      // ëª¨ë“  ì¸ì ‘í•œ ì…€ ìŒì„ í™•ì¸
      for (let y = 0; y < N; y++) {
        for (let x = 0; x < N; x++) {
          // ì˜¤ë¥¸ìª½ê³¼ êµí™˜
          if (x < N-1) {
            swap({x, y}, {x: x+1, y});
            if (findMatches().length > 0) {
              possibleMoves.push({x1: x, y1: y, x2: x+1, y2: y});
            }
            swap({x, y}, {x: x+1, y}); // ë˜ëŒë¦¬ê¸°
          }
          
          // ì•„ë˜ì™€ êµí™˜
          if (y < N-1) {
            swap({x, y}, {x, y: y+1});
            if (findMatches().length > 0) {
              possibleMoves.push({x1: x, y1: y, x2: x, y2: y+1});
            }
            swap({x, y}, {x, y: y+1}); // ë˜ëŒë¦¬ê¸°
          }
        }
      }
      
      return possibleMoves;
    }

    function showHints() {
      if (Date.now() - lastMoveTime < 10000) return; // 10ì´ˆ ë¯¸ë§Œì´ë©´ íŒíŠ¸ í‘œì‹œ ì•ˆí•¨
      
      clearHints();
      const moves = findPossibleMoves();
      
      if (moves.length > 0) {
        // ëœë¤í•˜ê²Œ í•˜ë‚˜ì˜ ê°€ëŠ¥í•œ ì›€ì§ì„ ì„ íƒ
        const move = moves[Math.floor(Math.random() * moves.length)];
        
        // íŒíŠ¸ í‘œì‹œ
        const cell1 = document.querySelector(`.cell[data-x="${move.x1}"][data-y="${move.y1}"]`);
        const cell2 = document.querySelector(`.cell[data-x="${move.x2}"][data-y="${move.y2}"]`);
        
        if (cell1) cell1.classList.add('hint');
        if (cell2) cell2.classList.add('hint');
      }
    }

    function clearHints() {
      const hints = document.querySelectorAll('.hint');
      hints.forEach(hint => hint.classList.remove('hint'));
    }

    function updateTimer() {
      const elapsed = Math.floor((Date.now() - lastMoveTime) / 1000);
      const remaining = Math.max(0, 10 - elapsed);
      document.getElementById('timer').textContent = `ì›€ì§ì„ íŒíŠ¸ê¹Œì§€: ${remaining}ì´ˆ`;
      
      if (elapsed >= 10) {
        showHints();
      }
    }

    function restart() {
      score = 0;
      selected = null;
      lastMoveTime = Date.now();
      clearHints();
      makeBoard();
      drawBoard();
    }

    // ì´ˆê¸°í™”
    restart();
    
    // íƒ€ì´ë¨¸ ì„¤ì •
    setInterval(updateTimer, 1000);
  </script>
</body>
</html> 