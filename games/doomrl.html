<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <title>Doom Emoji RL (Emoji-based, JS, One File, Customizable, True Turn-based Reload)</title>
  <style>
    body { 
      background: #222; 
      color: #eee; 
      font-family: 'Courier New', monospace; 
      text-align: center;
      margin: 0;
      padding: 20px;
    }
    #game-container {
      display: inline-block;
      margin: 0 auto;
      max-width: 100%;
    }
    #game-grid {
      display: grid;
      grid-template-columns: repeat(30, 1fr);
      gap: 0px;
      margin-bottom: 10px;
      background-color: #111;
      border: 2px solid #444;
      padding: 5px;
    }
    .cell {
      width: 20px;
      height: 20px;
      font-size: 18px;
      line-height: 20px;
      text-align: center;
      user-select: none;
      background-color: #fff; /* ëª¨ë“  ì…€ì˜ ê¸°ë³¸ ë°°ê²½ìƒ‰ì„ í°ìƒ‰ìœ¼ë¡œ ì„¤ì • */
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      box-sizing: border-box; /* ì¶”ê°€: borderì™€ paddingì„ ìš”ì†Œ í¬ê¸°ì— í¬í•¨ */
    }
    /* ì¡°ì¤€ ê²½ë¡œ í•˜ì´ë¼ì´íŠ¸ë¥¼ ìœ„í•œ í´ë˜ìŠ¤ */
    .aim-path {
      position: relative;
      background-color: rgba(255, 255, 0, 0.2) !important; /* ì—°í•œ ë…¸ë€ìƒ‰ ë°°ê²½ */
      font-weight: bold;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
    }
    #status-bar {
      font-size: 16px;
      margin-bottom: 5px;
      padding: 5px;
      background-color: #333;
      border: 1px solid #555;
      text-align: left;
    }
    #message-log {
      height: 80px;
      overflow-y: auto;
      font-size: 14px;
      margin-top: 5px;
      margin-bottom: 10px;
      padding: 5px;
      background-color: #333;
      border: 1px solid #555;
      text-align: left;
    }
    #turn-timer {
      margin-bottom: 10px;
      padding: 5px;
      background-color: #333;
      border: 1px solid #555;
    }
    #turn-timer-bar {
      height: 10px;
      background-color: #444;
    }
    #mobile-controls {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-top: 15px;
      user-select: none;
    }
    .controls-row {
      display: flex;
      justify-content: center;
      margin-bottom: 5px;
    }
    .dir-btn, .action-btn {
      width: 50px;
      height: 50px;
      margin: 0 5px;
      font-size: 24px;
      background-color: #444;
      border: 2px solid #666;
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
    }
    .dir-btn:active, .action-btn:active {
      background-color: #666;
      transform: scale(0.95);
    }
    .action-row {
      margin-top: 10px;
    }
    .action-btn {
      background-color: #553355;
    }
    /* ë°ìŠ¤í¬íƒ‘ ìµœì í™” */
    @media (min-width: 769px) {
      .cell {
        width: 22px;
        height: 22px;
        font-size: 16px;
        line-height: 1;
      }
    }
    /* ëª¨ë°”ì¼ ìµœì í™” */
    @media (max-width: 768px) {
      body {
        padding: 10px 5px;
      }
      .cell {
        width: 18px;
        height: 18px;
        font-size: 16px;
        line-height: 1;
      }
      .dir-btn, .action-btn {
        width: 45px;
        height: 45px;
        margin: 0 3px;
      }
    }
    /* ì‘ì€ í™”ë©´ ìµœì í™” */
    @media (max-width: 480px) {
      .cell {
        width: 16px;
        height: 16px;
        font-size: 14px;
        line-height: 1;
      }
      .dir-btn, .action-btn {
        width: 40px;
        height: 40px;
        font-size: 20px;
      }
    }
    .hidden {
      visibility: hidden;
    }
    /* ì‹œì•¼ ë°– ì˜ì—­ë§Œ ê²€ì€ìƒ‰ìœ¼ë¡œ ì„¤ì • */
    .wall { background-color: #fff; } /* ë²½ë„ í°ìƒ‰ ë°°ê²½ìœ¼ë¡œ ë³€ê²½ */
    .floor { background-color: #fff; } /* ë°”ë‹¥ ë°°ê²½ìƒ‰ì„ í°ìƒ‰ìœ¼ë¡œ ìœ ì§€ */
    .hidden-cell { background-color: #000; } /* ì‹œì•¼ ë°– ì˜ì—­ì€ ê²€ì€ìƒ‰ */
    .grass { background-color: #fff; } /* ì”ë”” ë°°ê²½ìƒ‰ë„ í°ìƒ‰ìœ¼ë¡œ ë³€ê²½ */
    .desert { background-color: #fff; } /* ì‚¬ë§‰ ë°°ê²½ìƒ‰ë„ í°ìƒ‰ìœ¼ë¡œ ë³€ê²½ */
    .water { background-color: #fff; } /* ë¬¼ ë°°ê²½ìƒ‰ë„ í°ìƒ‰ìœ¼ë¡œ ë³€ê²½ */
    .mountain { background-color: #fff; } /* ì‚° ë°°ê²½ìƒ‰ë„ í°ìƒ‰ìœ¼ë¡œ ë³€ê²½ */
    .lava { background-color: #fff; } /* í™”ì‚°/ìš©ì•” ë°°ê²½ìƒ‰ë„ í°ìƒ‰ìœ¼ë¡œ ë³€ê²½ */
    
    /* ìƒˆë¡œìš´ ë°”ì´ì˜´ ìŠ¤íƒ€ì¼ */
    .forest { background-color: #fff; } /* ìˆ² ë°°ê²½ìƒ‰ */
    .swamp { background-color: #fff; } /* ëŠªì§€ëŒ€ ë°°ê²½ìƒ‰ */
    .snow { background-color: #fff; } /* ëˆˆ ë°°ê²½ìƒ‰ */
    .ruins { background-color: #fff; } /* íí—ˆ ë°°ê²½ìƒ‰ */
    .cave { background-color: #fff; } /* ë™êµ´ ë°°ê²½ìƒ‰ */
    .village { background-color: #fff; } /* ë§ˆì„ ë°°ê²½ìƒ‰ */
    .wasteland { background-color: #fff; } /* í™©ë¬´ì§€ ë°°ê²½ìƒ‰ */
    .dungeon { background-color: #fff; } /* ë˜ì „ ë°°ê²½ìƒ‰ */
    
    /* ë§µ ì„ íƒ UI */
    #map-select-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    
    #map-select-title {
      font-size: 24px;
      margin-bottom: 20px;
      color: #fff;
    }
    
    #map-select-options {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 15px;
      width: 80%;
      max-width: 600px;
    }
    
    .map-option {
      background-color: #333;
      border: 2px solid #555;
      border-radius: 8px;
      padding: 15px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .map-option:hover {
      background-color: #444;
      transform: scale(1.05);
    }
    
    .map-option h3 {
      margin-top: 0;
      color: #fff;
    }
    
    .map-option p {
      color: #ccc;
      font-size: 14px;
    }
    
    .map-option-emoji {
      font-size: 32px;
      margin-bottom: 10px;
    }
  </style>
</head>
<body>
<div id="game-container">
  <div id="status-bar"></div>
  <div id="game-grid"></div>
  <div id="message-log"></div>
  <div id="turn-timer">
    <div id="turn-timer-bar"></div>
  </div>
  <div id="mobile-controls">
    <div class="controls-row">
      <button class="dir-btn" data-dir="6">â†–ï¸</button>
      <button class="dir-btn" data-dir="7">â¬†ï¸</button>
      <button class="dir-btn" data-dir="8">â†—ï¸</button>
    </div>
    <div class="controls-row">
      <button class="dir-btn" data-dir="3">â¬…ï¸</button>
      <button class="action-btn" id="aim-btn">ğŸ”«</button>
      <button class="dir-btn" data-dir="5">â¡ï¸</button>
    </div>
    <div class="controls-row">
      <button class="dir-btn" data-dir="0">â†™ï¸</button>
      <button class="dir-btn" data-dir="1">â¬‡ï¸</button>
      <button class="dir-btn" data-dir="2">â†˜ï¸</button>
    </div>
    <div class="controls-row action-row">
      <button class="action-btn" id="reload-btn">ğŸ”„</button>
      <button class="action-btn" id="run-btn">ğŸ‘Ÿ</button>
      <button class="action-btn" id="weapon-btn">ğŸ”«âš¡</button>
    </div>
  </div>
</div>

<!-- ë§µ ì„ íƒ UI -->
<div id="map-select-container">
  <h2 id="map-select-title">ë§µ íƒ€ì… ì„ íƒ</h2>
  <div id="map-select-options">
    <div class="map-option" data-map-type="mixed">
      <div class="map-option-emoji">ğŸŒ</div>
      <h3>í˜¼í•©í˜•</h3>
      <p>ë‹¤ì–‘í•œ ì§€í˜•ê³¼ êµ¬ì¡°ë¬¼ì´ í˜¼í•©ëœ ê· í˜• ì¡íŒ ë§µ</p>
    </div>
    <div class="map-option" data-map-type="wilderness">
      <div class="map-option-emoji">ğŸŒ²</div>
      <h3>ìì—° í™˜ê²½</h3>
      <p>ìˆ², ê°•, ì‚° ë“± ìì—° ì§€í˜•ì´ í’ë¶€í•œ ë§µ</p>
    </div>
    <div class="map-option" data-map-type="dungeon">
      <div class="map-option-emoji">ğŸ°</div>
      <h3>ë˜ì „</h3>
      <p>ë¯¸ë¡œì™€ í†µë¡œê°€ ë§ì€ ë˜ì „ ìŠ¤íƒ€ì¼ ë§µ</p>
    </div>
    <div class="map-option" data-map-type="village">
      <div class="map-option-emoji">ğŸ˜ï¸</div>
      <h3>ë§ˆì„</h3>
      <p>ë§ˆì„ê³¼ ê±´ë¬¼ì´ ë§ì€ ì •ì°©ì§€ ì¤‘ì‹¬ ë§µ</p>
    </div>
    <div class="map-option" data-map-type="wasteland">
      <div class="map-option-emoji">â˜¢ï¸</div>
      <h3>í™©ë¬´ì§€</h3>
      <p>ìœ„í—˜ ì§€ì—­ì´ ë§ì€ í™©íí•œ í™˜ê²½ì˜ ë§µ</p>
    </div>
  </div>
</div>
<script>
// ======= Game configuration (difficulty & settings) =======
const MAP_W = 100;            // Map width
const MAP_H = 100;            // Map height
const VIEW_R = 8;             // Sight radius
const SCREEN_W = 30;          // Displayed area width
const SCREEN_H = 20;          // Displayed area height
const MONSTER_COUNT = 100;     // Number of monsters
const UNICORN_COUNT = 3;     // Number of unicorns
const PLAYER_START_HP = 10;   // Player HP
const PLAYER_AMMO_MAX = 6;    // Gun max ammo
const MONSTER_HP = 5;         // Monster HP (raise for harder game)
const UNICORN_HP = 15;        // Unicorn HP (stronger than normal monsters)
const WALL_RATIO = 0.08;      // Wall generation ratio (0~1)
const GUN_DAMAGE_MIN = 2;     // Gun minimum damage
const GUN_DAMAGE_MAX = 3;     // Gun maximum damage (inclusive)
// ==========================================================

// ì¡°ì¤€ì„  ì´ëª¨í‹°ì½˜ ìƒìˆ˜
const AIM_EMOJIS = {
  // ìˆ˜í‰/ìˆ˜ì§ ë°©í–¥
  'right': 'â”€',
  'left': 'â”€', 
  'up': 'â”‚',
  'down': 'â”‚',
  
  // ëŒ€ê°ì„  ë°©í–¥
  'up-right': 'â•±',
  'down-right': 'â•²',
  'down-left': 'â•±',
  'up-left': 'â•²'
};

// ì¡°ì¤€ì„  ì‹œì‘/ë ì´ëª¨í‹°ì½˜
const AIM_START_EMOJI = 'ğŸ”«';  // ì‹œì‘ì  (ì´êµ¬)
const AIM_END_EMOJI = 'âŠ•';     // ëì  (ì‹­ìì„ )

// ì§€í˜• íƒ€ì… ìƒìˆ˜
const TERRAIN_TYPES = {
  FLOOR: 'FLOOR',
  WALL: 'WALL',
  GRASS: 'GRASS',
  TREE: 'TREE',
  ROCK: 'ROCK',
  HOUSE: 'HOUSE',
  CASTLE: 'CASTLE',
  CHURCH: 'CHURCH',
  DESERT: 'DESERT',
  WATER: 'WATER',
  MOUNTAIN: 'MOUNTAIN',
  LAVA: 'LAVA',
  // ìƒˆë¡œìš´ ë°”ì´ì˜´ íƒ€ì… ì¶”ê°€
  FOREST: 'FOREST',
  SWAMP: 'SWAMP',
  SNOW: 'SNOW',
  RUINS: 'RUINS',
  CAVE: 'CAVE',
  VILLAGE: 'VILLAGE',
  WASTELAND: 'WASTELAND',
  DUNGEON: 'DUNGEON'
};

// ëª¬ìŠ¤í„° íƒ€ì… ìƒìˆ˜
const MONSTER_TYPES = {
  ZOMBIE: 'ZOMBIE',
  ORC: 'ORC',
  VAMPIRE: 'VAMPIRE',
  FAIRY: 'FAIRY',
  GOBLIN: 'GOBLIN',
  DRAGON: 'DRAGON',
  UNICORN: 'UNICORN' // ìœ ë‹ˆì½˜ íƒ€ì… ì¶”ê°€
};

// Map symbols with emoji
const TILES = {
  // ì§€í˜• íƒ€ì¼ - ìƒ‰ìƒ ê¸°ë°˜ìœ¼ë¡œ ë³€ê²½
  FLOOR: { symbol: '.', emoji: 'â¬œ' },  // ê¸°ë³¸ ë°”ë‹¥ì€ í°ìƒ‰ ì‚¬ê°í˜•
  WALL: { symbol: '#', emoji: 'â¬›' },   // ë²½ì€ ê²€ì€ìƒ‰ ì‚¬ê°í˜•ìœ¼ë¡œ ë³€ê²½
  GRASS: { symbol: ',', emoji: 'â¬œ' },  // ì”ë””/ë“¤íŒë„ í°ìƒ‰ ì‚¬ê°í˜•ìœ¼ë¡œ ë³€ê²½
  TREE: { symbol: 'T', emoji: 'ğŸŒ²' },   // ë‚˜ë¬´
  ROCK: { symbol: '^', emoji: 'ğŸŸ«' },   // ë°”ìœ„ ì´ëª¨í‹°ì½˜ì„ ê°ˆìƒ‰ ì‚¬ê°í˜•ìœ¼ë¡œ ëŒ€ì²´
  HOUSE: { symbol: 'H', emoji: 'ğŸ ' },  // ì§‘
  CASTLE: { symbol: 'C', emoji: 'ğŸ°' },  // ì„±
  CHURCH: { symbol: 'R', emoji: 'â›ª' },  // êµíšŒ
  DESERT: { symbol: 'D', emoji: 'â¬œ' },  // ì‚¬ë§‰ë„ í°ìƒ‰ ì‚¬ê°í˜•ìœ¼ë¡œ ë³€ê²½
  WATER: { symbol: 'W', emoji: 'â¬œ' },   // ë¬¼ë„ í°ìƒ‰ ì‚¬ê°í˜•ìœ¼ë¡œ ë³€ê²½
  MOUNTAIN: { symbol: 'M', emoji: 'â¬œ' }, // ì‚°ë„ í°ìƒ‰ ì‚¬ê°í˜•ìœ¼ë¡œ ë³€ê²½
  LAVA: { symbol: 'L', emoji: 'â¬œ' },    // í™”ì‚°/ìš©ì•”ë„ í°ìƒ‰ ì‚¬ê°í˜•ìœ¼ë¡œ ë³€ê²½
  
  // ìƒˆë¡œìš´ ë°”ì´ì˜´ íƒ€ì¼
  FOREST: { symbol: 'F', emoji: 'ğŸŒ³' },  // ìˆ²
  SWAMP: { symbol: 'S', emoji: 'ğŸŒ¿' },   // ëŠªì§€ëŒ€
  SNOW: { symbol: 'N', emoji: 'â„ï¸' },    // ëˆˆ
  RUINS: { symbol: 'U', emoji: 'ğŸšï¸' },   // íí—ˆ
  CAVE: { symbol: 'V', emoji: 'ğŸ•³ï¸' },    // ë™êµ´
  VILLAGE: { symbol: 'I', emoji: 'ğŸ˜ï¸' }, // ë§ˆì„
  WASTELAND: { symbol: 'A', emoji: 'ğŸœï¸' }, // í™©ë¬´ì§€
  DUNGEON: { symbol: 'G', emoji: 'ğŸ§±' },  // ë˜ì „
  
  // í”Œë ˆì´ì–´
  PLAYER: { symbol: '@', emoji: 'ğŸ¤º' },  // íœì‹± ì„ ìˆ˜
  
  // ëª¬ìŠ¤í„° íƒ€ì…
  ZOMBIE: { symbol: 'Z', emoji: 'ğŸ§Ÿ' },   // ì¢€ë¹„
  ORC: { symbol: 'O', emoji: 'ğŸ‘¹' },      // ì˜¤í¬
  VAMPIRE: { symbol: 'V', emoji: 'ğŸ§›' },  // ë“œë¼í˜ë¼/ë±€íŒŒì´ì–´
  FAIRY: { symbol: 'F', emoji: 'ğŸ§š' },    // ìš”ì •
  GOBLIN: { symbol: 'G', emoji: 'ğŸ‘º' },   // ê³ ë¸”ë¦°
  DRAGON: { symbol: 'D', emoji: 'ğŸ‰' },   // ë“œë˜ê³¤
  UNICORN: { symbol: 'U', emoji: 'ğŸ¦„' },  // ìœ ë‹ˆì½˜
  
  // ê¸°íƒ€
  MONSTER_DEAD: { symbol: 'M', emoji: 'ğŸ’€' },  // ì£½ì€ ëª¬ìŠ¤í„°
  BULLET: { symbol: '*', emoji: 'ğŸ’¥' },        // ì´ì•Œ íš¨ê³¼
  HIDDEN: { symbol: ' ', emoji: 'â¬›' }          // ì‹œì•¼ ë°–ì€ ê²€ì€ìƒ‰ ì‚¬ê°í˜•
};

// For compatibility with existing code
const FLOOR = '.', WALL = '#', PLAYER = '@', MONSTER = 'M', BULLET = '*';

// Game state
let map = [];
let terrainMap = []; // ì§€í˜• ì •ë³´ë¥¼ ì €ì¥í•˜ëŠ” ë°°ì—´
let player = {
  x: Math.floor(MAP_W / 2),
  y: Math.floor(MAP_H / 2),
  hp: PLAYER_START_HP,
  ammo: PLAYER_AMMO_MAX,
  aiming: false,
  aimDir: { dx: 0, dy: 0 },
  aimTarget: null,      // ì¡°ì¤€ ì¤‘ì¸ íƒ€ê²Ÿ ìœ„ì¹˜ {x, y}
  aimPath: [],          // ì¡°ì¤€ ê²½ë¡œ [{x, y}, ...]
  currentWeapon: 'gun'  // í˜„ì¬ ë¬´ê¸° (gun, rocket, laser)
};
let monsters = [];
let msg = [];
let gameOver = false;
let highlightedCells = []; // í•˜ì´ë¼ì´íŠ¸ëœ ì…€ ì¶”ì 
let exploredMap = {}; // íƒì‚¬í•œ ì§€ì—­ì„ ê¸°ì–µí•˜ëŠ” ê°ì²´

// ì‹œì•¼ ê³µìœ  ì‹œìŠ¤í…œ ê´€ë ¨ ë³€ìˆ˜
let sightGroups = [];  // ì‹œì•¼ ê³µìœ  ê·¸ë£¹ ëª©ë¡
let realTimeTurnActive = false;  // ì‹¤ì‹œê°„ í„´ ì‹œìŠ¤í…œ í™œì„±í™” ìƒíƒœ
let currentTurnTime = 0;  // í˜„ì¬ í„´ì˜ ì‹œì‘ ì‹œê°„
let turnDuration = 500;   // í„´ ì§€ì† ì‹œê°„ (ë°€ë¦¬ì´ˆ)
let playerActedThisTurn = false;  // í˜„ì¬ í„´ì— í”Œë ˆì´ì–´ê°€ í–‰ë™í–ˆëŠ”ì§€ ì—¬ë¶€

// Directions for keypad (1-9, skip 5)
const DIRS = [
  { dx: -1, dy: 1 }, { dx: 0, dy: 1 }, { dx: 1, dy: 1 },
  { dx: -1, dy: 0 }, { dx: 0, dy: 0 }, { dx: 1, dy: 0 },
  { dx: -1, dy: -1 }, { dx: 0, dy: -1 }, { dx: 1, dy: -1 }
];
// Keypad keycode mapping (numpad and numbers)
const NUM_DIR_KEYS = {
  "97": 0, "98": 1, "99": 2, // Numpad 1,2,3
  "100": 3, "101": 4, "102": 5, // Numpad 4,5,6
  "103": 6, "104": 7, "105": 8, // Numpad 7,8,9
  "49": 0, "50": 1, "51": 2, // 1,2,3
  "52": 3, "53": 4, "54": 5, // 4,5,6
  "55": 6, "56": 7, "57": 8  // 7,8,9
};
function addMsg(s) { 
  msg.unshift(s); 
  if (msg.length > 5) msg.length = 5; 
}

// í†µí•© ë§µ ìƒì„± í•¨ìˆ˜
function generateIntegratedMap(mapType = 'mixed') {
  // ê¸°ë³¸ ë§µ ì´ˆê¸°í™”
  for (let y = 0; y < MAP_H; ++y) {
    map[y] = [];
    terrainMap[y] = [];
    for (let x = 0; x < MAP_W; ++x) {
      if (x === 0 || y === 0 || x === MAP_W - 1 || y === MAP_H - 1) {
        map[y][x] = WALL;
        terrainMap[y][x] = TERRAIN_TYPES.WALL;
      } else {
        // ê¸°ë³¸ì ìœ¼ë¡œ ì”ë”” ì§€í˜•ìœ¼ë¡œ ì„¤ì •
        map[y][x] = FLOOR;
        terrainMap[y][x] = TERRAIN_TYPES.GRASS;
      }
    }
  }
  
  // ë§µ íƒ€ì…ì— ë”°ë¼ ë‹¤ë¥¸ ìƒì„± ë°©ì‹ ì ìš©
  switch (mapType) {
    case 'wilderness': // ìì—° í™˜ê²½ ì¤‘ì‹¬
      generateTerrainWithNoise();
      generateBiomes();
      createForestClusters(5, 10, 15);
      createRockClusters(4, 8, 12);
      placeBuildingRandomly(TERRAIN_TYPES.HOUSE, 3);
      createVillages(1);
      createRandomDangerZones(1);
      break;
      
    case 'dungeon': // ë˜ì „ ì¤‘ì‹¬
      generateMaze(10, 10, 30, 30);
      generateMaze(60, 60, 30, 30);
      createTunnelSystem(8);
      createRuins(5);
      placeBuildingRandomly(TERRAIN_TYPES.CASTLE, 2);
      createRandomDangerZones(3);
      break;
      
    case 'village': // ë§ˆì„ ì¤‘ì‹¬
      generateTerrainWithNoise();
      createVillages(4);
      placeBuildingRandomly(TERRAIN_TYPES.HOUSE, 10);
      placeBuildingRandomly(TERRAIN_TYPES.CHURCH, 2);
      placeBuildingRandomly(TERRAIN_TYPES.CASTLE, 1);
      createForestClusters(2, 5, 8);
      break;
      
    case 'wasteland': // í™©ë¬´ì§€ ì¤‘ì‹¬
      for (let y = 1; y < MAP_H - 1; y++) {
        for (let x = 1; x < MAP_W - 1; x++) {
          terrainMap[y][x] = TERRAIN_TYPES.WASTELAND;
        }
      }
      createRuins(8);
      createRandomDangerZones(5);
      break;
      
    case 'mixed': // í˜¼í•©í˜• (ê¸°ë³¸ê°’)
    default:
      // í”„ë™íƒˆ ë…¸ì´ì¦ˆë¡œ ìì—°ìŠ¤ëŸ¬ìš´ ì§€í˜• ìƒì„±
      generateTerrainWithNoise();
      
      // ë°”ì´ì˜´ ìƒì„±
      generateBiomes();
      
      // ë¯¸ë¡œ ìƒì„± (ë§µì˜ íŠ¹ì • ì˜ì—­ì— ë¯¸ë¡œ ìƒì„±)
      generateMaze(10, 10, 20, 20); // ì¢Œìƒë‹¨ì— ë¯¸ë¡œ ìƒì„±
      generateMaze(70, 70, 20, 20); // ìš°í•˜ë‹¨ì— ë¯¸ë¡œ ìƒì„±
      
      // í†µë¡œ ì‹œìŠ¤í…œ ìƒì„±
      createTunnelSystem(5);
      
      // ìˆ² ì§€ì—­ ìƒì„± (ë‚˜ë¬´ í´ëŸ¬ìŠ¤í„°)
      createForestClusters(3, 8, 12);
      
      // ë°”ìœ„ ì§€ì—­ ìƒì„±
      createRockClusters(2, 6, 8);
      
      // ê±´ë¬¼ ë°°ì¹˜ (ì§‘, ì„±)
      placeBuildingRandomly(TERRAIN_TYPES.HOUSE, 5);
      placeBuildingRandomly(TERRAIN_TYPES.CASTLE, 1);
      placeBuildingRandomly(TERRAIN_TYPES.CHURCH, 3);
      
      // ë§ˆì„ ìƒì„±
      createVillages(2);
      
      // íí—ˆ ìƒì„±
      createRuins(3);
      
      // ìœ„í—˜ ì§€ì—­ ìƒì„±
      createRandomDangerZones(2);
      break;
  }
  
  // ë²½ ì¶”ê°€ (ë¯¸ë¡œ í˜•íƒœ) - ëª¨ë“  ë§µ íƒ€ì…ì— ì ìš©
  addMazeWalls(WALL_RATIO);
  
  // ìœ„í—˜ ì§€ì—­ ì´ˆê¸°í™”
  dangerZones = [];
}

// Map generation: fantasy world with various terrain types
function genMap() {
  // í†µí•© ë§µ ìƒì„± í•¨ìˆ˜ í˜¸ì¶œ
  generateIntegratedMap('mixed');
}

// ë°”ì´ì˜´ ìƒì„± í•¨ìˆ˜
function generateBiomes() {
  // ë°”ì´ì˜´ ì¤‘ì‹¬ì  ì„¤ì •
  const biomes = [
    { type: TERRAIN_TYPES.FOREST, x: Math.floor(Math.random() * MAP_W * 0.4) + MAP_W * 0.1, y: Math.floor(Math.random() * MAP_H * 0.4) + MAP_H * 0.1, radius: 20 },
    { type: TERRAIN_TYPES.DESERT, x: Math.floor(Math.random() * MAP_W * 0.4) + MAP_W * 0.5, y: Math.floor(Math.random() * MAP_H * 0.4) + MAP_H * 0.1, radius: 15 },
    { type: TERRAIN_TYPES.SWAMP, x: Math.floor(Math.random() * MAP_W * 0.4) + MAP_W * 0.1, y: Math.floor(Math.random() * MAP_H * 0.4) + MAP_H * 0.5, radius: 12 },
    { type: TERRAIN_TYPES.SNOW, x: Math.floor(Math.random() * MAP_W * 0.4) + MAP_W * 0.5, y: Math.floor(Math.random() * MAP_H * 0.4) + MAP_H * 0.5, radius: 18 }
  ];
  
  // ê° ë°”ì´ì˜´ ìƒì„±
  for (const biome of biomes) {
    createBiome(biome.type, biome.x, biome.y, biome.radius);
  }
}

// ê°œë³„ ë°”ì´ì˜´ ìƒì„± í•¨ìˆ˜
function createBiome(biomeType, centerX, centerY, radius) {
  for (let y = Math.max(1, centerY - radius); y < Math.min(MAP_H - 1, centerY + radius); y++) {
    for (let x = Math.max(1, centerX - radius); x < Math.min(MAP_W - 1, centerX + radius); x++) {
      // ì¤‘ì‹¬ì ìœ¼ë¡œë¶€í„°ì˜ ê±°ë¦¬ ê³„ì‚°
      const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
      
      // ê±°ë¦¬ì— ë”°ë¥¸ í™•ë¥ ë¡œ ë°”ì´ì˜´ íƒ€ì¼ ë°°ì¹˜
      if (distance <= radius) {
        const probability = 1 - (distance / radius);
        
        if (Math.random() < probability * 0.8) {
          terrainMap[y][x] = biomeType;
          
          // ë°”ì´ì˜´ë³„ íŠ¹ìˆ˜ ì§€í˜• ìƒì„±
          if (biomeType === TERRAIN_TYPES.FOREST) {
            // ìˆ² ë°”ì´ì˜´ì—ëŠ” ë‚˜ë¬´ë¥¼ ë” ë§ì´ ë°°ì¹˜
            if (Math.random() < 0.2) {
              map[y][x] = WALL;
              terrainMap[y][x] = TERRAIN_TYPES.TREE;
            }
          } else if (biomeType === TERRAIN_TYPES.DESERT) {
            // ì‚¬ë§‰ ë°”ì´ì˜´ì—ëŠ” ë°”ìœ„ë¥¼ ê°„í—ì ìœ¼ë¡œ ë°°ì¹˜
            if (Math.random() < 0.05) {
              map[y][x] = WALL;
              terrainMap[y][x] = TERRAIN_TYPES.ROCK;
            }
          } else if (biomeType === TERRAIN_TYPES.SWAMP) {
            // ëŠªì§€ëŒ€ ë°”ì´ì˜´ì—ëŠ” ë¬¼ì„ ê°„í—ì ìœ¼ë¡œ ë°°ì¹˜
            if (Math.random() < 0.15) {
              map[y][x] = WALL;
              terrainMap[y][x] = TERRAIN_TYPES.WATER;
            }
          } else if (biomeType === TERRAIN_TYPES.SNOW) {
            // ëˆˆ ë°”ì´ì˜´ì—ëŠ” ë‚˜ë¬´ë¥¼ ê°„í—ì ìœ¼ë¡œ ë°°ì¹˜
            if (Math.random() < 0.08) {
              map[y][x] = WALL;
              terrainMap[y][x] = TERRAIN_TYPES.TREE;
            }
          }
        }
      }
    }
  }
}

// ë§ˆì„ ìƒì„± í•¨ìˆ˜
function createVillages(count) {
  for (let i = 0; i < count; i++) {
    // ë§ˆì„ ì¤‘ì‹¬ì  ì„ íƒ
    const centerX = Math.floor(Math.random() * (MAP_W - 30)) + 15;
    const centerY = Math.floor(Math.random() * (MAP_H - 30)) + 15;
    const radius = Math.floor(Math.random() * 5) + 8;
    
    // ë§ˆì„ ì˜ì—­ ì„¤ì •
    for (let y = Math.max(1, centerY - radius); y < Math.min(MAP_H - 1, centerY + radius); y++) {
      for (let x = Math.max(1, centerX - radius); x < Math.min(MAP_W - 1, centerX + radius); x++) {
        // ì¤‘ì‹¬ì ìœ¼ë¡œë¶€í„°ì˜ ê±°ë¦¬ ê³„ì‚°
        const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
        
        // ë§ˆì„ ì˜ì—­ ë‚´ì— ìˆìœ¼ë©´ ë§ˆì„ ì§€í˜•ìœ¼ë¡œ ì„¤ì •
        if (distance <= radius) {
          terrainMap[y][x] = TERRAIN_TYPES.VILLAGE;
          
          // ë§ˆì„ ë‚´ì— ì§‘ê³¼ ê¸¸ ë°°ì¹˜
          if (Math.random() < 0.2) {
            map[y][x] = WALL;
            terrainMap[y][x] = TERRAIN_TYPES.HOUSE;
          }
        }
      }
    }
    
    // ë§ˆì„ ì¤‘ì•™ì— êµíšŒ ë°°ì¹˜
    terrainMap[centerY][centerX] = TERRAIN_TYPES.CHURCH;
    map[centerY][centerX] = WALL;
  }
}

// íí—ˆ ìƒì„± í•¨ìˆ˜
function createRuins(count) {
  for (let i = 0; i < count; i++) {
    // íí—ˆ ì¤‘ì‹¬ì  ì„ íƒ
    const centerX = Math.floor(Math.random() * (MAP_W - 20)) + 10;
    const centerY = Math.floor(Math.random() * (MAP_H - 20)) + 10;
    const radius = Math.floor(Math.random() * 4) + 5;
    
    // íí—ˆ ì˜ì—­ ì„¤ì •
    for (let y = Math.max(1, centerY - radius); y < Math.min(MAP_H - 1, centerY + radius); y++) {
      for (let x = Math.max(1, centerX - radius); x < Math.min(MAP_W - 1, centerX + radius); x++) {
        // ì¤‘ì‹¬ì ìœ¼ë¡œë¶€í„°ì˜ ê±°ë¦¬ ê³„ì‚°
        const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
        
        // íí—ˆ ì˜ì—­ ë‚´ì— ìˆìœ¼ë©´ íí—ˆ ì§€í˜•ìœ¼ë¡œ ì„¤ì •
        if (distance <= radius) {
          terrainMap[y][x] = TERRAIN_TYPES.RUINS;
          
          // íí—ˆ ë‚´ì— ë²½ ì”í•´ ë°°ì¹˜
          if (Math.random() < 0.3) {
            map[y][x] = WALL;
          }
        }
      }
    }
  }
}

// ìˆ² í´ëŸ¬ìŠ¤í„° ìƒì„± í•¨ìˆ˜
function createForestClusters(numClusters, minSize, maxSize) {
  for (let i = 0; i < numClusters; i++) {
    // í´ëŸ¬ìŠ¤í„° ì¤‘ì‹¬ì  ì„ íƒ
    const centerX = Math.floor(Math.random() * (MAP_W - 20)) + 10;
    const centerY = Math.floor(Math.random() * (MAP_H - 20)) + 10;
    
    // í´ëŸ¬ìŠ¤í„° í¬ê¸° ê²°ì •
    const clusterSize = Math.floor(Math.random() * (maxSize - minSize + 1)) + minSize;
    
    // ë‚˜ë¬´ ë°°ì¹˜
    for (let j = 0; j < clusterSize; j++) {
      const offsetX = Math.floor(Math.random() * 15) - 7;
      const offsetY = Math.floor(Math.random() * 15) - 7;
      const x = Math.min(Math.max(centerX + offsetX, 1), MAP_W - 2);
      const y = Math.min(Math.max(centerY + offsetY, 1), MAP_H - 2);
      
      // 20% í™•ë¥ ë¡œ ë‚˜ë¬´ë¥¼ ë°°ì¹˜, ë‚˜ë¨¸ì§€ëŠ” ì”ë””ë¡œ ìœ ì§€
      if (Math.random() < 0.2) {
        map[y][x] = WALL; // ë‚˜ë¬´ëŠ” ë²½ìœ¼ë¡œ ì·¨ê¸‰ (í†µê³¼ ë¶ˆê°€)
        terrainMap[y][x] = TERRAIN_TYPES.TREE;
      }
    }
  }
}

// ë°”ìœ„ í´ëŸ¬ìŠ¤í„° ìƒì„± í•¨ìˆ˜
function createRockClusters(numClusters, minSize, maxSize) {
  for (let i = 0; i < numClusters; i++) {
    // í´ëŸ¬ìŠ¤í„° ì¤‘ì‹¬ì  ì„ íƒ
    const centerX = Math.floor(Math.random() * (MAP_W - 20)) + 10;
    const centerY = Math.floor(Math.random() * (MAP_H - 20)) + 10;
    
    // í´ëŸ¬ìŠ¤í„° í¬ê¸° ê²°ì •
    const clusterSize = Math.floor(Math.random() * (maxSize - minSize + 1)) + minSize;
    
    // ë°”ìœ„ ë°°ì¹˜
    for (let j = 0; j < clusterSize; j++) {
      const offsetX = Math.floor(Math.random() * 10) - 5;
      const offsetY = Math.floor(Math.random() * 10) - 5;
      const x = Math.min(Math.max(centerX + offsetX, 1), MAP_W - 2);
      const y = Math.min(Math.max(centerY + offsetY, 1), MAP_H - 2);
      
      map[y][x] = WALL; // ë°”ìœ„ëŠ” ë²½ìœ¼ë¡œ ì·¨ê¸‰ (í†µê³¼ ë¶ˆê°€)
      terrainMap[y][x] = TERRAIN_TYPES.ROCK;
    }
  }
}

// ê±´ë¬¼ ëœë¤ ë°°ì¹˜ í•¨ìˆ˜
function placeBuildingRandomly(buildingType, count) {
  for (let i = 0; i < count; i++) {
    let x, y;
    let placed = false;
    let attempts = 0;
    
    // ì ì ˆí•œ ìœ„ì¹˜ ì°¾ê¸° (ìµœëŒ€ 100ë²ˆ ì‹œë„)
    while (!placed && attempts < 100) {
      x = Math.floor(Math.random() * (MAP_W - 10)) + 5;
      y = Math.floor(Math.random() * (MAP_H - 10)) + 5;
      
      // ì£¼ë³€ ê³µê°„ì´ ë¹„ì–´ìˆëŠ”ì§€ í™•ì¸
      let isEmpty = true;
      for (let dy = -2; dy <= 2; dy++) {
        for (let dx = -2; dx <= 2; dx++) {
          const nx = x + dx;
          const ny = y + dy;
          if (inMap(nx, ny) && terrainMap[ny][nx] !== TERRAIN_TYPES.GRASS) {
            isEmpty = false;
            break;
          }
        }
        if (!isEmpty) break;
      }
      
      if (isEmpty) {
        map[y][x] = WALL; // ê±´ë¬¼ì€ ë²½ìœ¼ë¡œ ì·¨ê¸‰ (í†µê³¼ ë¶ˆê°€)
        terrainMap[y][x] = buildingType;
        placed = true;
      }
      
      attempts++;
    }
  }
}

// ë¯¸ë¡œ í˜•íƒœì˜ ë²½ ì¶”ê°€
function addMazeWalls(ratio) {
  for (let y = 1; y < MAP_H - 1; y++) {
    for (let x = 1; x < MAP_W - 1; x++) {
      // ì´ë¯¸ íŠ¹ë³„í•œ ì§€í˜•ì´ ìˆëŠ” ê²½ìš° ê±´ë„ˆë›°ê¸°
      if (terrainMap[y][x] !== TERRAIN_TYPES.GRASS) continue;
      
      if (Math.random() < ratio) {
        map[y][x] = WALL;
        terrainMap[y][x] = TERRAIN_TYPES.WALL;
      }
    }
  }
}

// Place player and monsters
function placeEntities() {
  function randPos() {
    let x, y;
    do {
      x = Math.floor(Math.random() * (MAP_W - 2)) + 1;
      y = Math.floor(Math.random() * (MAP_H - 2)) + 1;
    } while (map[y][x] !== FLOOR ||
      (x === player.x && y === player.y) ||
      monsters.some(m => m.x === x && m.y === y));
    return { x, y };
  }
  // Place player
  let p = randPos();
  player.x = p.x; player.y = p.y;
  player.hp = PLAYER_START_HP;
  player.ammo = PLAYER_AMMO_MAX;
  player.aiming = false;
  player.reloading = false;
  
  // Place monsters
  monsters = [];
  for (let i = 0; i < MONSTER_COUNT; ++i) {
    let m = randPos();
    
    // ëª¬ìŠ¤í„° íƒ€ì… ê²°ì •
    const monsterRoll = Math.random();
    let monsterType, hp;
    
    if (monsterRoll < 0.3) { // 30% í™•ë¥ ë¡œ ì¢€ë¹„
      monsterType = MONSTER_TYPES.ZOMBIE;
      hp = MONSTER_HP;
    } else if (monsterRoll < 0.6) { // 30% í™•ë¥ ë¡œ ì˜¤í¬
      monsterType = MONSTER_TYPES.ORC;
      hp = MONSTER_HP + 1;
    } else if (monsterRoll < 0.8) { // 20% í™•ë¥ ë¡œ ê³ ë¸”ë¦°
      monsterType = MONSTER_TYPES.GOBLIN;
      hp = MONSTER_HP - 2;
    } else if (monsterRoll < 0.9) { // 10% í™•ë¥ ë¡œ ë±€íŒŒì´ì–´
      monsterType = MONSTER_TYPES.VAMPIRE;
      hp = MONSTER_HP + 3;
    } else if (monsterRoll < 0.98) { // 8% í™•ë¥ ë¡œ ìš”ì •
      monsterType = MONSTER_TYPES.FAIRY;
      hp = MONSTER_HP - 3;
    } else { // 2% í™•ë¥ ë¡œ ë“œë˜ê³¤
      monsterType = MONSTER_TYPES.DRAGON;
      hp = MONSTER_HP * 3;
    }
    
    monsters.push({ x: m.x, y: m.y, hp: hp, type: monsterType });
  }
  
  // ìœ ë‹ˆì½˜ ë°°ì¹˜ (íŠ¹ë³„í•œ ëª¬ìŠ¤í„°)
  for (let i = 0; i < UNICORN_COUNT; ++i) {
    let m = randPos();
    monsters.push({ 
      x: m.x, 
      y: m.y, 
      hp: UNICORN_HP, 
      type: MONSTER_TYPES.UNICORN,
      isUnicorn: true,  // ìœ ë‹ˆì½˜ ì‹ë³„ì
      nextMoveTime: 0,  // ë‹¤ìŒ í–‰ë™ ì‹œê°„ (ì‹¤ì‹œê°„ í„´ ì‹œìŠ¤í…œìš©)
      lastSeenPlayer: false, // í”Œë ˆì´ì–´ë¥¼ ë§ˆì§€ë§‰ìœ¼ë¡œ ë³¸ ìƒíƒœ
      targetMonster: null // ê³µê²© ëŒ€ìƒ ëª¬ìŠ¤í„°
    });
  }
}

// Check if in map
function inMap(x, y) { return x >= 0 && y >= 0 && x < MAP_W && y < MAP_H; }

// Bresenham line for FOV and shooting
function los(x0, y0, x1, y1, fn) {
  let dx = Math.abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
  let dy = -Math.abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
  let err = dx + dy, e2;
  for (; ;) {
    if (fn(x0, y0) === false) return false;
    if (x0 === x1 && y0 === y1) break;
    e2 = 2 * err;
    if (e2 >= dy) { err += dy; x0 += sx; }
    if (e2 <= dx) { err += dx; y0 += sy; }
  }
  return true;
}

// Field of view (returns set of visible positions)
function calcFOV() {
  let vis = {};
  for (let dy = -VIEW_R; dy <= VIEW_R; ++dy)
    for (let dx = -VIEW_R; dx <= VIEW_R; ++dx) {
      let tx = player.x + dx, ty = player.y + dy;
      if (inMap(tx, ty) && Math.sqrt(dx * dx + dy * dy) <= VIEW_R) {
        los(player.x, player.y, tx, ty, (x, y) => {
          vis[`${x},${y}`] = true;
          // íƒì‚¬í•œ ì§€ì—­ ê¸°ë¡
          exploredMap[`${x},${y}`] = map[y][x];
          return map[y][x] !== WALL;
        });
      }
    }
  return vis;
}

// ê²½ë¡œ ì‹œê°í™” í•¨ìˆ˜
function calculatePath(startX, startY, endX, endY) {
  let path = [];
  
  // Bresenham ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ê²½ë¡œ ê³„ì‚°
  let dx = Math.abs(endX - startX), sx = startX < endX ? 1 : -1;
  let dy = -Math.abs(endY - startY), sy = startY < endY ? 1 : -1;
  let err = dx + dy, e2;
  
  let x = startX, y = startY;
  
  while (true) {
    // ì‹œì‘ì ì€ ê²½ë¡œì— í¬í•¨í•˜ì§€ ì•ŠìŒ
    if (!(x === startX && y === startY)) {
      path.push({x, y});
    }
    
    if (x === endX && y === endY) break;
    
    e2 = 2 * err;
    if (e2 >= dy) { err += dy; x += sx; }
    if (e2 <= dx) { err += dx; y += sy; }
    
    // ë²½ì„ ë§Œë‚˜ë©´ ê²½ë¡œ ì¤‘ë‹¨
    if (inMap(x, y) && map[y][x] === WALL) break;
  }
  
  return path;
}

// ì¡°ì¤€ ê²½ë¡œ í‘œì‹œ í•¨ìˆ˜
function showAimPath(startX, startY, endX, endY) {
  // ì´ì „ í•˜ì´ë¼ì´íŠ¸ ì œê±°
  clearHighlights();
  
  // ê²½ë¡œ ê³„ì‚°
  const path = calculatePath(startX, startY, endX, endY);
  player.aimPath = path;
  
  // ë°©í–¥ ê²°ì •
  const dx = Math.sign(endX - startX);
  const dy = Math.sign(endY - startY);
  
  let direction;
  if (dx === 1 && dy === 0) direction = 'right';
  else if (dx === -1 && dy === 0) direction = 'left';
  else if (dx === 0 && dy === -1) direction = 'up';
  else if (dx === 0 && dy === 1) direction = 'down';
  else if (dx === 1 && dy === -1) direction = 'up-right';
  else if (dx === 1 && dy === 1) direction = 'down-right';
  else if (dx === -1 && dy === 1) direction = 'down-left';
  else if (dx === -1 && dy === -1) direction = 'up-left';
  else direction = 'right'; // ê¸°ë³¸ê°’
  
  const aimEmoji = AIM_EMOJIS[direction];
  
  // ê²½ë¡œ í‘œì‹œ
  path.forEach((pos, index) => {
    const cellIndex = (pos.y - Math.max(0, Math.min(MAP_H - SCREEN_H, player.y - Math.floor(SCREEN_H / 2)))) * SCREEN_W + 
                      (pos.x - Math.max(0, Math.min(MAP_W - SCREEN_W, player.x - Math.floor(SCREEN_W / 2))));
    const cells = document.getElementById('game-grid').children;
    
    if (cellIndex >= 0 && cellIndex < cells.length) {
      const cell = cells[cellIndex];
      
      // CSS í´ë˜ìŠ¤ ì¶”ê°€ë¡œ í•˜ì´ë¼ì´íŠ¸
      cell.classList.add('aim-path');
      
      // ì¡°ì¤€ì„  ì´ëª¨í‹°ì½˜ í‘œì‹œ
      const originalContent = cell.textContent;
      cell.textContent = aimEmoji;
      cell.style.color = '#ffcc00'; // ë…¸ë€ìƒ‰ìœ¼ë¡œ í‘œì‹œ
      
      // ì›ë˜ ë‚´ìš© ì €ì¥ (ë‚˜ì¤‘ì— ë³µì›í•˜ê¸° ìœ„í•´)
      cell.dataset.originalContent = originalContent;
      
      highlightedCells.push(cell);
    }
  });
  
  // ì‹œì‘ì ê³¼ ëì  íŠ¹ë³„ í‘œì‹œ
  if (path.length > 0) {
    // ì‹œì‘ì  í‘œì‹œ (ì²« ë²ˆì§¸ ê²½ë¡œ ì§€ì )
    const startPos = path[0];
    const startCellIndex = (startPos.y - Math.max(0, Math.min(MAP_H - SCREEN_H, player.y - Math.floor(SCREEN_H / 2)))) * SCREEN_W + 
                          (startPos.x - Math.max(0, Math.min(MAP_W - SCREEN_W, player.x - Math.floor(SCREEN_W / 2))));
    const cells = document.getElementById('game-grid').children;
    
    if (startCellIndex >= 0 && startCellIndex < cells.length) {
      const startCell = cells[startCellIndex];
      startCell.textContent = AIM_START_EMOJI;
      startCell.style.color = '#ff0000'; // ë¹¨ê°„ìƒ‰ìœ¼ë¡œ í‘œì‹œ
    }
    
    // ëì  í‘œì‹œ (ë§ˆì§€ë§‰ ê²½ë¡œ ì§€ì )
    const endPos = path[path.length - 1];
    const endCellIndex = (endPos.y - Math.max(0, Math.min(MAP_H - SCREEN_H, player.y - Math.floor(SCREEN_H / 2)))) * SCREEN_W + 
                        (endPos.x - Math.max(0, Math.min(MAP_W - SCREEN_W, player.x - Math.floor(SCREEN_W / 2))));
    
    if (endCellIndex >= 0 && endCellIndex < cells.length) {
      const endCell = cells[endCellIndex];
      endCell.textContent = AIM_END_EMOJI;
      endCell.style.color = '#00ff00'; // ë…¹ìƒ‰ìœ¼ë¡œ í‘œì‹œ
    }
  }
}

// í•˜ì´ë¼ì´íŠ¸ ì œê±° í•¨ìˆ˜
function clearHighlights() {
  highlightedCells.forEach(cell => {
    // CSS í´ë˜ìŠ¤ ì œê±°
    cell.classList.remove('aim-path');
    
    // ì›ë˜ ë‚´ìš© ë³µì›
    if (cell.dataset.originalContent) {
      cell.textContent = cell.dataset.originalContent;
      delete cell.dataset.originalContent;
    }
    
    // ìƒ‰ìƒ ì´ˆê¸°í™”
    cell.style.color = '';
  });
  
  highlightedCells = [];
  player.aimPath = [];
}

// ê°€ì¥ ê°€ê¹Œìš´ ëª¬ìŠ¤í„° ì°¾ê¸°
function findNearestVisibleMonster() {
  let vis = calcFOV();
  let nearestMonster = null;
  let minDistance = Infinity;
  
  monsters.forEach(m => {
    if (m.hp <= 0) return; // ì£½ì€ ëª¬ìŠ¤í„°ëŠ” ì œì™¸
    
    // ì‹œì•¼ ë‚´ì— ìˆëŠ”ì§€ í™•ì¸
    if (vis[`${m.x},${m.y}`]) {
      // ë§¨í•´íŠ¼ ê±°ë¦¬ ê³„ì‚°
      let distance = Math.abs(m.x - player.x) + Math.abs(m.y - player.y);
      
      // ë” ê°€ê¹Œìš´ ëª¬ìŠ¤í„° ë°œê²¬ ì‹œ ì—…ë°ì´íŠ¸
      if (distance < minDistance) {
        minDistance = distance;
        nearestMonster = m;
      }
    }
  });
  
  return nearestMonster;
}

// ìë™ ì¡°ì¤€ í•¨ìˆ˜
function autoAim() {
  const nearestMonster = findNearestVisibleMonster();
  
  if (nearestMonster) {
    // ëª¬ìŠ¤í„° ë°©í–¥ìœ¼ë¡œ ì¡°ì¤€ ì„¤ì •
    const dx = Math.sign(nearestMonster.x - player.x);
    const dy = Math.sign(nearestMonster.y - player.y);
    
    player.aimDir = { dx, dy };
    player.aimTarget = { x: nearestMonster.x, y: nearestMonster.y };
    
    // ê¶¤ì  í‘œì‹œ
    showAimPath(player.x, player.y, nearestMonster.x, nearestMonster.y);
    
    addMsg(`ì¡°ì¤€: ${nearestMonster.x},${nearestMonster.y}ì˜ ëª¬ìŠ¤í„°`);
    return true;
  }
  
  addMsg('ì‹œì•¼ ë‚´ì— ëª¬ìŠ¤í„°ê°€ ì—†ìŠµë‹ˆë‹¤.');
  return false; // ì‹œì•¼ ë‚´ì— ëª¬ìŠ¤í„°ê°€ ì—†ìŒ
}

// Render the game
function render() {
  // ë ˆì´ì € íš¨ê³¼ê°€ ì§„í–‰ ì¤‘ì´ë©´ ë Œë”ë§ ê±´ë„ˆë›°ê¸°
  if (window.laserEffectActive && Date.now() < window.laserEffectActive) {
    console.log("ë ˆì´ì € íš¨ê³¼ ì¤‘ - ë Œë”ë§ ê±´ë„ˆëœ€");
    return;
  }
  
  let vis = calcFOV();
  let gameGrid = document.getElementById('game-grid');
  let statusBar = document.getElementById('status-bar');
  let messageLog = document.getElementById('message-log');
  let turnTimer = document.getElementById('turn-timer');
  let turnTimerBar = document.getElementById('turn-timer-bar');
  
  // Clear previous content
  gameGrid.innerHTML = '';
  
  // Set grid template
  gameGrid.style.gridTemplateColumns = `repeat(${SCREEN_W}, 1fr)`;
  
  // Calculate view area
  let sx = Math.max(0, Math.min(MAP_W - SCREEN_W, player.x - Math.floor(SCREEN_W / 2)));
  let sy = Math.max(0, Math.min(MAP_H - SCREEN_H, player.y - Math.floor(SCREEN_H / 2)));
  
  // Create grid cells
  for (let y = sy; y < sy + SCREEN_H; ++y) {
    for (let x = sx; x < sx + SCREEN_W; ++x) {
      let cell = document.createElement('div');
      cell.className = 'cell';
      
      // íƒ€ì¼ ì¢Œí‘œ ì €ì¥ (í´ë¦­ ì´ë²¤íŠ¸ìš©)
      cell.dataset.x = x;
      cell.dataset.y = y;
      
      // Determine cell content
      let cellType = 'HIDDEN';
      let isExplored = exploredMap[`${x},${y}`] !== undefined;
      
      if (vis[`${x},${y}`]) {
        // í˜„ì¬ ì‹œì•¼ ë‚´ì— ìˆëŠ” ê²½ìš°
        if (player.x === x && player.y === y) {
          cellType = 'PLAYER';
        } else {
          let m = monsters.find(m => m.x === x && m.y === y);
          if (m) {
            if (m.hp <= 0) {
              cellType = 'MONSTER_DEAD';
            } else {
              cellType = m.type; // ëª¬ìŠ¤í„° íƒ€ì… ì‚¬ìš©
              // Add monster HP display
              cell.style.position = 'relative';
              let hpDisplay = document.createElement('div');
              hpDisplay.style.position = 'absolute';
              hpDisplay.style.bottom = '0';
              hpDisplay.style.right = '0';
              hpDisplay.style.fontSize = '8px';
              hpDisplay.style.backgroundColor = 'rgba(0,0,0,0.5)';
              hpDisplay.style.color = '#fff';
              hpDisplay.style.padding = '1px';
              hpDisplay.textContent = m.hp;
              cell.appendChild(hpDisplay);
            }
          } else {
            // ì§€í˜• íƒ€ì…ì— ë”°ë¼ íƒ€ì¼ ê²°ì •
            if (inMap(x, y) && terrainMap[y] && terrainMap[y][x]) {
              cellType = terrainMap[y][x];
            } else {
              cellType = map[y][x] === WALL ? 'WALL' : 'FLOOR';
            }
          }
        }
      } else if (isExplored) {
        // ì‹œì•¼ ë°–ì´ì§€ë§Œ ì´ì „ì— íƒì‚¬í•œ ì§€ì—­ì¸ ê²½ìš°
        // ì§€í˜• íƒ€ì…ì— ë”°ë¼ íƒ€ì¼ ê²°ì •
        if (inMap(x, y) && terrainMap[y] && terrainMap[y][x]) {
          cellType = terrainMap[y][x];
        } else {
          cellType = exploredMap[`${x},${y}`] === WALL ? 'WALL' : 'FLOOR';
        }
        
        // ì–´ë‘ìš´ ë°˜íˆ¬ëª… íš¨ê³¼ ì ìš©
        cell.style.filter = 'brightness(0.5)';
        cell.style.opacity = '0.7';
      } else {
        // ì‹œì•¼ ë°–ì´ê³  íƒì‚¬í•˜ì§€ ì•Šì€ ì§€ì—­ì€ ê²€ì€ìƒ‰ìœ¼ë¡œ í‘œì‹œ
        cell.classList.add('hidden-cell');
      }
      
      // Add appropriate CSS class
      if (cellType === 'WALL' || cellType === TERRAIN_TYPES.TREE || 
          cellType === TERRAIN_TYPES.ROCK || cellType === TERRAIN_TYPES.CASTLE || 
          cellType === TERRAIN_TYPES.HOUSE || cellType === TERRAIN_TYPES.CHURCH) {
        cell.classList.add('wall');
      } else if (cellType === 'FLOOR' || cellType === TERRAIN_TYPES.GRASS) {
        cell.classList.add('floor');
      } else if (cellType === TERRAIN_TYPES.DESERT) {
        cell.classList.add('desert');
      } else if (cellType === TERRAIN_TYPES.WATER) {
        cell.classList.add('water');
      } else if (cellType === TERRAIN_TYPES.MOUNTAIN) {
        cell.classList.add('mountain');
      } else if (cellType === TERRAIN_TYPES.LAVA) {
        cell.classList.add('lava');
      } else if (cellType === TERRAIN_TYPES.FOREST) {
        cell.classList.add('forest');
      } else if (cellType === TERRAIN_TYPES.SWAMP) {
        cell.classList.add('swamp');
      } else if (cellType === TERRAIN_TYPES.SNOW) {
        cell.classList.add('snow');
      } else if (cellType === TERRAIN_TYPES.RUINS) {
        cell.classList.add('ruins');
      } else if (cellType === TERRAIN_TYPES.CAVE) {
        cell.classList.add('cave');
      } else if (cellType === TERRAIN_TYPES.VILLAGE) {
        cell.classList.add('village');
      } else if (cellType === TERRAIN_TYPES.WASTELAND) {
        cell.classList.add('wasteland');
      } else if (cellType === TERRAIN_TYPES.DUNGEON) {
        cell.classList.add('dungeon');
      }
      
      // Set emoji content
      cell.textContent = TILES[cellType] ? TILES[cellType].emoji : TILES['FLOOR'].emoji;
      
      // ì¡°ì¤€ ëª¨ë“œì¼ ë•Œ í´ë¦­ ì´ë²¤íŠ¸ ì¶”ê°€
      if (player.aiming && vis[`${x},${y}`]) {
        cell.style.cursor = 'crosshair';
        
        // í´ë¦­ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
        cell.addEventListener('click', function() {
          const targetX = parseInt(this.dataset.x);
          const targetY = parseInt(this.dataset.y);
          
          // ë²½ì´ë‚˜ í”Œë ˆì´ì–´ ìœ„ì¹˜ëŠ” ì¡°ì¤€ ë¶ˆê°€
          if (map[targetY][targetX] === WALL || (targetX === player.x && targetY === player.y)) {
            addMsg('ìœ íš¨í•˜ì§€ ì•Šì€ ì¡°ì¤€ ìœ„ì¹˜ì…ë‹ˆë‹¤.');
            return;
          }
          
          // ì¡°ì¤€ ë°©í–¥ ì„¤ì •
          const dx = Math.sign(targetX - player.x);
          const dy = Math.sign(targetY - player.y);
          
          player.aimDir = { dx, dy };
          player.aimTarget = { x: targetX, y: targetY };
          
          // ê¶¤ì  í‘œì‹œ
          showAimPath(player.x, player.y, targetX, targetY);
          
          addMsg(`ì¡°ì¤€: ${targetX},${targetY} ìœ„ì¹˜`);
        });
      }
      
      // Add to grid
      gameGrid.appendChild(cell);
    }
  }
  
  // Update status bar
  let statusText = `HP: ${player.hp} | Ammo: ${player.ammo} | ë¬´ê¸°: ${getWeaponEmoji(player.currentWeapon)} ${getWeaponName(player.currentWeapon)} | ëª¬ìŠ¤í„°: ${monsters.filter(m => m.hp > 0).length}`;
  
  // ì‹¤ì‹œê°„ í„´ ì‹œìŠ¤í…œ ìƒíƒœ í‘œì‹œ
  if (realTimeTurnActive) {
    statusText += ' | ì‹¤ì‹œê°„ í„´ í™œì„±í™”!';
  }
  
  statusBar.innerHTML = statusText;
  
  // Update turn timer display
  if (realTimeTurnActive) {
    turnTimer.style.display = 'block';
    const now = Date.now();
    const elapsed = now - currentTurnTime;
    const remaining = Math.max(0, turnDuration - elapsed);
    const percent = (remaining / turnDuration) * 100;
    
    turnTimerBar.style.width = `${percent}%`;
    
    // ë‚¨ì€ ì‹œê°„ì— ë”°ë¼ ìƒ‰ìƒ ë³€ê²½
    if (percent > 60) {
      turnTimerBar.style.backgroundColor = '#0f0'; // ë…¹ìƒ‰
    } else if (percent > 30) {
      turnTimerBar.style.backgroundColor = '#ff0'; // ë…¸ë€ìƒ‰
    } else {
      turnTimerBar.style.backgroundColor = '#f00'; // ë¹¨ê°„ìƒ‰
    }
  } else {
    turnTimer.style.display = 'none';
  }
  
  // Update message log
  messageLog.innerHTML = '';
  if (player.aiming) {
    let aimingMsg = document.createElement('div');
    aimingMsg.textContent = 'ì¡°ì¤€ ì¤‘: ë°©í–¥í‚¤ë¡œ ë°©í–¥ ì„ íƒ ë˜ëŠ” íƒ€ì¼ í´ë¦­, ë‹¤ì‹œ ğŸ”« ë²„íŠ¼ì„ ëˆŒëŸ¬ ë°œì‚¬';
    aimingMsg.style.color = '#ffcc00';
    messageLog.appendChild(aimingMsg);
    
    // ë¬´ê¸°ë³„ íŒíŠ¸ í‘œì‹œ
    let weaponHint = document.createElement('div');
    switch(player.currentWeapon) {
      case 'gun':
        weaponHint.textContent = 'ê¶Œì´: ë‹¨ì¼ ëŒ€ìƒì—ê²Œ ì¤‘ê°„ ë°ë¯¸ì§€';
        break;
      case 'rocket':
        weaponHint.textContent = 'ë¡œì¼“: í­ë°œë¡œ ì£¼ë³€ ëª¬ìŠ¤í„°ì—ê²Œë„ ë°ë¯¸ì§€';
        break;
      case 'laser':
        weaponHint.textContent = 'ë ˆì´ì €: ì—¬ëŸ¬ ëª¬ìŠ¤í„°ë¥¼ ê´€í†µí•˜ëŠ” ë¹”';
        break;
    }
    weaponHint.style.color = '#aaffaa';
    messageLog.appendChild(weaponHint);
    
    // ë¬´ê¸° ì „í™˜ íŒíŠ¸
    let switchHint = document.createElement('div');
    switchHint.textContent = 'ë¬´ê¸° ì „í™˜: í‚¤ë³´ë“œ 1-3 ë˜ëŠ” ğŸ’ ë²„íŠ¼';
    switchHint.style.color = '#aaaaff';
    messageLog.appendChild(switchHint);
  } else {
    let controlMsg = document.createElement('div');
    controlMsg.textContent = 'ì´ë™: ë°©í–¥í‚¤ | ğŸ”«: ì¡°ì¤€/ë°œì‚¬ | ğŸ”„: ì¬ì¥ì „ | ğŸ’: ë¬´ê¸° ì „í™˜';
    messageLog.appendChild(controlMsg);
  }
  
  // Add game messages
  msg.forEach(m => {
    let msgElement = document.createElement('div');
    msgElement.textContent = m;
    messageLog.appendChild(msgElement);
  });
  
  // Game over message
  if (gameOver) {
    let gameOverMsg = document.createElement('div');
    gameOverMsg.textContent = 'ê²Œì„ ì˜¤ë²„! ìƒˆë¡œê³ ì¹¨í•˜ì—¬ ë‹¤ì‹œ ì‹œì‘';
    gameOverMsg.style.color = 'red';
    gameOverMsg.style.fontWeight = 'bold';
    messageLog.appendChild(gameOverMsg);
  }
  
  // ì¡°ì¤€ ê²½ë¡œ ë‹¤ì‹œ í‘œì‹œ (ë Œë”ë§ í›„)
  if (player.aiming && player.aimTarget) {
    showAimPath(player.x, player.y, player.aimTarget.x, player.aimTarget.y);
  }
}

// ë¬´ê¸° ì´ë¦„ ë°˜í™˜ í•¨ìˆ˜
function getWeaponName(weaponType) {
  switch(weaponType) {
    case 'gun': return 'ê¶Œì´';
    case 'rocket': return 'ë¡œì¼“';
    case 'laser': return 'ë ˆì´ì €';
    default: return 'ê¶Œì´';
  }
}

// ë¬´ê¸° ì´ëª¨ì§€ ë°˜í™˜ í•¨ìˆ˜
function getWeaponEmoji(weaponType) {
  switch(weaponType) {
    case 'gun': return 'ğŸ”«';
    case 'rocket': return 'ğŸš€';
    case 'laser': return 'âš¡';
    default: return 'ğŸ”«';
  }
}

// Move player
function tryMove(dx, dy) {
  let nx = player.x + dx, ny = player.y + dy;
  if (!inMap(nx, ny)) return false;
  if (map[ny][nx] === WALL) return false;
  let m = monsters.find(m => m.x === nx && m.y === ny && m.hp > 0);
  if (m) {
    m.hp -= 2 + Math.floor(Math.random() * 2); // melee attack
    addMsg('You punch the monster!');
    if (m.hp <= 0) addMsg('Monster dies!');
    
    // ì‹¤ì‹œê°„ í„´ ì‹œìŠ¤í…œì—ì„œ í”Œë ˆì´ì–´ í–‰ë™ ì²˜ë¦¬
    if (realTimeTurnActive) {
      playerActedThisTurn = true;
    }
  } else {
    player.x = nx; player.y = ny;
    
    // ì‹¤ì‹œê°„ í„´ ì‹œìŠ¤í…œì—ì„œ í”Œë ˆì´ì–´ í–‰ë™ ì²˜ë¦¬
    if (realTimeTurnActive) {
      playerActedThisTurn = true;
    }
  }
  
  // ì´ë™ í›„ ì‹œì•¼ ê³µìœ  ìƒíƒœ ì—…ë°ì´íŠ¸
  updateSightGroups();
  
  return true;
}

// Monster AI: very simple, move toward player if in FOV, else random walk
function monsterTurn() {
  let vis = calcFOV();
  monsters.forEach(m => {
    // ìœ ë‹ˆì½˜ì€ í”Œë ˆì´ì–´ ì‹œì•¼ì— ìˆì„ ë•Œë§Œ ì¼ë°˜ í„´ì—ì„œ ì œì™¸
    const isUnicornInRealTimeTurn = m.isUnicorn && vis[`${m.x},${m.y}`] && realTimeTurnActive;
    
    if (isUnicornInRealTimeTurn) return;
    
    if (m.hp <= 0) return;
    let dx = player.x - m.x, dy = player.y - m.y;
    let dist = Math.max(Math.abs(dx), Math.abs(dy));
    if (dist === 1) { // adjacent, attack
      // ìœ ë‹ˆì½˜ì€ í”Œë ˆì´ì–´ë¥¼ ê³µê²©í•˜ì§€ ì•ŠìŒ
      if (m.isUnicorn) return;
      
      player.hp -= 2;
      addMsg('Monster hits you!');
      if (player.hp <= 0) { gameOver = true; addMsg('You died!'); }
      return;
    }
    if (vis[`${m.x},${m.y}`]) {
      // Move closer
      let mx = dx ? dx / Math.abs(dx) : 0, my = dy ? dy / Math.abs(dy) : 0;
      let nx = m.x + mx, ny = m.y + my;
      
      // ìœ ë‹ˆì½˜ì€ í”Œë ˆì´ì–´ë¥¼ í–¥í•´ ì´ë™í•˜ì§€ ì•Šê³ , ë‹¤ë¥¸ ëª¬ìŠ¤í„°ë¥¼ í–¥í•´ ì´ë™
      if (m.isUnicorn) {
        // ìœ ë‹ˆì½˜ì˜ ì‹œì•¼ ë‚´ ê°€ì¥ ê°€ê¹Œìš´ ëª¬ìŠ¤í„° ì°¾ê¸°
        const unicornFOV = calcMonsterFOV(m);
        let nearestMonster = null;
        let minDistance = Infinity;
        
        monsters.forEach(target => {
          // ìê¸° ìì‹ ì´ê±°ë‚˜ ìœ ë‹ˆì½˜ì´ê±°ë‚˜ ì´ë¯¸ ì£½ì€ ëª¬ìŠ¤í„°ëŠ” ì œì™¸
          if (target === m || target.isUnicorn || target.hp <= 0) return;
          
          // ì‹œì•¼ ë‚´ì— ìˆëŠ”ì§€ í™•ì¸
          if (unicornFOV[`${target.x},${target.y}`]) {
            // ê±°ë¦¬ ê³„ì‚°
            const distance = Math.abs(target.x - m.x) + Math.abs(target.y - m.y);
            
            // ë” ê°€ê¹Œìš´ ëª¬ìŠ¤í„° ë°œê²¬ ì‹œ ì—…ë°ì´íŠ¸
            if (distance < minDistance) {
              minDistance = distance;
              nearestMonster = target;
            }
          }
        });
        
        // ê°€ê¹Œìš´ ëª¬ìŠ¤í„°ê°€ ìˆìœ¼ë©´ ê·¸ ë°©í–¥ìœ¼ë¡œ ì´ë™ ë˜ëŠ” ê³µê²©
        if (nearestMonster) {
          const mdx = Math.sign(nearestMonster.x - m.x);
          const mdy = Math.sign(nearestMonster.y - m.y);
          const mdist = Math.max(Math.abs(nearestMonster.x - m.x), Math.abs(nearestMonster.y - m.y));
          
          if (mdist <= 1) {
            // ëª¬ìŠ¤í„°ì™€ ì¸ì ‘í•´ ìˆìœ¼ë©´ ê³µê²©
            nearestMonster.hp -= 4; // ìœ ë‹ˆì½˜ì€ ê°•í•œ ê³µê²©ë ¥
            addMsg('ìœ ë‹ˆì½˜ì´ ëª¬ìŠ¤í„°ë¥¼ ê³µê²©í–ˆìŠµë‹ˆë‹¤!');
            
            if (nearestMonster.hp <= 0) {
              addMsg('ìœ ë‹ˆì½˜ì´ ëª¬ìŠ¤í„°ë¥¼ ì²˜ì¹˜í–ˆìŠµë‹ˆë‹¤!');
            }
          } else {
            // ëª¬ìŠ¤í„° ë°©í–¥ìœ¼ë¡œ ì´ë™ ì‹œë„
            const nx = m.x + mdx;
            const ny = m.y + mdy;
            
            if (inMap(nx, ny) && map[ny][nx] !== WALL && 
                !monsters.some(mm => mm !== m && mm.x === nx && mm.y === ny && mm.hp > 0)) {
              m.x = nx;
              m.y = ny;
            }
          }
        } else {
          // ëª¬ìŠ¤í„°ê°€ ì—†ìœ¼ë©´ ëœë¤ ì´ë™
          let d = DIRS[Math.floor(Math.random() * 8)];
          let nx = m.x + d.dx, ny = m.y + d.dy;
          if (inMap(nx, ny) && map[ny][nx] !== WALL && 
              !monsters.some(mm => mm !== m && mm.x === nx && mm.y === ny && mm.hp > 0) && 
              (player.x !== nx || player.y !== ny)) {
            m.x = nx;
            m.y = ny;
          }
        }
      } else {
        // ì¼ë°˜ ëª¬ìŠ¤í„°ëŠ” í”Œë ˆì´ì–´ë¥¼ í–¥í•´ ì´ë™
        if (inMap(nx, ny) && map[ny][nx] !== WALL && 
            !monsters.some(mm => mm !== m && mm.x === nx && mm.y === ny && mm.hp > 0) && 
            (player.x !== nx || player.y !== ny)) {
          m.x = nx;
          m.y = ny;
        }
      }
    } else {
      // Random move
      let d = DIRS[Math.floor(Math.random() * 8)];
      let nx = m.x + d.dx, ny = m.y + d.dy;
      if (inMap(nx, ny) && map[ny][nx] !== WALL && 
          !monsters.some(mm => mm !== m && mm.x === nx && mm.y === ny && mm.hp > 0) && 
          (player.x !== nx || player.y !== ny)) {
        m.x = nx;
        m.y = ny;
      }
    }
  });
  
  // ëª¬ìŠ¤í„° í„´ í›„ ì‹œì•¼ ê³µìœ  ìƒíƒœ ì—…ë°ì´íŠ¸
  updateSightGroups();
  
  // ìœ„í—˜ ì§€ì—­ ì—…ë°ì´íŠ¸
  updateDangerZones();
  
  // ëœë¤í•˜ê²Œ ìƒˆë¡œìš´ ìœ„í—˜ ì§€ì—­ ìƒì„± (0.5% í™•ë¥ )
  if (Math.random() < 0.005) {
    createRandomDangerZones(1);
    addMsg('ìƒˆë¡œìš´ ìœ„í—˜ ì§€ì—­ì´ ë°œìƒí–ˆìŠµë‹ˆë‹¤!');
  }
}

// Reload (now takes a real turn)
function doReload() {
  if (player.ammo === PLAYER_AMMO_MAX) { addMsg('ì´ë¯¸ ì¥ì „ë˜ì–´ ìˆìŠµë‹ˆë‹¤.'); render(); return; }
  player.ammo = PLAYER_AMMO_MAX;
  addMsg('ì¬ì¥ì „ ì™„ë£Œ!');
  monsterTurn(); // Monsters act immediately (reload is a turn)
  render();
}

// Keyboard input
document.addEventListener('keydown', function (e) {
  if (gameOver) return;
  
  // ì¡°ì¤€ ëª¨ë“œì¼ ë•Œ
  if (player.aiming) {
    // ESC: ì¡°ì¤€ ì·¨ì†Œ
    if (e.key === 'Escape') { 
      player.aiming = false; 
      player.aimTarget = null;
      clearHighlights();
      render(); 
      return; 
    }
    
    // ë°©í–¥í‚¤ë¡œ ì¡°ì¤€ ë°©í–¥ ì„¤ì •
    let d = NUM_DIR_KEYS[e.keyCode];
    if (d !== undefined && d !== 4) {
      player.aimDir = DIRS[d];
      
      // í•´ë‹¹ ë°©í–¥ìœ¼ë¡œ ì¡°ì¤€ ê²½ë¡œ í‘œì‹œ
      const targetX = player.x + player.aimDir.dx * 10; // ì¶©ë¶„íˆ ë¨¼ ê±°ë¦¬
      const targetY = player.y + player.aimDir.dy * 10;
      player.aimTarget = { x: targetX, y: targetY };
      
      showAimPath(player.x, player.y, targetX, targetY);
      render();
      return;
    }
    
    // F: ë°œì‚¬
    if (e.key === 'f' || e.key === 'F') {
      if (player.aimTarget) {
        // ì¡°ì¤€ëœ íƒ€ê²Ÿìœ¼ë¡œ ë°œì‚¬
        console.log("í‚¤ë³´ë“œ: ì¡°ì¤€ íƒ€ê²Ÿìœ¼ë¡œ ë°œì‚¬", player.aimTarget);
        
        fireWeapon(player.aimDir.dx, player.aimDir.dy);
        player.aiming = false;
        player.aimTarget = null;
        clearHighlights();
        monsterTurn();
        render();
      } else {
        addMsg('ë°©í–¥í‚¤ë¡œ ë°©í–¥ì„ ì„ íƒí•˜ê±°ë‚˜ íƒ€ì¼ì„ í´ë¦­í•˜ì„¸ìš”!');
      }
      return;
    }
    
    // ìˆ«ìí‚¤ 1-3: ë¬´ê¸° ì „í™˜
    if (e.key === '1' || e.key === '2' || e.key === '3') {
      const weaponIndex = parseInt(e.key) - 1;
      const weapons = ['gun', 'rocket', 'laser'];
      if (weaponIndex >= 0 && weaponIndex < weapons.length) {
        player.currentWeapon = weapons[weaponIndex];
        addMsg(`ë¬´ê¸° ì „í™˜: ${getWeaponName(player.currentWeapon)}`);
        updateWeaponButton();
        render();
      }
      return;
    }
    
    return;
  }
  
  // ì¡°ì¤€ ëª¨ë“œê°€ ì•„ë‹ ë•Œ
  
  // F: ì¡°ì¤€ ëª¨ë“œ ì‹œì‘
  if (e.key === 'f' || e.key === 'F') {
    player.aiming = true; 
    player.aimDir = { dx: 0, dy: 0 };
    
    // ìë™ ì¡°ì¤€ ì‹œë„
    autoAim();
    
    render(); 
    return;
  }
  
  // R: ì¬ì¥ì „
  if (e.key === 'r' || e.key === 'R') { 
    doReload(); 
    return; 
  }
  
  // ìˆ«ìí‚¤ 1-3: ë¬´ê¸° ì „í™˜
  if (e.key === '1' || e.key === '2' || e.key === '3') {
    const weaponIndex = parseInt(e.key) - 1;
    const weapons = ['gun', 'rocket', 'laser'];
    if (weaponIndex >= 0 && weaponIndex < weapons.length) {
      player.currentWeapon = weapons[weaponIndex];
      addMsg(`ë¬´ê¸° ì „í™˜: ${getWeaponName(player.currentWeapon)}`);
      updateWeaponButton();
      render();
    }
    return;
  }
  
  // ë°©í–¥í‚¤: ì´ë™
  let d = NUM_DIR_KEYS[e.keyCode];
  if (d !== undefined && d !== 4) {
    tryMove(DIRS[d].dx, DIRS[d].dy);
    monsterTurn();
    render();
    return;
  }
});
function init() {
  console.log("ê²Œì„ ì´ˆê¸°í™” í•¨ìˆ˜ ì‹œì‘");
  
  // ë§µ ì„ íƒ UI í‘œì‹œ
  showMapSelectionUI();
  
  console.log("ê²Œì„ ì´ˆê¸°í™” ì™„ë£Œ");
}

// ë§µ ì„ íƒ UI í‘œì‹œ í•¨ìˆ˜
function showMapSelectionUI() {
  const mapSelectContainer = document.getElementById('map-select-container');
  const mapOptions = document.querySelectorAll('.map-option');
  
  // ë§µ ì„ íƒ UI í‘œì‹œ
  mapSelectContainer.style.display = 'flex';
  
  // ë§µ ì˜µì…˜ í´ë¦­ ì´ë²¤íŠ¸ ì„¤ì •
  mapOptions.forEach(option => {
    option.addEventListener('click', function() {
      const mapType = this.getAttribute('data-map-type');
      
      // ì„ íƒí•œ ë§µ íƒ€ì…ìœ¼ë¡œ ê²Œì„ ì‹œì‘
      startGameWithMapType(mapType);
      
      // ë§µ ì„ íƒ UI ìˆ¨ê¹€
      mapSelectContainer.style.display = 'none';
    });
  });
}

// ì„ íƒí•œ ë§µ íƒ€ì…ìœ¼ë¡œ ê²Œì„ ì‹œì‘
function startGameWithMapType(mapType) {
  console.log(`ë§µ íƒ€ì… '${mapType}'ìœ¼ë¡œ ê²Œì„ ì‹œì‘`);
  
  // ë§µ ìƒì„±
  generateIntegratedMap(mapType);
  
  // ì—”í‹°í‹° ë°°ì¹˜
  placeEntities();
  
  // ë©”ì‹œì§€ ì´ˆê¸°í™”
  msg = ['Welcome to Doom Emoji RL!', `${getMapTypeName(mapType)} ë§µì—ì„œ ê²Œì„ì„ ì‹œì‘í•©ë‹ˆë‹¤!`];
  
  // ëª¨ë°”ì¼ ì»¨íŠ¸ë¡¤ ì´ë²¤íŠ¸ ì„¤ì •
  setupMobileControls();
  
  // ë¬´ê¸° ë²„íŠ¼ ì´ˆê¸°í™”
  updateWeaponButton();
  
  // ì‹œì•¼ ê³µìœ  ìƒíƒœ ì´ˆê¸°í™”
  updateSightGroups();
  
  // ê²Œì„ ë£¨í”„ ì‹œì‘
  startGameLoop();
  
  // ì´ˆê¸° ê²Œì„ ìƒíƒœ ë Œë”ë§
  render();
}

// ë§µ íƒ€ì… ì´ë¦„ ë°˜í™˜ í•¨ìˆ˜
function getMapTypeName(mapType) {
  switch (mapType) {
    case 'mixed': return 'í˜¼í•©í˜•';
    case 'wilderness': return 'ìì—° í™˜ê²½';
    case 'dungeon': return 'ë˜ì „';
    case 'village': return 'ë§ˆì„';
    case 'wasteland': return 'í™©ë¬´ì§€';
    default: return 'í˜¼í•©í˜•';
  }
}

// ëª¨ë°”ì¼ ì»¨íŠ¸ë¡¤ ì„¤ì •
function setupMobileControls() {
  // ëª¨ë°”ì¼ í„°ì¹˜ ì´ë²¤íŠ¸ ìµœì í™”
  document.addEventListener('touchstart', function(e) {
    if (e.target.tagName === 'BUTTON') {
      e.preventDefault(); // ê¸°ë³¸ í„°ì¹˜ ë™ì‘ ë°©ì§€
    }
  }, { passive: false });
  
  // ë”ë¸” íƒ­ ì¤Œ ë°©ì§€
  document.addEventListener('dblclick', function(e) {
    e.preventDefault();
  });

  // ë°©í–¥ ë²„íŠ¼ ì´ë²¤íŠ¸
  const dirButtons = document.querySelectorAll('.dir-btn');
  dirButtons.forEach(btn => {
    // í´ë¦­ ì´ë²¤íŠ¸ì™€ í„°ì¹˜ ì´ë²¤íŠ¸ ëª¨ë‘ ì²˜ë¦¬
    ['click', 'touchstart'].forEach(eventType => {
      btn.addEventListener(eventType, function(e) {
        if (eventType === 'touchstart') e.preventDefault();
        if (gameOver) return;
        
        const dirIndex = parseInt(this.getAttribute('data-dir'));
        if (player.aiming) {
          // ì¡°ì¤€ ì¤‘ì¼ ë•ŒëŠ” ì¡°ì¤€ ë°©í–¥ ì„¤ì •
          player.aimDir = DIRS[dirIndex];
          
          // í•´ë‹¹ ë°©í–¥ìœ¼ë¡œ ì¡°ì¤€ ê²½ë¡œ í‘œì‹œ
          const targetX = player.x + player.aimDir.dx * 10; // ì¶©ë¶„íˆ ë¨¼ ê±°ë¦¬
          const targetY = player.y + player.aimDir.dy * 10;
          player.aimTarget = { x: targetX, y: targetY };
          
          showAimPath(player.x, player.y, targetX, targetY);
          render();
        } else {
          // ì¼ë°˜ ì´ë™
          tryMove(DIRS[dirIndex].dx, DIRS[dirIndex].dy);
          monsterTurn();
          render();
        }
      });
    });
  });
  
  // ì¡°ì¤€/ë°œì‚¬ ë²„íŠ¼
  const aimBtn = document.getElementById('aim-btn');
  ['click', 'touchstart'].forEach(eventType => {
    aimBtn.addEventListener(eventType, function(e) {
      if (eventType === 'touchstart') e.preventDefault();
      if (gameOver) return;
      
      if (player.aiming) {
        // ì´ë¯¸ ì¡°ì¤€ ì¤‘ì´ë©´ ë°œì‚¬
        if (player.aimTarget) {
          // ì¡°ì¤€ëœ íƒ€ê²Ÿìœ¼ë¡œ ë°œì‚¬
          console.log("ì¡°ì¤€ íƒ€ê²Ÿìœ¼ë¡œ ë°œì‚¬:", player.aimTarget);
          
          // í˜„ì¬ ë¬´ê¸°ì— ë”°ë¼ ë‹¤ë¥¸ ë°œì‚¬ íš¨ê³¼ ì‚¬ìš©
          fireWeapon(player.aimDir.dx, player.aimDir.dy);
          player.aiming = false;
          player.aimTarget = null;
          clearHighlights();
          monsterTurn();
          render();
        } else {
          addMsg('ë°©í–¥í‚¤ë¡œ ë°©í–¥ì„ ì„ íƒí•˜ê±°ë‚˜ íƒ€ì¼ì„ í´ë¦­í•˜ì„¸ìš”!');
        }
      } else {
        // ì¡°ì¤€ ëª¨ë“œ ì‹œì‘ ë° ìë™ ì¡°ì¤€ ì‹œë„
        player.aiming = true;
        player.aimDir = { dx: 0, dy: 0 };
        
        // ìë™ ì¡°ì¤€ ì‹œë„
        autoAim();
        
        render();
      }
    });
  });
  
  // ì¬ì¥ì „ ë²„íŠ¼
  const reloadBtn = document.getElementById('reload-btn');
  ['click', 'touchstart'].forEach(eventType => {
    reloadBtn.addEventListener(eventType, function(e) {
      if (eventType === 'touchstart') e.preventDefault();
      if (gameOver) return;
      doReload();
    });
  });
  
  // ë‹¬ë¦¬ê¸° ë²„íŠ¼ (2ì¹¸ ì´ë™)
  const runBtn = document.getElementById('run-btn');
  ['click', 'touchstart'].forEach(eventType => {
    runBtn.addEventListener(eventType, function(e) {
      if (eventType === 'touchstart') e.preventDefault();
      if (gameOver || player.aiming) return;
      
      addMsg('Run mode: Choose direction');
      // ë‹¤ìŒ ë°©í–¥í‚¤ ì…ë ¥ì„ ê¸°ë‹¤ë ¸ë‹¤ê°€ 2ì¹¸ ì´ë™
      const runHandler = function(e) {
        if (e.target.classList.contains('dir-btn')) {
          const dirIndex = parseInt(e.target.getAttribute('data-dir'));
          const dir = DIRS[dirIndex];
          
          // ì²« ë²ˆì§¸ ì¹¸ ì´ë™
          if (tryMove(dir.dx, dir.dy)) {
            // ë‘ ë²ˆì§¸ ì¹¸ ì´ë™ ì‹œë„
            tryMove(dir.dx, dir.dy);
          }
          
          monsterTurn();
          render();
          
          // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì œê±°
          document.getElementById('mobile-controls').removeEventListener('click', runHandler);
          document.getElementById('mobile-controls').removeEventListener('touchstart', runHandler);
        }
      };
      
      document.getElementById('mobile-controls').addEventListener('click', runHandler);
      document.getElementById('mobile-controls').addEventListener('touchstart', runHandler);
    });
  });
  
  // ì¸ë²¤í† ë¦¬ ë²„íŠ¼ (ë¬´ê¸° ì „í™˜ìœ¼ë¡œ ë³€ê²½)
  const inventoryBtn = document.getElementById('weapon-btn');
  ['click', 'touchstart'].forEach(eventType => {
    inventoryBtn.addEventListener(eventType, function(e) {
      if (eventType === 'touchstart') e.preventDefault();
      if (gameOver) return;
      
      // ë¬´ê¸° ì „í™˜
      switchWeapon();
      render();
    });
  });
  
  // ëª¨ë“  í™˜ê²½ì—ì„œ ì»¨íŠ¸ë¡¤ íŒ¨ë„ í‘œì‹œ
  document.getElementById('mobile-controls').style.display = 'flex';
}

// ë¬´ê¸° ì „í™˜ ë²„íŠ¼ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
function updateWeaponButton() {
  const weaponBtn = document.getElementById('weapon-btn');
  if (weaponBtn) {
    // í˜„ì¬ ë¬´ê¸°ì— ë”°ë¼ ë‹¤ìŒ ë¬´ê¸° ì•„ì´ì½˜ í‘œì‹œ
    switch(player.currentWeapon) {
      case 'gun':
        weaponBtn.innerHTML = 'ğŸš€'; // ë‹¤ìŒ ë¬´ê¸°ëŠ” ë¡œì¼“
        break;
      case 'rocket':
        weaponBtn.innerHTML = 'âš¡'; // ë‹¤ìŒ ë¬´ê¸°ëŠ” ë ˆì´ì €
        break;
      case 'laser':
        weaponBtn.innerHTML = 'ğŸ”«'; // ë‹¤ìŒ ë¬´ê¸°ëŠ” ê¶Œì´
        break;
    }
  }
}

// ë¬´ê¸° ì „í™˜ í•¨ìˆ˜
function switchWeapon() {
  const weapons = ['gun', 'rocket', 'laser'];
  const currentIndex = weapons.indexOf(player.currentWeapon);
  const nextIndex = (currentIndex + 1) % weapons.length;
  player.currentWeapon = weapons[nextIndex];
  addMsg(`ë¬´ê¸° ì „í™˜: ${getWeaponName(player.currentWeapon)}`);
  
  // ë¬´ê¸° ì „í™˜ ë²„íŠ¼ ì—…ë°ì´íŠ¸
  updateWeaponButton();
}

// ë¬´ê¸°ë³„ ë°œì‚¬ í•¨ìˆ˜
function fireWeapon(dx, dy) {
  if (player.ammo <= 0) { 
    addMsg('íƒ„ì•½ì´ ì—†ìŠµë‹ˆë‹¤! Rí‚¤ë‚˜ ğŸ”„ ë²„íŠ¼ìœ¼ë¡œ ì¬ì¥ì „í•˜ì„¸ìš”.'); 
    return; 
  }
  
  // ì¡°ì¤€ íƒ€ê²Ÿì´ ìˆëŠ” ê²½ìš°, ì •í™•í•œ íƒ€ê²Ÿ ì¢Œí‘œë¥¼ ì‚¬ìš©
  if (player.aimTarget) {
    // íƒ€ê²Ÿê¹Œì§€ì˜ ê²½ë¡œ ê³„ì‚°
    const path = calculatePath(player.x, player.y, player.aimTarget.x, player.aimTarget.y);
    
    console.log("ë°œì‚¬ ê²½ë¡œ:", path);
    addMsg(`ë°œì‚¬: ${player.aimTarget.x},${player.aimTarget.y} ë°©í–¥`);
    
    switch(player.currentWeapon) {
      case 'gun':
        fireGunWithPath(path);
        break;
      case 'rocket':
        fireRocketWithPath(path);
        break;
      case 'laser':
        fireLaserWithPath(path);
        break;
      default:
        fireGunWithPath(path);
    }
  } else {
    // ê¸°ì¡´ ë°©ì‹ - ë°©í–¥ë§Œ ì‚¬ìš©
    switch(player.currentWeapon) {
      case 'gun':
        fireGun(dx, dy);
        break;
      case 'rocket':
        fireRocket(dx, dy);
        break;
      case 'laser':
        fireLaser(dx, dy);
        break;
      default:
        fireGun(dx, dy);
    }
  }
  
  player.ammo--;
}

// ì¼ë°˜ ì´ ë°œì‚¬ (ê¶¤ì  í‘œì‹œ)
function fireGun(dx, dy) {
  let x = player.x, y = player.y;
  let hit = false;
  
  // ê²½ë¡œ ê³„ì‚°
  const path = [];
  for (let i = 0; i < MAP_W; ++i) {
    x += dx; y += dy;
    if (!inMap(x, y) || map[y][x] === WALL) break;
    path.push({x, y});
    
    let m = monsters.find(m => m.x === x && m.y === y && m.hp > 0);
    if (m) {
      let dmg = GUN_DAMAGE_MIN + Math.floor(Math.random() * (GUN_DAMAGE_MAX - GUN_DAMAGE_MIN + 1));
      m.hp -= dmg;
      addMsg(`ëª¬ìŠ¤í„°ë¥¼ ì´ìœ¼ë¡œ ì©ë‹ˆë‹¤! (${dmg} ë°ë¯¸ì§€)`);
      if (m.hp <= 0) addMsg('ëª¬ìŠ¤í„°ê°€ ì“°ëŸ¬ì§‘ë‹ˆë‹¤!');
      hit = true;
      break;
    }
  }
  
  if (!hit) addMsg('ì´ì•Œì´ ì–´ë‘  ì†ìœ¼ë¡œ ì‚¬ë¼ì§‘ë‹ˆë‹¤.');
  
  // ì´ì•Œ ê¶¤ì  í‘œì‹œ
  showBulletTrail(path);
}

// ê²½ë¡œ ê¸°ë°˜ ê¶Œì´ ë°œì‚¬ í•¨ìˆ˜
function fireGunWithPath(path) {
  let hit = false;
  
  // ê²½ë¡œë¥¼ ë”°ë¼ ëª¬ìŠ¤í„° í™•ì¸
  for (let i = 0; i < path.length; i++) {
    const pos = path[i];
    
    // ë²½ì„ ë§Œë‚˜ë©´ ì¤‘ë‹¨
    if (map[pos.y][pos.x] === WALL) {
      // ë²½ì— ë¶€ë”ªíŒ ì§€ì ê¹Œì§€ì˜ ê²½ë¡œë§Œ ì‚¬ìš©
      path = path.slice(0, i);
      break;
    }
    
    // ëª¬ìŠ¤í„°ë¥¼ ë§Œë‚˜ë©´ ë°ë¯¸ì§€ ì ìš©
    let m = monsters.find(m => m.x === pos.x && m.y === pos.y && m.hp > 0);
    if (m) {
      let dmg = GUN_DAMAGE_MIN + Math.floor(Math.random() * (GUN_DAMAGE_MAX - GUN_DAMAGE_MIN + 1));
      m.hp -= dmg;
      addMsg(`ëª¬ìŠ¤í„°ë¥¼ ì´ìœ¼ë¡œ ì©ë‹ˆë‹¤! (${dmg} ë°ë¯¸ì§€)`);
      if (m.hp <= 0) addMsg('ëª¬ìŠ¤í„°ê°€ ì“°ëŸ¬ì§‘ë‹ˆë‹¤!');
      hit = true;
      
      // ëª¬ìŠ¤í„°ì— ë§ì€ ì§€ì ê¹Œì§€ì˜ ê²½ë¡œë§Œ ì‚¬ìš©
      path = path.slice(0, i + 1);
      break;
    }
  }
  
  if (!hit) addMsg('ì´ì•Œì´ ì–´ë‘  ì†ìœ¼ë¡œ ì‚¬ë¼ì§‘ë‹ˆë‹¤.');
  
  // ì´ì•Œ ê¶¤ì  í‘œì‹œ
  showBulletTrail(path);
}

// ë¡œì¼“ ë°œì‚¬ (ì• ë‹ˆë©”ì´ì…˜ íš¨ê³¼)
function fireRocket(dx, dy) {
  let x = player.x, y = player.y;
  let hit = false;
  
  // ê²½ë¡œ ê³„ì‚°
  const path = [];
  for (let i = 0; i < MAP_W; ++i) {
    x += dx; y += dy;
    if (!inMap(x, y) || map[y][x] === WALL) break;
    path.push({x, y});
    
    let m = monsters.find(m => m.x === x && m.y === y && m.hp > 0);
    if (m) {
      let dmg = 5 + Math.floor(Math.random() * 3); // ë¡œì¼“ì€ ë” ê°•ë ¥í•¨
      m.hp -= dmg;
      addMsg(`ë¡œì¼“ì´ ëª¬ìŠ¤í„°ì—ê²Œ ëª…ì¤‘! (${dmg} ë°ë¯¸ì§€)`);
      if (m.hp <= 0) addMsg('ëª¬ìŠ¤í„°ê°€ í­ë°œê³¼ í•¨ê»˜ ì“°ëŸ¬ì§‘ë‹ˆë‹¤!');
      hit = true;
      
      // ì£¼ë³€ ëª¬ìŠ¤í„°ì—ê²Œ í”¼í•´ (í­ë°œ íš¨ê³¼)
      monsters.forEach(nearby => {
        if (nearby !== m && nearby.hp > 0) {
          const distance = Math.abs(nearby.x - m.x) + Math.abs(nearby.y - m.y);
          if (distance <= 2) {
            nearby.hp -= Math.max(1, 3 - distance);
            if (nearby.hp <= 0) addMsg('ì£¼ë³€ ëª¬ìŠ¤í„°ë„ í­ë°œì— íœ˜ë§ë ¤ ì“°ëŸ¬ì§‘ë‹ˆë‹¤!');
          }
        }
      });
      
      break;
    }
  }
  
  if (!hit) addMsg('ë¡œì¼“ì´ ë‚ ì•„ê°€ í­ë°œí•©ë‹ˆë‹¤.');
  
  // ë¡œì¼“ ì• ë‹ˆë©”ì´ì…˜ í‘œì‹œ
  animateRocket(path);
}

// ê²½ë¡œ ê¸°ë°˜ ë¡œì¼“ ë°œì‚¬ í•¨ìˆ˜
function fireRocketWithPath(path) {
  let hit = false;
  let hitPos = null;
  
  // ê²½ë¡œë¥¼ ë”°ë¼ ëª¬ìŠ¤í„° í™•ì¸
  for (let i = 0; i < path.length; i++) {
    const pos = path[i];
    
    // ë²½ì„ ë§Œë‚˜ë©´ ì¤‘ë‹¨
    if (map[pos.y][pos.x] === WALL) {
      // ë²½ì— ë¶€ë”ªíŒ ì§€ì ê¹Œì§€ì˜ ê²½ë¡œë§Œ ì‚¬ìš©
      path = path.slice(0, i);
      break;
    }
    
    // ëª¬ìŠ¤í„°ë¥¼ ë§Œë‚˜ë©´ ë°ë¯¸ì§€ ì ìš©
    let m = monsters.find(m => m.x === pos.x && m.y === pos.y && m.hp > 0);
    if (m) {
      let dmg = 5 + Math.floor(Math.random() * 3); // ë¡œì¼“ì€ ë” ê°•ë ¥í•¨
      m.hp -= dmg;
      addMsg(`ë¡œì¼“ì´ ëª¬ìŠ¤í„°ì—ê²Œ ëª…ì¤‘! (${dmg} ë°ë¯¸ì§€)`);
      if (m.hp <= 0) addMsg('ëª¬ìŠ¤í„°ê°€ í­ë°œê³¼ í•¨ê»˜ ì“°ëŸ¬ì§‘ë‹ˆë‹¤!');
      hit = true;
      hitPos = pos;
      
      // ì£¼ë³€ ëª¬ìŠ¤í„°ì—ê²Œ í”¼í•´ (í­ë°œ íš¨ê³¼)
      monsters.forEach(nearby => {
        if (nearby !== m && nearby.hp > 0) {
          const distance = Math.abs(nearby.x - pos.x) + Math.abs(nearby.y - pos.y);
          if (distance <= 2) {
            nearby.hp -= Math.max(1, 3 - distance);
            if (nearby.hp <= 0) addMsg('ì£¼ë³€ ëª¬ìŠ¤í„°ë„ í­ë°œì— íœ˜ë§ë ¤ ì“°ëŸ¬ì§‘ë‹ˆë‹¤!');
          }
        }
      });
      
      // ëª¬ìŠ¤í„°ì— ë§ì€ ì§€ì ê¹Œì§€ì˜ ê²½ë¡œë§Œ ì‚¬ìš©
      path = path.slice(0, i + 1);
      break;
    }
  }
  
  if (!hit) {
    addMsg('ë¡œì¼“ì´ ë‚ ì•„ê°€ í­ë°œí•©ë‹ˆë‹¤.');
    // ê²½ë¡œ ëì—ì„œ í­ë°œ íš¨ê³¼ (ë§ˆì§€ë§‰ ìœ„ì¹˜ ì£¼ë³€ ëª¬ìŠ¤í„°ì—ê²Œ í”¼í•´)
    if (path.length > 0) {
      const lastPos = path[path.length - 1];
      monsters.forEach(nearby => {
        if (nearby.hp > 0) {
          const distance = Math.abs(nearby.x - lastPos.x) + Math.abs(nearby.y - lastPos.y);
          if (distance <= 1) { // í­ë°œ ë²”ìœ„ ì¶•ì†Œ
            nearby.hp -= 2;
            addMsg('í­ë°œì´ ëª¬ìŠ¤í„°ì—ê²Œ í”¼í•´ë¥¼ ì…í™ë‹ˆë‹¤!');
            if (nearby.hp <= 0) addMsg('ëª¬ìŠ¤í„°ê°€ ì“°ëŸ¬ì§‘ë‹ˆë‹¤!');
          }
        }
      });
    }
  }
  
  // ë¡œì¼“ ì• ë‹ˆë©”ì´ì…˜ í‘œì‹œ
  animateRocket(path);
}

// ë ˆì´ì € ë°œì‚¬ (ê´‘ì„  íš¨ê³¼)
function fireLaser(dx, dy) {
  let x = player.x, y = player.y;
  let hit = false;
  
  // ê²½ë¡œ ê³„ì‚°
  const path = [];
  for (let i = 0; i < MAP_W; ++i) {
    x += dx; y += dy;
    if (!inMap(x, y) || map[y][x] === WALL) break;
    path.push({x, y});
    
    let m = monsters.find(m => m.x === x && m.y === y && m.hp > 0);
    if (m) {
      let dmg = 3; // ë ˆì´ì €ëŠ” ê³ ì • ë°ë¯¸ì§€
      m.hp -= dmg;
      addMsg(`ë ˆì´ì €ê°€ ëª¬ìŠ¤í„°ë¥¼ ê´€í†µí•©ë‹ˆë‹¤! (${dmg} ë°ë¯¸ì§€)`);
      if (m.hp <= 0) addMsg('ëª¬ìŠ¤í„°ê°€ ì“°ëŸ¬ì§‘ë‹ˆë‹¤!');
      hit = true;
      // ë ˆì´ì €ëŠ” ê´€í†µí•¨ (break í•˜ì§€ ì•ŠìŒ)
    }
  }
  
  if (!hit) addMsg('ë ˆì´ì €ê°€ í—ˆê³µì„ ê°€ë¦½ë‹ˆë‹¤.');
  
  // ë ˆì´ì € ê´‘ì„  íš¨ê³¼ í‘œì‹œ
  showLaserBeam(path);
}

// ê²½ë¡œ ê¸°ë°˜ ë ˆì´ì € ë°œì‚¬ í•¨ìˆ˜
function fireLaserWithPath(path) {
  let hit = false;
  
  // ë²½ì„ ë§Œë‚˜ëŠ” ì§€ì  ì°¾ê¸°
  let wallIndex = -1;
  for (let i = 0; i < path.length; i++) {
    const pos = path[i];
    if (map[pos.y][pos.x] === WALL) {
      wallIndex = i;
      break;
    }
  }
  
  // ë²½ì´ ìˆìœ¼ë©´ í•´ë‹¹ ì§€ì ê¹Œì§€ë§Œ ê²½ë¡œ ì‚¬ìš©
  if (wallIndex !== -1) {
    path = path.slice(0, wallIndex);
  }
  
  // ê²½ë¡œë¥¼ ë”°ë¼ ëª¨ë“  ëª¬ìŠ¤í„°ì—ê²Œ ë°ë¯¸ì§€ ì ìš© (ê´€í†µ)
  path.forEach(pos => {
    let m = monsters.find(m => m.x === pos.x && m.y === pos.y && m.hp > 0);
    if (m) {
      let dmg = 3; // ë ˆì´ì €ëŠ” ê³ ì • ë°ë¯¸ì§€
      m.hp -= dmg;
      addMsg(`ë ˆì´ì €ê°€ ëª¬ìŠ¤í„°ë¥¼ ê´€í†µí•©ë‹ˆë‹¤! (${dmg} ë°ë¯¸ì§€)`);
      if (m.hp <= 0) addMsg('ëª¬ìŠ¤í„°ê°€ ì“°ëŸ¬ì§‘ë‹ˆë‹¤!');
      hit = true;
    }
  });
  
  if (!hit) addMsg('ë ˆì´ì €ê°€ í—ˆê³µì„ ê°€ë¦½ë‹ˆë‹¤.');
  
  // ë ˆì´ì € ê´‘ì„  íš¨ê³¼ í‘œì‹œ
  showLaserBeam(path);
}

// ì´ì•Œ ê¶¤ì  í‘œì‹œ í•¨ìˆ˜
function showBulletTrail(path) {
  // ê²½ë¡œì— ì  í‘œì‹œ
  path.forEach((pos, index) => {
    setTimeout(() => {
      const cellIndex = (pos.y - Math.max(0, Math.min(MAP_H - SCREEN_H, player.y - Math.floor(SCREEN_H / 2)))) * SCREEN_W + 
                        (pos.x - Math.max(0, Math.min(MAP_W - SCREEN_W, player.x - Math.floor(SCREEN_W / 2))));
      const cells = document.getElementById('game-grid').children;
      
      if (cellIndex >= 0 && cellIndex < cells.length) {
        const cell = cells[cellIndex];
        const originalContent = cell.innerHTML;
        
        // ì´ì•Œ íš¨ê³¼ í‘œì‹œ
        cell.innerHTML = 'Â·';
        cell.style.color = 'yellow';
        
        // ì ì‹œ í›„ ì›ë˜ëŒ€ë¡œ ë³µì›
        setTimeout(() => {
          cell.innerHTML = originalContent;
          cell.style.color = '';
        }, 100);
      }
    }, index * 30); // 30ms ê°„ê²©ìœ¼ë¡œ ìˆœì°¨ í‘œì‹œ
  });
}

// ë¡œì¼“ ì• ë‹ˆë©”ì´ì…˜ í•¨ìˆ˜
function animateRocket(path) {
  let currentIndex = 0;
  
  const interval = setInterval(() => {
    // ì´ì „ ë¡œì¼“ ì§€ìš°ê¸°
    if (currentIndex > 0) {
      const prevPos = path[currentIndex - 1];
      const prevCellIndex = (prevPos.y - Math.max(0, Math.min(MAP_H - SCREEN_H, player.y - Math.floor(SCREEN_H / 2)))) * SCREEN_W + 
                           (prevPos.x - Math.max(0, Math.min(MAP_W - SCREEN_W, player.x - Math.floor(SCREEN_W / 2))));
      const cells = document.getElementById('game-grid').children;
      
      if (prevCellIndex >= 0 && prevCellIndex < cells.length) {
        const cell = cells[prevCellIndex];
        // ì›ë˜ ë‚´ìš© ë³µì› (ê°„ë‹¨íˆ ì²˜ë¦¬)
        cell.innerHTML = TILES.FLOOR.emoji;
        cell.style.color = '';
      }
    }
    
    // í˜„ì¬ ìœ„ì¹˜ì— ë¡œì¼“ í‘œì‹œ
    if (currentIndex < path.length) {
      const pos = path[currentIndex];
      const cellIndex = (pos.y - Math.max(0, Math.min(MAP_H - SCREEN_H, player.y - Math.floor(SCREEN_H / 2)))) * SCREEN_W + 
                        (pos.x - Math.max(0, Math.min(MAP_W - SCREEN_W, player.x - Math.floor(SCREEN_W / 2))));
      const cells = document.getElementById('game-grid').children;
      
      if (cellIndex >= 0 && cellIndex < cells.length) {
        const cell = cells[cellIndex];
        
        // ë¡œì¼“ íš¨ê³¼ í‘œì‹œ
        cell.innerHTML = 'ğŸš€';
        cell.style.color = 'orange';
      }
      
      currentIndex++;
    } else {
      // ì• ë‹ˆë©”ì´ì…˜ ì¢…ë£Œ ë° í­ë°œ íš¨ê³¼
      clearInterval(interval);
      
      if (path.length > 0) {
        const lastPos = path[path.length - 1];
        const lastCellIndex = (lastPos.y - Math.max(0, Math.min(MAP_H - SCREEN_H, player.y - Math.floor(SCREEN_H / 2)))) * SCREEN_W + 
                             (lastPos.x - Math.max(0, Math.min(MAP_W - SCREEN_W, player.x - Math.floor(SCREEN_W / 2))));
        const cells = document.getElementById('game-grid').children;
        
        if (lastCellIndex >= 0 && lastCellIndex < cells.length) {
          const cell = cells[lastCellIndex];
          
          // í­ë°œ íš¨ê³¼
          cell.innerHTML = 'ğŸ’¥';
          
          // ì ì‹œ í›„ ì›ë˜ëŒ€ë¡œ ë³µì›
          setTimeout(() => {
            cell.innerHTML = TILES.FLOOR.emoji;
            cell.style.color = '';
          }, 300);
        }
      }
    }
  }, 100); // 100ms ê°„ê²©ìœ¼ë¡œ ì• ë‹ˆë©”ì´ì…˜
}

// ë ˆì´ì € ê´‘ì„  íš¨ê³¼ í•¨ìˆ˜
function showLaserBeam(path) {
  console.log("ë ˆì´ì € ê²½ë¡œ í‘œì‹œ ì‹œì‘", path);
  
  if (!path || path.length === 0) {
    console.log("ê²½ë¡œê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤!");
    return;
  }
  
  // ë Œë”ë§ ë°©ì§€ í”Œë˜ê·¸ ì„¤ì • (ì´ ì‹œê°„ ë™ì•ˆ ì¶”ê°€ ë Œë”ë§ ë°©ì§€)
  const preventRenderUntil = Date.now() + 1000;
  window.laserEffectActive = preventRenderUntil;
  
  // ê° ì…€ì˜ ì›ë˜ ë‚´ìš© ì €ì¥
  const originalContents = [];
  const cellsToUpdate = [];
  
  // ëª¨ë“  ì…€ ì •ë³´ ìˆ˜ì§‘
  path.forEach((pos, index) => {
    const cellIndex = (pos.y - Math.max(0, Math.min(MAP_H - SCREEN_H, player.y - Math.floor(SCREEN_H / 2)))) * SCREEN_W + 
                      (pos.x - Math.max(0, Math.min(MAP_W - SCREEN_W, player.x - Math.floor(SCREEN_W / 2))));
    const cells = document.getElementById('game-grid').children;
    
    if (cellIndex >= 0 && cellIndex < cells.length) {
      const cell = cells[cellIndex];
      originalContents.push({
        cell: cell,
        content: cell.innerHTML,
        backgroundColor: cell.style.backgroundColor,
        color: cell.style.color
      });
      cellsToUpdate.push(cell);
    }
  });
  
  console.log(`ë ˆì´ì € ê²½ë¡œì— ìˆëŠ” ì…€ ìˆ˜: ${cellsToUpdate.length}`);
  
  // 1ë‹¨ê³„: ê°•ë ¬í•œ ë…¸ë€ìƒ‰ ë ˆì´ì € ë¹” (0ms)
  cellsToUpdate.forEach(cell => {
    cell.innerHTML = 'âš¡'; // ë ˆì´ì € ì´ëª¨í‹°ì½˜
    cell.style.setProperty('color', '#FFFF00', 'important'); // ë…¸ë€ìƒ‰
    cell.style.setProperty('background-color', '#880000', 'important'); // ì–´ë‘ìš´ ë¹¨ê°„ìƒ‰ ë°°ê²½
  });
  
  // 2ë‹¨ê³„: ì¤‘ê°„ ê°•ë„ (300ms)
  setTimeout(() => {
    cellsToUpdate.forEach(cell => {
      cell.innerHTML = 'âœ¨'; // ë‹¤ë¥¸ ì´ëª¨í‹°ì½˜
      cell.style.setProperty('color', '#FFDD00', 'important');
      cell.style.setProperty('background-color', '#660000', 'important');
    });
  }, 300);
  
  // 3ë‹¨ê³„: ì˜…ì€ íš¨ê³¼ (600ms)
  setTimeout(() => {
    cellsToUpdate.forEach(cell => {
      cell.innerHTML = 'Â·'; // ë” ì‘ì€ ì´ëª¨í‹°ì½˜
      cell.style.setProperty('color', '#FFEE88', 'important');
      cell.style.setProperty('background-color', '#440000', 'important');
    });
  }, 600);
  
  // ì›ë˜ ìƒíƒœë¡œ ë³µì› (900ms)
  setTimeout(() => {
    originalContents.forEach(item => {
      const cell = item.cell;
      if (cell) {
        cell.innerHTML = item.content;
        cell.style.removeProperty('color');
        cell.style.removeProperty('background-color');
        
        // ì›ë˜ ìŠ¤íƒ€ì¼ì´ ìˆì—ˆë‹¤ë©´ ë³µì›
        if (item.backgroundColor) cell.style.backgroundColor = item.backgroundColor;
        if (item.color) cell.style.color = item.color;
      }
    });
    
    // ë Œë”ë§ ë°©ì§€ í”Œë˜ê·¸ í•´ì œ
    window.laserEffectActive = false;
    console.log("ë ˆì´ì € ê²½ë¡œ í‘œì‹œ ì¢…ë£Œ");
    
    // ê°•ì œ ë Œë”ë§ìœ¼ë¡œ í™”ë©´ ì—…ë°ì´íŠ¸
    setTimeout(render, 50);
  }, 900);
}

// ê²Œì„ ì´ˆê¸°í™” í˜¸ì¶œ
window.onload = function() {
  console.log("ê²Œì„ ì´ˆê¸°í™” ì‹œì‘");
  init();
  console.log("ê²Œì„ ì´ˆê¸°í™” ì™„ë£Œ");
};

// ëª¬ìŠ¤í„°ì˜ ì‹œì•¼ ê³„ì‚° í•¨ìˆ˜
function calcMonsterFOV(monster) {
  let vis = {};
  for (let dy = -VIEW_R; dy <= VIEW_R; ++dy)
    for (let dx = -VIEW_R; dx <= VIEW_R; ++dx) {
      let tx = monster.x + dx, ty = monster.y + dy;
      if (inMap(tx, ty) && Math.sqrt(dx * dx + dy * dy) <= VIEW_R) {
        los(monster.x, monster.y, tx, ty, (x, y) => {
          vis[`${x},${y}`] = true;
          return map[y][x] !== WALL;
        });
      }
    }
  return vis;
}

// ì‹œì•¼ ê³µìœ  ê·¸ë£¹ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
function updateSightGroups() {
  // ê¸°ì¡´ ê·¸ë£¹ ì´ˆê¸°í™”
  sightGroups = [];
  
  // ëª¨ë“  ìœ ë‹ˆì½˜ê³¼ í”Œë ˆì´ì–´ì˜ ì‹œì•¼ ê³„ì‚°
  const playerFOV = calcFOV();
  const unicorns = monsters.filter(m => m.isUnicorn && m.hp > 0);
  
  // ê° ìœ ë‹ˆì½˜ì˜ ì‹œì•¼ ê³„ì‚°
  const unicornFOVs = unicorns.map(unicorn => ({
    unicorn: unicorn,
    fov: calcMonsterFOV(unicorn)
  }));
  
  // ì‹œì•¼ ê³µìœ  ê´€ê³„ í™•ì¸
  const entities = [{ type: 'player', fov: playerFOV }, ...unicornFOVs];
  const connections = [];
  
  // í”Œë ˆì´ì–´ì˜ ì‹œì•¼ì— ìœ ë‹ˆì½˜ì´ ìˆëŠ”ì§€ ì§ì ‘ í™•ì¸
  let playerCanSeeUnicorn = false;
  if (unicorns.length > 0) {
    playerCanSeeUnicorn = unicorns.some(unicorn => playerFOV[`${unicorn.x},${unicorn.y}`]);
  }
  
  // ëª¨ë“  ì—”í‹°í‹° ìŒì— ëŒ€í•´ ì‹œì•¼ ê³µìœ  í™•ì¸
  for (let i = 0; i < entities.length; i++) {
    for (let j = i + 1; j < entities.length; j++) {
      const entity1 = entities[i];
      const entity2 = entities[j];
      
      // ì‹œì•¼ ê³µìœ  ì—¬ë¶€ í™•ì¸
      let sharesSight = false;
      
      // ì—”í‹°í‹°1ì´ ì—”í‹°í‹°2ë¥¼ ë³¼ ìˆ˜ ìˆëŠ”ì§€ í™•ì¸
      if (entity1.type === 'player') {
        const unicorn = entity2.unicorn;
        if (entity1.fov[`${unicorn.x},${unicorn.y}`]) {
          sharesSight = true;
        }
      } else if (entity2.type === 'player') {
        const unicorn = entity1.unicorn;
        if (entity2.fov[`${unicorn.x},${unicorn.y}`]) {
          sharesSight = true;
        }
      } else {
        // ìœ ë‹ˆì½˜ë¼ë¦¬ì˜ ì‹œì•¼ ê³µìœ  í™•ì¸
        const unicorn1 = entity1.unicorn;
        const unicorn2 = entity2.unicorn;
        if (entity1.fov[`${unicorn2.x},${unicorn2.y}`]) {
          sharesSight = true;
        }
      }
      
      if (sharesSight) {
        connections.push([i, j]);
      }
    }
  }
  
  // ì—°ê²° ê´€ê³„ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ê·¸ë£¹ í˜•ì„±
  const visited = new Array(entities.length).fill(false);
  
  for (let i = 0; i < entities.length; i++) {
    if (visited[i]) continue;
    
    // BFSë¡œ ì—°ê²°ëœ ëª¨ë“  ì—”í‹°í‹° ì°¾ê¸°
    const group = [];
    const queue = [i];
    visited[i] = true;
    
    while (queue.length > 0) {
      const current = queue.shift();
      group.push(current);
      
      // í˜„ì¬ ì—”í‹°í‹°ì™€ ì—°ê²°ëœ ëª¨ë“  ì—”í‹°í‹° ì°¾ê¸°
      for (const [a, b] of connections) {
        let next = -1;
        if (a === current && !visited[b]) next = b;
        if (b === current && !visited[a]) next = a;
        
        if (next !== -1) {
          visited[next] = true;
          queue.push(next);
        }
      }
    }
    
    // ê·¸ë£¹ì— í”Œë ˆì´ì–´ê°€ í¬í•¨ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸
    const hasPlayer = group.some(idx => entities[idx].type === 'player');
    
    // ê·¸ë£¹ì— í¬í•¨ëœ ìœ ë‹ˆì½˜ë“¤ ìˆ˜ì§‘
    const groupUnicorns = group
      .filter(idx => entities[idx].type !== 'player')
      .map(idx => entities[idx].unicorn);
    
    // ìœ íš¨í•œ ê·¸ë£¹ë§Œ ì¶”ê°€ (í”Œë ˆì´ì–´ê°€ ìˆê±°ë‚˜ ìœ ë‹ˆì½˜ì´ 2ë§ˆë¦¬ ì´ìƒ)
    if (hasPlayer || groupUnicorns.length > 1) {
      sightGroups.push({
        hasPlayer: hasPlayer,
        unicorns: groupUnicorns
      });
    }
  }
  
  // ì‹¤ì‹œê°„ í„´ ì‹œìŠ¤í…œ í™œì„±í™” ì—¬ë¶€ ê²°ì •
  const playerGroup = sightGroups.find(group => group.hasPlayer);
  const unicornGroup = sightGroups.find(group => !group.hasPlayer && group.unicorns.length > 1);
  const wasActive = realTimeTurnActive;
  
  // í”Œë ˆì´ì–´ê°€ ì§ì ‘ ìœ ë‹ˆì½˜ì„ ë³¼ ìˆ˜ ìˆì„ ë•Œë§Œ ì‹¤ì‹œê°„ í„´ ì‹œìŠ¤í…œ í™œì„±í™”
  realTimeTurnActive = playerCanSeeUnicorn;
  
  // ì‹¤ì‹œê°„ í„´ ì‹œìŠ¤í…œ ìƒíƒœ ë³€ê²½ ì‹œ ì²˜ë¦¬
  if (!wasActive && realTimeTurnActive) {
    // ì‹¤ì‹œê°„ í„´ ì‹œìŠ¤í…œ í™œì„±í™”
    startRealTimeTurn();
    
    if (playerCanSeeUnicorn) {
      addMsg('ìœ ë‹ˆì½˜ê³¼ ì‹œì•¼ê°€ ê²¹ì³¤ìŠµë‹ˆë‹¤! ì‹¤ì‹œê°„ í„´ ì‹œìŠ¤í…œì´ í™œì„±í™”ë©ë‹ˆë‹¤.');
      
      // í”Œë ˆì´ì–´ ì‹œì•¼ì— ìˆëŠ” ìœ ë‹ˆì½˜ë“¤ì—ê²Œ í”Œë ˆì´ì–´ ê°ì§€ ìƒíƒœ ì„¤ì •
      unicorns.forEach(unicorn => {
        if (playerFOV[`${unicorn.x},${unicorn.y}`]) {
          unicorn.lastSeenPlayer = true;
        }
      });
    }
  } else if (wasActive && !realTimeTurnActive) {
    // ì‹¤ì‹œê°„ í„´ ì‹œìŠ¤í…œ ë¹„í™œì„±í™”
    addMsg('ì‹¤ì‹œê°„ í„´ ì‹œìŠ¤í…œì´ ë¹„í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤. ì¼ë°˜ í„´ ì‹œìŠ¤í…œìœ¼ë¡œ ëŒì•„ê°‘ë‹ˆë‹¤.');
  }
}

// ì‹¤ì‹œê°„ í„´ ì‹œì‘ í•¨ìˆ˜
function startRealTimeTurn() {
  currentTurnTime = Date.now();
  playerActedThisTurn = false;
  
  // í”Œë ˆì´ì–´ê°€ ì†í•œ ê·¸ë£¹ì˜ ìœ ë‹ˆì½˜ë“¤ì—ê²Œ ëœë¤ í–‰ë™ ì‹œê°„ ì„¤ì •
  const playerGroup = sightGroups.find(group => group.hasPlayer);
  if (playerGroup) {
    playerGroup.unicorns.forEach(unicorn => {
      // 0~500ms ì‚¬ì´ì˜ ëœë¤í•œ ì‹œê°„ì— í–‰ë™
      unicorn.nextMoveTime = currentTurnTime + Math.floor(Math.random() * turnDuration);
    });
  }
  
  // ìœ ë‹ˆì½˜ë¼ë¦¬ ì‹œì•¼ê°€ ê²¹ì¹˜ëŠ” ê·¸ë£¹ì˜ ìœ ë‹ˆì½˜ë“¤ì—ê²Œ ëœë¤ í–‰ë™ ì‹œê°„ ì„¤ì •
  const unicornGroups = sightGroups.filter(group => !group.hasPlayer && group.unicorns.length > 1);
  unicornGroups.forEach(group => {
    group.unicorns.forEach(unicorn => {
      // 0~500ms ì‚¬ì´ì˜ ëœë¤í•œ ì‹œê°„ì— í–‰ë™
      unicorn.nextMoveTime = currentTurnTime + Math.floor(Math.random() * turnDuration);
    });
  });
}

// ì‹¤ì‹œê°„ í„´ ì²˜ë¦¬ í•¨ìˆ˜ (ê²Œì„ ë£¨í”„ì—ì„œ í˜¸ì¶œ)
function processRealTimeTurn() {
  if (!realTimeTurnActive) return;
  
  const now = Date.now();
  const elapsed = now - currentTurnTime;
  
  // í„´ ì‹œê°„ì´ ì§€ë‚¬ëŠ”ì§€ í™•ì¸
  if (elapsed >= turnDuration) {
    // í„´ ì¢…ë£Œ, ìƒˆ í„´ ì‹œì‘
    endRealTimeTurn();
    startRealTimeTurn();
    return;
  }
  
  // ëª¨ë“  ì‹¤ì‹œê°„ í„´ ê·¸ë£¹ ì²˜ë¦¬
  sightGroups.forEach(group => {
    // ê·¸ë£¹ì— ì†í•œ ìœ ë‹ˆì½˜ë“¤ì˜ í–‰ë™ ì²˜ë¦¬
    group.unicorns.forEach(unicorn => {
      // ì´ í„´ì— í–‰ë™í•  ì‹œê°„ì´ ë˜ì—ˆê³ , ì•„ì§ í–‰ë™í•˜ì§€ ì•Šì•˜ë‹¤ë©´
      if (now >= unicorn.nextMoveTime && unicorn.nextMoveTime >= currentTurnTime) {
        // ìœ ë‹ˆì½˜ í–‰ë™ ì²˜ë¦¬
        unicornAction(unicorn);
        
        // í–‰ë™ ì™„ë£Œ í‘œì‹œ (ì´ë²ˆ í„´ì— ë‹¤ì‹œ í–‰ë™í•˜ì§€ ì•Šë„ë¡)
        unicorn.nextMoveTime = currentTurnTime - 1;
      }
    });
  });
}

// í„´ ì¢…ë£Œ í•¨ìˆ˜
function endRealTimeTurn() {
  // í”Œë ˆì´ì–´ê°€ í¬í•¨ëœ ê·¸ë£¹ì´ ìˆëŠ” ê²½ìš°ì—ë§Œ ë©”ì‹œì§€ í‘œì‹œ
  const playerInvolved = sightGroups.some(group => group.hasPlayer);
  
  // í”Œë ˆì´ì–´ê°€ ì´ë²ˆ í„´ì— í–‰ë™í•˜ì§€ ì•Šì•˜ë‹¤ë©´ ë©”ì‹œì§€ í‘œì‹œ (í”Œë ˆì´ì–´ê°€ í¬í•¨ëœ ê²½ìš°ë§Œ)
  if (playerInvolved && !playerActedThisTurn) {
    addMsg('í„´ì´ ì§€ë‚˜ê°”ìŠµë‹ˆë‹¤! ë¹ ë¥´ê²Œ í–‰ë™í•˜ì„¸ìš”.');
  }
  
  // ì‹œì•¼ ê³µìœ  ê·¸ë£¹ ì—…ë°ì´íŠ¸
  updateSightGroups();
  
  // ì‹¤ì‹œê°„ í„´ì´ ê³„ì† í™œì„±í™”ë˜ì–´ ìˆë‹¤ë©´ UI ì—…ë°ì´íŠ¸
  if (realTimeTurnActive) {
    render();
  }
}

// ìœ ë‹ˆì½˜ í–‰ë™ í•¨ìˆ˜
function unicornAction(unicorn) {
  // ì´ë¯¸ ì£½ì—ˆë‹¤ë©´ í–‰ë™í•˜ì§€ ì•ŠìŒ
  if (unicorn.hp <= 0) return;
  
  // ì‹œì•¼ ë‚´ ëª¬ìŠ¤í„° ì°¾ê¸° (ìœ ë‹ˆì½˜ì€ ë‹¤ë¥¸ ëª¬ìŠ¤í„°ë§Œ ê³µê²©)
  const unicornFOV = calcMonsterFOV(unicorn);
  let nearestMonster = null;
  let minDistance = Infinity;
  
  monsters.forEach(m => {
    // ìê¸° ìì‹ ì´ê±°ë‚˜ ìœ ë‹ˆì½˜ì´ê±°ë‚˜ ì´ë¯¸ ì£½ì€ ëª¬ìŠ¤í„°ëŠ” ì œì™¸
    if (m === unicorn || m.isUnicorn || m.hp <= 0) return;
    
    // ì‹œì•¼ ë‚´ì— ìˆëŠ”ì§€ í™•ì¸
    if (unicornFOV[`${m.x},${m.y}`]) {
      // ê±°ë¦¬ ê³„ì‚°
      const distance = Math.abs(m.x - unicorn.x) + Math.abs(m.y - unicorn.y);
      
      // ë” ê°€ê¹Œìš´ ëª¬ìŠ¤í„° ë°œê²¬ ì‹œ ì—…ë°ì´íŠ¸
      if (distance < minDistance) {
        minDistance = distance;
        nearestMonster = m;
      }
    }
  });
  
  // ê°€ê¹Œìš´ ëª¬ìŠ¤í„°ê°€ ìˆìœ¼ë©´ ê·¸ ë°©í–¥ìœ¼ë¡œ ì´ë™ ë˜ëŠ” ê³µê²©
  if (nearestMonster) {
    unicorn.targetMonster = nearestMonster;
    const dx = Math.sign(nearestMonster.x - unicorn.x);
    const dy = Math.sign(nearestMonster.y - unicorn.y);
    const dist = Math.max(Math.abs(nearestMonster.x - unicorn.x), Math.abs(nearestMonster.y - unicorn.y));
    
    if (dist <= 1) {
      // ëª¬ìŠ¤í„°ì™€ ì¸ì ‘í•´ ìˆìœ¼ë©´ ê³µê²©
      nearestMonster.hp -= 4; // ìœ ë‹ˆì½˜ì€ ê°•í•œ ê³µê²©ë ¥
      addMsg('ìœ ë‹ˆì½˜ì´ ëª¬ìŠ¤í„°ë¥¼ ê³µê²©í–ˆìŠµë‹ˆë‹¤!');
      
      if (nearestMonster.hp <= 0) {
        addMsg('ìœ ë‹ˆì½˜ì´ ëª¬ìŠ¤í„°ë¥¼ ì²˜ì¹˜í–ˆìŠµë‹ˆë‹¤!');
        unicorn.targetMonster = null;
      }
    } else {
      // ëª¬ìŠ¤í„° ë°©í–¥ìœ¼ë¡œ ì´ë™ ì‹œë„
      const nx = unicorn.x + dx;
      const ny = unicorn.y + dy;
      
      if (inMap(nx, ny) && map[ny][nx] !== WALL && 
          !monsters.some(m => m !== unicorn && m.x === nx && m.y === ny && m.hp > 0)) {
        unicorn.x = nx;
        unicorn.y = ny;
        addMsg('ìœ ë‹ˆì½˜ì´ ëª¬ìŠ¤í„°ë¥¼ í–¥í•´ ì›€ì§ì…ë‹ˆë‹¤.');
      }
    }
  } else if (unicorn.lastSeenPlayer) {
    // ëª¬ìŠ¤í„°ê°€ ì—†ê³  í”Œë ˆì´ì–´ë¥¼ ë³¸ ì ì´ ìˆìœ¼ë©´ í”Œë ˆì´ì–´ ê·¼ì²˜ë¡œ ì´ë™
    const dx = Math.sign(player.x - unicorn.x);
    const dy = Math.sign(player.y - unicorn.y);
    const dist = Math.max(Math.abs(player.x - unicorn.x), Math.abs(player.y - unicorn.y));
    
    // í”Œë ˆì´ì–´ì™€ ë„ˆë¬´ ê°€ê¹Œìš°ë©´ ê±°ë¦¬ë¥¼ ìœ ì§€
    if (dist <= 2) {
      // í”Œë ˆì´ì–´ë¡œë¶€í„° ë©€ì–´ì§€ëŠ” ë°©í–¥ ì°¾ê¸°
      const nx = unicorn.x - dx;
      const ny = unicorn.y - dy;
      
      if (inMap(nx, ny) && map[ny][nx] !== WALL && 
          !monsters.some(m => m !== unicorn && m.x === nx && m.y === ny && m.hp > 0)) {
        unicorn.x = nx;
        unicorn.y = ny;
      }
    } else if (dist > 5) {
      // í”Œë ˆì´ì–´ì™€ ë„ˆë¬´ ë©€ë©´ ê°€ê¹Œì›Œì§
      const nx = unicorn.x + dx;
      const ny = unicorn.y + dy;
      
      if (inMap(nx, ny) && map[ny][nx] !== WALL && 
          !monsters.some(m => m !== unicorn && m.x === nx && m.y === ny && m.hp > 0)) {
        unicorn.x = nx;
        unicorn.y = ny;
      }
    } else {
      // ì ì ˆí•œ ê±°ë¦¬ë©´ ëœë¤ ì´ë™
      randomUnicornMovement(unicorn);
    }
  } else {
    // í”Œë ˆì´ì–´ë¥¼ ë³¸ ì ì´ ì—†ìœ¼ë©´ ëœë¤ ì´ë™
    randomUnicornMovement(unicorn);
  }
  
  // í–‰ë™ í›„ ì‹œì•¼ ê³µìœ  ìƒíƒœ ì—…ë°ì´íŠ¸ëŠ” í”Œë ˆì´ì–´ê°€ ì‹œì•¼ì— ìˆì„ ê°€ëŠ¥ì„±ì´ ìˆì„ ë•Œë§Œ ìˆ˜í–‰
  if (unicorn.lastSeenPlayer) {
    updateSightGroups();
  }
}

// ìœ ë‹ˆì½˜ ëœë¤ ì´ë™ í—¬í¼ í•¨ìˆ˜
function randomUnicornMovement(unicorn) {
  const directions = [
    { dx: -1, dy: 0 }, { dx: 1, dy: 0 }, { dx: 0, dy: -1 }, { dx: 0, dy: 1 },
    { dx: -1, dy: -1 }, { dx: 1, dy: -1 }, { dx: -1, dy: 1 }, { dx: 1, dy: 1 }
  ];
  
  // ëœë¤ ë°©í–¥ ì„ íƒ
  const dir = directions[Math.floor(Math.random() * directions.length)];
  const nx = unicorn.x + dir.dx;
  const ny = unicorn.y + dir.dy;
  
  // ìœ íš¨í•œ ìœ„ì¹˜ë¼ë©´ ì´ë™
  if (inMap(nx, ny) && map[ny][nx] !== WALL && 
      !monsters.some(m => m !== unicorn && m.x === nx && m.y === ny && m.hp > 0)) {
    unicorn.x = nx;
    unicorn.y = ny;
  }
}

// ê²Œì„ ë£¨í”„ í•¨ìˆ˜
function startGameLoop() {
  // ê²Œì„ ë£¨í”„ ê°„ê²© (ë°€ë¦¬ì´ˆ)
  const GAME_LOOP_INTERVAL = 50; // 50msë§ˆë‹¤ ì—…ë°ì´íŠ¸ (ì´ˆë‹¹ 20íšŒ)
  
  // ê²Œì„ ë£¨í”„ ì„¤ì •
  window.gameLoopInterval = setInterval(() => {
    // ê²Œì„ ì˜¤ë²„ ìƒíƒœë©´ ë£¨í”„ ì¤‘ë‹¨
    if (gameOver) {
      clearInterval(window.gameLoopInterval);
      return;
    }
    
    // ì‹¤ì‹œê°„ í„´ ì‹œìŠ¤í…œ ì²˜ë¦¬
    if (realTimeTurnActive) {
      processRealTimeTurn();
      
      // í„´ íƒ€ì´ë¨¸ UI ì—…ë°ì´íŠ¸
      const turnTimer = document.getElementById('turn-timer');
      const turnTimerBar = document.getElementById('turn-timer-bar');
      
      if (turnTimer && turnTimerBar) {
        // ì‹¤ì‹œê°„ í„´ ì‹œìŠ¤í…œì´ í™œì„±í™”ëœ ê²½ìš°ì—ë§Œ íƒ€ì´ë¨¸ í‘œì‹œ (ì´ë¯¸ í”Œë ˆì´ì–´ê°€ ìœ ë‹ˆì½˜ì„ ë³¼ ìˆ˜ ìˆëŠ”ì§€ í™•ì¸ë¨)
        turnTimer.style.display = 'block';
        const now = Date.now();
        const elapsed = now - currentTurnTime;
        const remaining = Math.max(0, turnDuration - elapsed);
        const percent = (remaining / turnDuration) * 100;
        
        turnTimerBar.style.width = `${percent}%`;
        
        // ë‚¨ì€ ì‹œê°„ì— ë”°ë¼ ìƒ‰ìƒ ë³€ê²½
        if (percent > 60) {
          turnTimerBar.style.backgroundColor = '#0f0'; // ë…¹ìƒ‰
        } else if (percent > 30) {
          turnTimerBar.style.backgroundColor = '#ff0'; // ë…¸ë€ìƒ‰
        } else {
          turnTimerBar.style.backgroundColor = '#f00'; // ë¹¨ê°„ìƒ‰
        }
      }
    } else {
      // ì‹¤ì‹œê°„ í„´ ì‹œìŠ¤í…œì´ ë¹„í™œì„±í™”ëœ ê²½ìš° íƒ€ì´ë¨¸ ìˆ¨ê¹€
      const turnTimer = document.getElementById('turn-timer');
      if (turnTimer) {
        turnTimer.style.display = 'none';
      }
    }
  }, GAME_LOOP_INTERVAL);
}

// í”„ë™íƒˆ ë…¸ì´ì¦ˆ ìƒì„±ì„ ìœ„í•œ ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
function generateNoise(width, height, scale, octaves, persistence, lacunarity, seed) {
  // 2D ë…¸ì´ì¦ˆ ë§µ ì´ˆê¸°í™”
  const noiseMap = new Array(height);
  for (let y = 0; y < height; y++) {
    noiseMap[y] = new Array(width);
  }
  
  // ì‹œë“œ ê¸°ë°˜ ëœë¤ í•¨ìˆ˜
  const seededRandom = function(x, y) {
    const dot = x * 12.9898 + y * 78.233 + seed;
    let value = Math.sin(dot) * 43758.5453123;
    value = value - Math.floor(value);
    return value;
  };
  
  // ë³´ê°„ í•¨ìˆ˜
  const smoothstep = function(a, b, t) {
    t = Math.max(0, Math.min(1, (t - a) / (b - a)));
    return t * t * (3 - 2 * t);
  };
  
  // 2D ê°’ ë…¸ì´ì¦ˆ ìƒì„±
  const valueNoise2D = function(x, y) {
    // ê²©ìì  ì¢Œí‘œ
    const x0 = Math.floor(x);
    const y0 = Math.floor(y);
    const x1 = x0 + 1;
    const y1 = y0 + 1;
    
    // ê° ê²©ìì ì—ì„œì˜ ëœë¤ê°’
    const v00 = seededRandom(x0, y0);
    const v10 = seededRandom(x1, y0);
    const v01 = seededRandom(x0, y1);
    const v11 = seededRandom(x1, y1);
    
    // ë³´ê°„ ê°€ì¤‘ì¹˜
    const sx = smoothstep(0, 1, x - x0);
    const sy = smoothstep(0, 1, y - y0);
    
    // ìˆ˜í‰ ë³´ê°„
    const a = v00 * (1 - sx) + v10 * sx;
    const b = v01 * (1 - sx) + v11 * sx;
    
    // ìˆ˜ì§ ë³´ê°„
    return a * (1 - sy) + b * sy;
  };
  
  // ì˜¥íƒ€ë¸Œ ë…¸ì´ì¦ˆ ìƒì„±
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      let amplitude = 1;
      let frequency = 1;
      let noiseValue = 0;
      let normalizer = 0;
      
      // ì—¬ëŸ¬ ì˜¥íƒ€ë¸Œì˜ ë…¸ì´ì¦ˆë¥¼ í•©ì„±
      for (let o = 0; o < octaves; o++) {
        const sampleX = x / scale * frequency;
        const sampleY = y / scale * frequency;
        
        const noise = valueNoise2D(sampleX, sampleY) * 2 - 1;
        noiseValue += noise * amplitude;
        normalizer += amplitude;
        
        amplitude *= persistence;
        frequency *= lacunarity;
      }
      
      // ì •ê·œí™”
      noiseValue = noiseValue / normalizer;
      noiseMap[y][x] = (noiseValue + 1) / 2; // 0~1 ë²”ìœ„ë¡œ ë³€í™˜
    }
  }
  
  return noiseMap;
}

// í”„ë™íƒˆ ë…¸ì´ì¦ˆë¥¼ ì´ìš©í•œ ìì—°ìŠ¤ëŸ¬ìš´ ì§€í˜• ìƒì„±
function generateTerrainWithNoise() {
  // ë…¸ì´ì¦ˆ ë§µ ìƒì„±
  const noiseMap = generateNoise(MAP_W, MAP_H, 20, 4, 0.5, 2, Math.random() * 10000);
  
  // ë…¸ì´ì¦ˆ ê°’ì— ë”°ë¥¸ ì§€í˜• ì„¤ì •
  for (let y = 1; y < MAP_H - 1; y++) {
    for (let x = 1; x < MAP_W - 1; x++) {
      const noiseValue = noiseMap[y][x];
      
      // ì´ë¯¸ íŠ¹ë³„í•œ ë°”ì´ì˜´ì´ë‚˜ êµ¬ì¡°ë¬¼ì´ ìˆëŠ” ê²½ìš° ê±´ë„ˆë›°ê¸°
      if (terrainMap[y][x] !== TERRAIN_TYPES.GRASS) continue;
      
      // ë…¸ì´ì¦ˆ ê°’ì— ë”°ë¥¸ ì§€í˜• ê²°ì •
      if (noiseValue < 0.3) {
        // ë¬¼
        terrainMap[y][x] = TERRAIN_TYPES.WATER;
        map[y][x] = WALL; // ë¬¼ì€ í†µê³¼ ë¶ˆê°€ëŠ¥
      } else if (noiseValue < 0.4) {
        // ëŠªì§€ëŒ€
        terrainMap[y][x] = TERRAIN_TYPES.SWAMP;
      } else if (noiseValue < 0.6) {
        // ì”ë”” (ê¸°ë³¸ê°’)
        terrainMap[y][x] = TERRAIN_TYPES.GRASS;
      } else if (noiseValue < 0.75) {
        // ìˆ²
        terrainMap[y][x] = TERRAIN_TYPES.FOREST;
        if (Math.random() < 0.3) {
          map[y][x] = WALL;
          terrainMap[y][x] = TERRAIN_TYPES.TREE;
        }
      } else {
        // ì‚°
        terrainMap[y][x] = TERRAIN_TYPES.MOUNTAIN;
        if (noiseValue > 0.85) {
          map[y][x] = WALL;
          terrainMap[y][x] = TERRAIN_TYPES.ROCK;
        }
      }
    }
  }
}

// ë™ì  ìœ„í—˜ ì§€ì—­ ê´€ë ¨ ë³€ìˆ˜
let dangerZones = [];
const DANGER_TYPES = {
  LAVA: { name: 'LAVA', emoji: 'ğŸŒ‹', damage: 3, spreadChance: 0.05, duration: 20 },
  POISON: { name: 'POISON', emoji: 'â˜£ï¸', damage: 1, spreadChance: 0.1, duration: 15 },
  RADIATION: { name: 'RADIATION', emoji: 'â˜¢ï¸', damage: 2, spreadChance: 0.03, duration: 30 }
};

// ë™ì  ìœ„í—˜ ì§€ì—­ ìƒì„± í•¨ìˆ˜
function createDangerZone(type, x, y, radius, duration) {
  const dangerType = DANGER_TYPES[type];
  if (!dangerType) return;
  
  // ìƒˆë¡œìš´ ìœ„í—˜ ì§€ì—­ ìƒì„±
  const newZone = {
    type: dangerType,
    center: { x, y },
    radius: radius,
    tiles: [],
    remainingTurns: duration || dangerType.duration,
    lastSpreadTurn: 0
  };
  
  // ì´ˆê¸° ìœ„í—˜ ì§€ì—­ íƒ€ì¼ ì„¤ì •
  for (let dy = -radius; dy <= radius; dy++) {
    for (let dx = -radius; dx <= radius; dx++) {
      const tx = x + dx;
      const ty = y + dy;
      
      if (!inMap(tx, ty)) continue;
      
      // ì¤‘ì‹¬ìœ¼ë¡œë¶€í„°ì˜ ê±°ë¦¬ ê³„ì‚°
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      if (distance <= radius) {
        // ê±°ë¦¬ì— ë”°ë¥¸ í™•ë¥ ë¡œ ìœ„í—˜ ì§€ì—­ íƒ€ì¼ ì„¤ì •
        const probability = 1 - (distance / radius);
        
        if (Math.random() < probability * 0.7) {
          // ìœ„í—˜ ì§€ì—­ íƒ€ì¼ ì¶”ê°€
          newZone.tiles.push({ x: tx, y: ty });
          
          // ì§€í˜• ì—…ë°ì´íŠ¸ (ì‹œê°ì  í‘œì‹œ)
          if (type === 'LAVA') {
            terrainMap[ty][tx] = TERRAIN_TYPES.LAVA;
          } else if (type === 'POISON') {
            terrainMap[ty][tx] = TERRAIN_TYPES.SWAMP;
          } else if (type === 'RADIATION') {
            terrainMap[ty][tx] = TERRAIN_TYPES.WASTELAND;
          }
        }
      }
    }
  }
  
  // ìœ„í—˜ ì§€ì—­ ë“±ë¡
  dangerZones.push(newZone);
}

// ìœ„í—˜ ì§€ì—­ ì—…ë°ì´íŠ¸ í•¨ìˆ˜ (í„´ë§ˆë‹¤ í˜¸ì¶œ)
function updateDangerZones() {
  // í”Œë ˆì´ì–´ê°€ ìœ„í—˜ ì§€ì—­ì— ìˆëŠ”ì§€ í™•ì¸
  for (const zone of dangerZones) {
    // í”Œë ˆì´ì–´ê°€ ìœ„í—˜ ì§€ì—­ íƒ€ì¼ì— ìˆëŠ”ì§€ í™•ì¸
    const playerInDanger = zone.tiles.some(tile => tile.x === player.x && tile.y === player.y);
    
    if (playerInDanger) {
      // í”Œë ˆì´ì–´ì—ê²Œ ë°ë¯¸ì§€
      player.hp -= zone.type.damage;
      addMsg(`${zone.type.name} ì§€ì—­ì—ì„œ ${zone.type.damage}ì˜ ë°ë¯¸ì§€ë¥¼ ì…ì—ˆìŠµë‹ˆë‹¤!`);
      
      if (player.hp <= 0) {
        gameOver = true;
        addMsg('ìœ„í—˜ ì§€ì—­ì—ì„œ ì‚¬ë§í–ˆìŠµë‹ˆë‹¤!');
      }
    }
    
    // ìœ„í—˜ ì§€ì—­ ì§€ì† ì‹œê°„ ê°ì†Œ
    zone.remainingTurns--;
    
    // ìœ„í—˜ ì§€ì—­ í™•ì‚° (3í„´ë§ˆë‹¤)
    if (zone.remainingTurns % 3 === 0) {
      spreadDangerZone(zone);
    }
    
    // ì§€ì† ì‹œê°„ì´ ëë‚œ ìœ„í—˜ ì§€ì—­ ì œê±°
    if (zone.remainingTurns <= 0) {
      // ì§€í˜• ë³µì›
      for (const tile of zone.tiles) {
        terrainMap[tile.y][tile.x] = TERRAIN_TYPES.GRASS;
      }
    }
  }
  
  // ì§€ì† ì‹œê°„ì´ ëë‚œ ìœ„í—˜ ì§€ì—­ í•„í„°ë§
  dangerZones = dangerZones.filter(zone => zone.remainingTurns > 0);
}

// ìœ„í—˜ ì§€ì—­ í™•ì‚° í•¨ìˆ˜
function spreadDangerZone(zone) {
  const newTiles = [];
  
  // ê¸°ì¡´ íƒ€ì¼ì—ì„œ í™•ì‚°
  for (const tile of zone.tiles) {
    // ì¸ì ‘í•œ 4ë°©í–¥ í™•ì¸
    const directions = [
      { dx: 0, dy: -1 }, // ìƒ
      { dx: 1, dy: 0 },  // ìš°
      { dx: 0, dy: 1 },  // í•˜
      { dx: -1, dy: 0 }  // ì¢Œ
    ];
    
    for (const dir of directions) {
      const nx = tile.x + dir.dx;
      const ny = tile.y + dir.dy;
      
      // ë§µ ë²”ìœ„ í™•ì¸
      if (!inMap(nx, ny)) continue;
      
      // ì´ë¯¸ ìœ„í—˜ ì§€ì—­ì¸ì§€ í™•ì¸
      const alreadyDanger = zone.tiles.some(t => t.x === nx && t.y === ny) || 
                           newTiles.some(t => t.x === nx && t.y === ny);
      
      if (!alreadyDanger && Math.random() < zone.type.spreadChance) {
        // ìƒˆë¡œìš´ ìœ„í—˜ ì§€ì—­ íƒ€ì¼ ì¶”ê°€
        newTiles.push({ x: nx, y: ny });
        
        // ì§€í˜• ì—…ë°ì´íŠ¸ (ì‹œê°ì  í‘œì‹œ)
        if (zone.type.name === 'LAVA') {
          terrainMap[ny][nx] = TERRAIN_TYPES.LAVA;
        } else if (zone.type.name === 'POISON') {
          terrainMap[ny][nx] = TERRAIN_TYPES.SWAMP;
        } else if (zone.type.name === 'RADIATION') {
          terrainMap[ny][nx] = TERRAIN_TYPES.WASTELAND;
        }
      }
    }
  }
  
  // ìƒˆë¡œìš´ íƒ€ì¼ ì¶”ê°€
  zone.tiles = [...zone.tiles, ...newTiles];
}

// ëœë¤ ìœ„í—˜ ì§€ì—­ ìƒì„±
function createRandomDangerZones(count) {
  const dangerTypes = Object.keys(DANGER_TYPES);
  
  for (let i = 0; i < count; i++) {
    // ëœë¤ ìœ„ì¹˜ ì„ íƒ
    let x, y;
    let validPosition = false;
    let attempts = 0;
    
    while (!validPosition && attempts < 100) {
      x = Math.floor(Math.random() * (MAP_W - 20)) + 10;
      y = Math.floor(Math.random() * (MAP_H - 20)) + 10;
      
      // í”Œë ˆì´ì–´ì™€ì˜ ê±°ë¦¬ í™•ì¸
      const distToPlayer = Math.sqrt(Math.pow(x - player.x, 2) + Math.pow(y - player.y, 2));
      
      // í”Œë ˆì´ì–´ë¡œë¶€í„° ì¶©ë¶„íˆ ë–¨ì–´ì ¸ ìˆëŠ”ì§€ í™•ì¸
      if (distToPlayer > 15) {
        validPosition = true;
      }
      
      attempts++;
    }
    
    if (validPosition) {
      // ëœë¤ ìœ„í—˜ íƒ€ì… ì„ íƒ
      const randomType = dangerTypes[Math.floor(Math.random() * dangerTypes.length)];
      
      // ìœ„í—˜ ì§€ì—­ ìƒì„±
      const radius = Math.floor(Math.random() * 3) + 3; // 3~5 ë²”ìœ„
      createDangerZone(randomType, x, y, radius);
    }
  }
}

// ë¯¸ë¡œ ìƒì„± í•¨ìˆ˜ (ê¹Šì´ ìš°ì„  íƒìƒ‰)
function generateMaze(startX, startY, width, height) {
  // ë¯¸ë¡œ ì˜ì—­ ì´ˆê¸°í™” (ëª¨ë‘ ë²½ìœ¼ë¡œ)
  for (let y = startY; y < startY + height; y++) {
    for (let x = startX; x < startX + width; x++) {
      if (inMap(x, y)) {
        map[y][x] = WALL;
        terrainMap[y][x] = TERRAIN_TYPES.WALL;
      }
    }
  }
  
  // ë¯¸ë¡œ ìƒì„±ì„ ìœ„í•œ ë°©ë¬¸ ë°°ì—´
  const visited = Array(height).fill().map(() => Array(width).fill(false));
  
  // ê¹Šì´ ìš°ì„  íƒìƒ‰ìœ¼ë¡œ ë¯¸ë¡œ ìƒì„±
  function dfs(x, y) {
    visited[y][x] = true;
    
    // ì‹¤ì œ ë§µ ì¢Œí‘œë¡œ ë³€í™˜
    const mapX = x * 2 + startX;
    const mapY = y * 2 + startY;
    
    // í˜„ì¬ ì…€ì„ ê¸¸ë¡œ ì„¤ì •
    if (inMap(mapX, mapY)) {
      map[mapY][mapX] = FLOOR;
      terrainMap[mapY][mapX] = TERRAIN_TYPES.DUNGEON;
    }
    
    // ì´ë™ ë°©í–¥ (ìƒ, ìš°, í•˜, ì¢Œ)
    const directions = [
      { dx: 0, dy: -1 }, // ìƒ
      { dx: 1, dy: 0 },  // ìš°
      { dx: 0, dy: 1 },  // í•˜
      { dx: -1, dy: 0 }  // ì¢Œ
    ];
    
    // ë°©í–¥ ëœë¤ ì„ê¸°
    for (let i = directions.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [directions[i], directions[j]] = [directions[j], directions[i]];
    }
    
    // ê° ë°©í–¥ìœ¼ë¡œ íƒìƒ‰
    for (const dir of directions) {
      const nx = x + dir.dx;
      const ny = y + dir.dy;
      
      // ë²”ìœ„ ì²´í¬
      if (nx < 0 || ny < 0 || nx >= Math.floor(width / 2) || ny >= Math.floor(height / 2)) continue;
      
      // ë°©ë¬¸í•˜ì§€ ì•Šì€ ì…€ì´ë©´ ì´ë™
      if (!visited[ny][nx]) {
        // ì¤‘ê°„ ë²½ ì œê±° (í†µë¡œ ìƒì„±)
        const wallX = mapX + dir.dx;
        const wallY = mapY + dir.dy;
        
        if (inMap(wallX, wallY)) {
          map[wallY][wallX] = FLOOR;
          terrainMap[wallY][wallX] = TERRAIN_TYPES.DUNGEON;
        }
        
        // ë‹¤ìŒ ì…€ë¡œ ì´ë™
        dfs(nx, ny);
      }
    }
  }
  
  // ì‹œì‘ì ì—ì„œ ë¯¸ë¡œ ìƒì„± ì‹œì‘
  dfs(0, 0);
  
  // ë¯¸ë¡œì— ì…êµ¬ì™€ ì¶œêµ¬ ìƒì„±
  createMazeEntrances(startX, startY, width, height);
}

// ë¯¸ë¡œ ì…êµ¬ì™€ ì¶œêµ¬ ìƒì„±
function createMazeEntrances(startX, startY, width, height) {
  // ì…êµ¬ ìƒì„± (ë¯¸ë¡œ ì™¸ë¶€ì—ì„œ ì ‘ê·¼ ê°€ëŠ¥í•œ ìœ„ì¹˜)
  const entranceDirections = [
    { dx: 0, dy: -1, side: 'top' },    // ìƒë‹¨
    { dx: width, dy: 0, side: 'right' }, // ìš°ì¸¡
    { dx: 0, dy: height, side: 'bottom' }, // í•˜ë‹¨
    { dx: -1, dy: 0, side: 'left' }    // ì¢Œì¸¡
  ];
  
  // ê° ë°©í–¥ì—ì„œ ì…êµ¬ ìƒì„± ì‹œë„
  for (const dir of entranceDirections) {
    // í•´ë‹¹ ë°©í–¥ì—ì„œ ì ì ˆí•œ ì…êµ¬ ìœ„ì¹˜ ì°¾ê¸°
    let entranceX, entranceY;
    let found = false;
    let attempts = 0;
    
    while (!found && attempts < 10) {
      if (dir.side === 'top' || dir.side === 'bottom') {
        // ìƒë‹¨ ë˜ëŠ” í•˜ë‹¨ ì…êµ¬
        entranceX = startX + Math.floor(Math.random() * (width - 2)) + 1;
        entranceY = startY + (dir.side === 'top' ? 0 : height - 1);
      } else {
        // ì¢Œì¸¡ ë˜ëŠ” ìš°ì¸¡ ì…êµ¬
        entranceX = startX + (dir.side === 'left' ? 0 : width - 1);
        entranceY = startY + Math.floor(Math.random() * (height - 2)) + 1;
      }
      
      // ì…êµ¬ ìœ„ì¹˜ê°€ ìœ íš¨í•œì§€ í™•ì¸
      if (inMap(entranceX, entranceY) && 
          inMap(entranceX + dir.dx, entranceY + dir.dy)) {
        // ì…êµ¬ ìƒì„±
        map[entranceY][entranceX] = FLOOR;
        terrainMap[entranceY][entranceX] = TERRAIN_TYPES.DUNGEON;
        
        // ì…êµ¬ ì£¼ë³€ë„ ê¸¸ë¡œ ì„¤ì • (ì ‘ê·¼ ê°€ëŠ¥í•˜ë„ë¡)
        const outsideX = entranceX + dir.dx;
        const outsideY = entranceY + dir.dy;
        
        if (map[outsideY][outsideX] === WALL) {
          map[outsideY][outsideX] = FLOOR;
          terrainMap[outsideY][outsideX] = TERRAIN_TYPES.GRASS;
        }
        
        found = true;
      }
      
      attempts++;
    }
  }
}

// í†µë¡œ ì‹œìŠ¤í…œ ìƒì„± í•¨ìˆ˜
function createTunnelSystem(count) {
  for (let i = 0; i < count; i++) {
    // ì‹œì‘ì ê³¼ ëì  ì„ íƒ
    let startX, startY, endX, endY;
    let validPoints = false;
    let attempts = 0;
    
    while (!validPoints && attempts < 100) {
      // ì‹œì‘ì  ì„ íƒ
      startX = Math.floor(Math.random() * (MAP_W - 20)) + 10;
      startY = Math.floor(Math.random() * (MAP_H - 20)) + 10;
      
      // ëì  ì„ íƒ (ì‹œì‘ì ìœ¼ë¡œë¶€í„° ì¼ì • ê±°ë¦¬ ë–¨ì–´ì§„ ìœ„ì¹˜)
      const angle = Math.random() * Math.PI * 2;
      const distance = 15 + Math.random() * 20;
      endX = Math.floor(startX + Math.cos(angle) * distance);
      endY = Math.floor(startY + Math.sin(angle) * distance);
      
      // ë§µ ë²”ìœ„ ë‚´ì¸ì§€ í™•ì¸
      if (inMap(startX, startY) && inMap(endX, endY)) {
        validPoints = true;
      }
      
      attempts++;
    }
    
    if (validPoints) {
      // í†µë¡œ ìƒì„± (A* ì•Œê³ ë¦¬ì¦˜)
      createTunnel(startX, startY, endX, endY);
    }
  }
}

// A* ì•Œê³ ë¦¬ì¦˜ì„ ì´ìš©í•œ í†µë¡œ ìƒì„±
function createTunnel(startX, startY, endX, endY) {
  // íœ´ë¦¬ìŠ¤í‹± í•¨ìˆ˜ (ë§¨í•´íŠ¼ ê±°ë¦¬)
  const heuristic = (x, y) => Math.abs(x - endX) + Math.abs(y - endY);
  
  // ìš°ì„ ìˆœìœ„ í êµ¬í˜„ (ê°„ë‹¨í•œ ë°°ì—´ë¡œ)
  const openSet = [{ x: startX, y: startY, g: 0, h: heuristic(startX, startY) }];
  const closedSet = new Set();
  const cameFrom = {};
  
  // g ì ìˆ˜ (ì‹œì‘ì ìœ¼ë¡œë¶€í„°ì˜ ë¹„ìš©)
  const gScore = {};
  gScore[`${startX},${startY}`] = 0;
  
  while (openSet.length > 0) {
    // f ì ìˆ˜ê°€ ê°€ì¥ ë‚®ì€ ë…¸ë“œ ì°¾ê¸°
    let lowestIndex = 0;
    for (let i = 1; i < openSet.length; i++) {
      if (openSet[i].g + openSet[i].h < openSet[lowestIndex].g + openSet[lowestIndex].h) {
        lowestIndex = i;
      }
    }
    
    const current = openSet[lowestIndex];
    
    // ëª©ì ì§€ì— ë„ë‹¬í•œ ê²½ìš°
    if (current.x === endX && current.y === endY) {
      // ê²½ë¡œ ì¬êµ¬ì„±
      let path = [];
      let currentKey = `${current.x},${current.y}`;
      
      while (currentKey in cameFrom) {
        const [x, y] = currentKey.split(',').map(Number);
        path.push({ x, y });
        currentKey = cameFrom[currentKey];
      }
      
      // ì‹œì‘ì  ì¶”ê°€
      path.push({ x: startX, y: startY });
      path.reverse();
      
      // í†µë¡œ ìƒì„±
      for (const pos of path) {
        if (inMap(pos.x, pos.y)) {
          map[pos.y][pos.x] = FLOOR;
          
          // í†µë¡œ ì£¼ë³€ ì§€í˜• ì„¤ì •
          const surroundingType = Math.random() < 0.5 ? TERRAIN_TYPES.CAVE : TERRAIN_TYPES.DUNGEON;
          terrainMap[pos.y][pos.x] = surroundingType;
          
          // í†µë¡œ ì£¼ë³€ ì•½ê°„ ë„“íˆê¸° (20% í™•ë¥ )
          if (Math.random() < 0.2) {
            const dx = Math.random() < 0.5 ? -1 : 1;
            const dy = Math.random() < 0.5 ? -1 : 1;
            
            if (inMap(pos.x + dx, pos.y) && map[pos.y][pos.x + dx] === WALL) {
              map[pos.y][pos.x + dx] = FLOOR;
              terrainMap[pos.y][pos.x + dx] = surroundingType;
            }
            
            if (inMap(pos.x, pos.y + dy) && map[pos.y + dy][pos.x] === WALL) {
              map[pos.y + dy][pos.x] = FLOOR;
              terrainMap[pos.y + dy][pos.x] = surroundingType;
            }
          }
        }
      }
      
      return;
    }
    
    // í˜„ì¬ ë…¸ë“œ ì²˜ë¦¬ ì™„ë£Œ
    openSet.splice(lowestIndex, 1);
    closedSet.add(`${current.x},${current.y}`);
    
    // ì´ì›ƒ ë…¸ë“œ íƒìƒ‰
    const neighbors = [
      { dx: 0, dy: -1 }, // ìƒ
      { dx: 1, dy: 0 },  // ìš°
      { dx: 0, dy: 1 },  // í•˜
      { dx: -1, dy: 0 }  // ì¢Œ
    ];
    
    for (const dir of neighbors) {
      const nx = current.x + dir.dx;
      const ny = current.y + dir.dy;
      
      // ë§µ ë²”ìœ„ ì²´í¬
      if (!inMap(nx, ny)) continue;
      
      // ì´ë¯¸ ì²˜ë¦¬í•œ ë…¸ë“œì¸ì§€ í™•ì¸
      if (closedSet.has(`${nx},${ny}`)) continue;
      
      // ì´ì›ƒ ë…¸ë“œê¹Œì§€ì˜ ë¹„ìš©
      const tentativeGScore = gScore[`${current.x},${current.y}`] + 1;
      
      // ì´ì›ƒ ë…¸ë“œê°€ openSetì— ì—†ê±°ë‚˜, ë” ë‚˜ì€ ê²½ë¡œë¥¼ ì°¾ì€ ê²½ìš°
      const neighborKey = `${nx},${ny}`;
      if (!openSet.some(node => node.x === nx && node.y === ny) || 
          tentativeGScore < (gScore[neighborKey] || Infinity)) {
        // ê²½ë¡œ ì—…ë°ì´íŠ¸
        cameFrom[neighborKey] = `${current.x},${current.y}`;
        gScore[neighborKey] = tentativeGScore;
        
        // openSetì— ì—†ìœ¼ë©´ ì¶”ê°€
        if (!openSet.some(node => node.x === nx && node.y === ny)) {
          openSet.push({
            x: nx,
            y: ny,
            g: tentativeGScore,
            h: heuristic(nx, ny)
          });
        }
      }
    }
  }
}
</script>
</body>
</html>