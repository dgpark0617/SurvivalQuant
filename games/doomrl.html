<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <title>Doom Emoji RL (Emoji-based, JS, One File, Customizable, True Turn-based Reload)</title>
  <style>
    body { 
      background: #222; 
      color: #eee; 
      font-family: 'Courier New', monospace; 
      text-align: center;
      margin: 0;
      padding: 20px;
    }
    #game-container {
      display: inline-block;
      margin: 0 auto;
      max-width: 100%;
    }
    #game-grid {
      display: grid;
      grid-template-columns: repeat(30, 1fr);
      gap: 0px;
      margin-bottom: 10px;
      background-color: #111;
      border: 2px solid #444;
      padding: 5px;
    }
    .cell {
      width: 20px;
      height: 20px;
      font-size: 18px;
      line-height: 20px;
      text-align: center;
      user-select: none;
      background-color: #fff; /* 모든 셀의 기본 배경색을 흰색으로 설정 */
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      box-sizing: border-box; /* 추가: border와 padding을 요소 크기에 포함 */
    }
    /* 조준 경로 하이라이트를 위한 클래스 */
    .aim-path {
      position: relative;
      background-color: rgba(255, 255, 0, 0.2) !important; /* 연한 노란색 배경 */
      font-weight: bold;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
    }
    #status-bar {
      font-size: 16px;
      margin-bottom: 5px;
      padding: 5px;
      background-color: #333;
      border: 1px solid #555;
      text-align: left;
    }
    #message-log {
      height: 80px;
      overflow-y: auto;
      font-size: 14px;
      margin-top: 5px;
      margin-bottom: 10px;
      padding: 5px;
      background-color: #333;
      border: 1px solid #555;
      text-align: left;
    }
    #turn-timer {
      margin-bottom: 10px;
      padding: 5px;
      background-color: #333;
      border: 1px solid #555;
    }
    #turn-timer-bar {
      height: 10px;
      background-color: #444;
    }
    #mobile-controls {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-top: 15px;
      user-select: none;
    }
    .controls-row {
      display: flex;
      justify-content: center;
      margin-bottom: 5px;
    }
    .dir-btn, .action-btn {
      width: 50px;
      height: 50px;
      margin: 0 5px;
      font-size: 24px;
      background-color: #444;
      border: 2px solid #666;
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
    }
    .dir-btn:active, .action-btn:active {
      background-color: #666;
      transform: scale(0.95);
    }
    .action-row {
      margin-top: 10px;
    }
    .action-btn {
      background-color: #553355;
    }
    /* 데스크탑 최적화 */
    @media (min-width: 769px) {
      .cell {
        width: 22px;
        height: 22px;
        font-size: 16px;
        line-height: 1;
      }
    }
    /* 모바일 최적화 */
    @media (max-width: 768px) {
      body {
        padding: 10px 5px;
      }
      .cell {
        width: 18px;
        height: 18px;
        font-size: 16px;
        line-height: 1;
      }
      .dir-btn, .action-btn {
        width: 45px;
        height: 45px;
        margin: 0 3px;
      }
    }
    /* 작은 화면 최적화 */
    @media (max-width: 480px) {
      .cell {
        width: 16px;
        height: 16px;
        font-size: 14px;
        line-height: 1;
      }
      .dir-btn, .action-btn {
        width: 40px;
        height: 40px;
        font-size: 20px;
      }
    }
    .hidden {
      visibility: hidden;
    }
    /* 시야 밖 영역만 검은색으로 설정 */
    .wall { background-color: #fff; } /* 벽도 흰색 배경으로 변경 */
    .floor { background-color: #fff; } /* 바닥 배경색을 흰색으로 유지 */
    .hidden-cell { background-color: #000; } /* 시야 밖 영역은 검은색 */
    .grass { background-color: #fff; } /* 잔디 배경색도 흰색으로 변경 */
    .desert { background-color: #fff; } /* 사막 배경색도 흰색으로 변경 */
    .water { background-color: #fff; } /* 물 배경색도 흰색으로 변경 */
    .mountain { background-color: #fff; } /* 산 배경색도 흰색으로 변경 */
    .lava { background-color: #fff; } /* 화산/용암 배경색도 흰색으로 변경 */
    
    /* 새로운 바이옴 스타일 */
    .forest { background-color: #fff; } /* 숲 배경색 */
    .swamp { background-color: #fff; } /* 늪지대 배경색 */
    .snow { background-color: #fff; } /* 눈 배경색 */
    .ruins { background-color: #fff; } /* 폐허 배경색 */
    .cave { background-color: #fff; } /* 동굴 배경색 */
    .village { background-color: #fff; } /* 마을 배경색 */
    .wasteland { background-color: #fff; } /* 황무지 배경색 */
    .dungeon { background-color: #fff; } /* 던전 배경색 */
    
    /* 맵 선택 UI */
    #map-select-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    
    #map-select-title {
      font-size: 24px;
      margin-bottom: 20px;
      color: #fff;
    }
    
    #map-select-options {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 15px;
      width: 80%;
      max-width: 600px;
    }
    
    .map-option {
      background-color: #333;
      border: 2px solid #555;
      border-radius: 8px;
      padding: 15px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .map-option:hover {
      background-color: #444;
      transform: scale(1.05);
    }
    
    .map-option h3 {
      margin-top: 0;
      color: #fff;
    }
    
    .map-option p {
      color: #ccc;
      font-size: 14px;
    }
    
    .map-option-emoji {
      font-size: 32px;
      margin-bottom: 10px;
    }
  </style>
</head>
<body>
<div id="game-container">
  <div id="status-bar"></div>
  <div id="game-grid"></div>
  <div id="message-log"></div>
  <div id="turn-timer">
    <div id="turn-timer-bar"></div>
  </div>
  <div id="mobile-controls">
    <div class="controls-row">
      <button class="dir-btn" data-dir="6">↖️</button>
      <button class="dir-btn" data-dir="7">⬆️</button>
      <button class="dir-btn" data-dir="8">↗️</button>
    </div>
    <div class="controls-row">
      <button class="dir-btn" data-dir="3">⬅️</button>
      <button class="action-btn" id="aim-btn">🔫</button>
      <button class="dir-btn" data-dir="5">➡️</button>
    </div>
    <div class="controls-row">
      <button class="dir-btn" data-dir="0">↙️</button>
      <button class="dir-btn" data-dir="1">⬇️</button>
      <button class="dir-btn" data-dir="2">↘️</button>
    </div>
    <div class="controls-row action-row">
      <button class="action-btn" id="reload-btn">🔄</button>
      <button class="action-btn" id="run-btn">👟</button>
      <button class="action-btn" id="weapon-btn">🔫⚡</button>
    </div>
  </div>
</div>

<!-- 맵 선택 UI -->
<div id="map-select-container">
  <h2 id="map-select-title">맵 타입 선택</h2>
  <div id="map-select-options">
    <div class="map-option" data-map-type="mixed">
      <div class="map-option-emoji">🌍</div>
      <h3>혼합형</h3>
      <p>다양한 지형과 구조물이 혼합된 균형 잡힌 맵</p>
    </div>
    <div class="map-option" data-map-type="wilderness">
      <div class="map-option-emoji">🌲</div>
      <h3>자연 환경</h3>
      <p>숲, 강, 산 등 자연 지형이 풍부한 맵</p>
    </div>
    <div class="map-option" data-map-type="dungeon">
      <div class="map-option-emoji">🏰</div>
      <h3>던전</h3>
      <p>미로와 통로가 많은 던전 스타일 맵</p>
    </div>
    <div class="map-option" data-map-type="village">
      <div class="map-option-emoji">🏘️</div>
      <h3>마을</h3>
      <p>마을과 건물이 많은 정착지 중심 맵</p>
    </div>
    <div class="map-option" data-map-type="wasteland">
      <div class="map-option-emoji">☢️</div>
      <h3>황무지</h3>
      <p>위험 지역이 많은 황폐한 환경의 맵</p>
    </div>
  </div>
</div>
<script>
// ======= Game configuration (difficulty & settings) =======
const MAP_W = 100;            // Map width
const MAP_H = 100;            // Map height
const VIEW_R = 8;             // Sight radius
const SCREEN_W = 30;          // Displayed area width
const SCREEN_H = 20;          // Displayed area height
const MONSTER_COUNT = 100;     // Number of monsters
const UNICORN_COUNT = 3;     // Number of unicorns
const PLAYER_START_HP = 10;   // Player HP
const PLAYER_AMMO_MAX = 6;    // Gun max ammo
const MONSTER_HP = 5;         // Monster HP (raise for harder game)
const UNICORN_HP = 15;        // Unicorn HP (stronger than normal monsters)
const WALL_RATIO = 0.08;      // Wall generation ratio (0~1)
const GUN_DAMAGE_MIN = 2;     // Gun minimum damage
const GUN_DAMAGE_MAX = 3;     // Gun maximum damage (inclusive)
// ==========================================================

// 조준선 이모티콘 상수
const AIM_EMOJIS = {
  // 수평/수직 방향
  'right': '─',
  'left': '─', 
  'up': '│',
  'down': '│',
  
  // 대각선 방향
  'up-right': '╱',
  'down-right': '╲',
  'down-left': '╱',
  'up-left': '╲'
};

// 조준선 시작/끝 이모티콘
const AIM_START_EMOJI = '🔫';  // 시작점 (총구)
const AIM_END_EMOJI = '⊕';     // 끝점 (십자선)

// 지형 타입 상수
const TERRAIN_TYPES = {
  FLOOR: 'FLOOR',
  WALL: 'WALL',
  GRASS: 'GRASS',
  TREE: 'TREE',
  ROCK: 'ROCK',
  HOUSE: 'HOUSE',
  CASTLE: 'CASTLE',
  CHURCH: 'CHURCH',
  DESERT: 'DESERT',
  WATER: 'WATER',
  MOUNTAIN: 'MOUNTAIN',
  LAVA: 'LAVA',
  // 새로운 바이옴 타입 추가
  FOREST: 'FOREST',
  SWAMP: 'SWAMP',
  SNOW: 'SNOW',
  RUINS: 'RUINS',
  CAVE: 'CAVE',
  VILLAGE: 'VILLAGE',
  WASTELAND: 'WASTELAND',
  DUNGEON: 'DUNGEON'
};

// 몬스터 타입 상수
const MONSTER_TYPES = {
  ZOMBIE: 'ZOMBIE',
  ORC: 'ORC',
  VAMPIRE: 'VAMPIRE',
  FAIRY: 'FAIRY',
  GOBLIN: 'GOBLIN',
  DRAGON: 'DRAGON',
  UNICORN: 'UNICORN' // 유니콘 타입 추가
};

// Map symbols with emoji
const TILES = {
  // 지형 타일 - 색상 기반으로 변경
  FLOOR: { symbol: '.', emoji: '⬜' },  // 기본 바닥은 흰색 사각형
  WALL: { symbol: '#', emoji: '⬛' },   // 벽은 검은색 사각형으로 변경
  GRASS: { symbol: ',', emoji: '⬜' },  // 잔디/들판도 흰색 사각형으로 변경
  TREE: { symbol: 'T', emoji: '🌲' },   // 나무
  ROCK: { symbol: '^', emoji: '🟫' },   // 바위 이모티콘을 갈색 사각형으로 대체
  HOUSE: { symbol: 'H', emoji: '🏠' },  // 집
  CASTLE: { symbol: 'C', emoji: '🏰' },  // 성
  CHURCH: { symbol: 'R', emoji: '⛪' },  // 교회
  DESERT: { symbol: 'D', emoji: '⬜' },  // 사막도 흰색 사각형으로 변경
  WATER: { symbol: 'W', emoji: '⬜' },   // 물도 흰색 사각형으로 변경
  MOUNTAIN: { symbol: 'M', emoji: '⬜' }, // 산도 흰색 사각형으로 변경
  LAVA: { symbol: 'L', emoji: '⬜' },    // 화산/용암도 흰색 사각형으로 변경
  
  // 새로운 바이옴 타일
  FOREST: { symbol: 'F', emoji: '🌳' },  // 숲
  SWAMP: { symbol: 'S', emoji: '🌿' },   // 늪지대
  SNOW: { symbol: 'N', emoji: '❄️' },    // 눈
  RUINS: { symbol: 'U', emoji: '🏚️' },   // 폐허
  CAVE: { symbol: 'V', emoji: '🕳️' },    // 동굴
  VILLAGE: { symbol: 'I', emoji: '🏘️' }, // 마을
  WASTELAND: { symbol: 'A', emoji: '🏜️' }, // 황무지
  DUNGEON: { symbol: 'G', emoji: '🧱' },  // 던전
  
  // 플레이어
  PLAYER: { symbol: '@', emoji: '🤺' },  // 펜싱 선수
  
  // 몬스터 타입
  ZOMBIE: { symbol: 'Z', emoji: '🧟' },   // 좀비
  ORC: { symbol: 'O', emoji: '👹' },      // 오크
  VAMPIRE: { symbol: 'V', emoji: '🧛' },  // 드라큘라/뱀파이어
  FAIRY: { symbol: 'F', emoji: '🧚' },    // 요정
  GOBLIN: { symbol: 'G', emoji: '👺' },   // 고블린
  DRAGON: { symbol: 'D', emoji: '🐉' },   // 드래곤
  UNICORN: { symbol: 'U', emoji: '🦄' },  // 유니콘
  
  // 기타
  MONSTER_DEAD: { symbol: 'M', emoji: '💀' },  // 죽은 몬스터
  BULLET: { symbol: '*', emoji: '💥' },        // 총알 효과
  HIDDEN: { symbol: ' ', emoji: '⬛' }          // 시야 밖은 검은색 사각형
};

// For compatibility with existing code
const FLOOR = '.', WALL = '#', PLAYER = '@', MONSTER = 'M', BULLET = '*';

// Game state
let map = [];
let terrainMap = []; // 지형 정보를 저장하는 배열
let player = {
  x: Math.floor(MAP_W / 2),
  y: Math.floor(MAP_H / 2),
  hp: PLAYER_START_HP,
  ammo: PLAYER_AMMO_MAX,
  aiming: false,
  aimDir: { dx: 0, dy: 0 },
  aimTarget: null,      // 조준 중인 타겟 위치 {x, y}
  aimPath: [],          // 조준 경로 [{x, y}, ...]
  currentWeapon: 'gun'  // 현재 무기 (gun, rocket, laser)
};
let monsters = [];
let msg = [];
let gameOver = false;
let highlightedCells = []; // 하이라이트된 셀 추적
let exploredMap = {}; // 탐사한 지역을 기억하는 객체

// 시야 공유 시스템 관련 변수
let sightGroups = [];  // 시야 공유 그룹 목록
let realTimeTurnActive = false;  // 실시간 턴 시스템 활성화 상태
let currentTurnTime = 0;  // 현재 턴의 시작 시간
let turnDuration = 500;   // 턴 지속 시간 (밀리초)
let playerActedThisTurn = false;  // 현재 턴에 플레이어가 행동했는지 여부

// Directions for keypad (1-9, skip 5)
const DIRS = [
  { dx: -1, dy: 1 }, { dx: 0, dy: 1 }, { dx: 1, dy: 1 },
  { dx: -1, dy: 0 }, { dx: 0, dy: 0 }, { dx: 1, dy: 0 },
  { dx: -1, dy: -1 }, { dx: 0, dy: -1 }, { dx: 1, dy: -1 }
];
// Keypad keycode mapping (numpad and numbers)
const NUM_DIR_KEYS = {
  "97": 0, "98": 1, "99": 2, // Numpad 1,2,3
  "100": 3, "101": 4, "102": 5, // Numpad 4,5,6
  "103": 6, "104": 7, "105": 8, // Numpad 7,8,9
  "49": 0, "50": 1, "51": 2, // 1,2,3
  "52": 3, "53": 4, "54": 5, // 4,5,6
  "55": 6, "56": 7, "57": 8  // 7,8,9
};
function addMsg(s) { 
  msg.unshift(s); 
  if (msg.length > 5) msg.length = 5; 
}

// 통합 맵 생성 함수
function generateIntegratedMap(mapType = 'mixed') {
  // 기본 맵 초기화
  for (let y = 0; y < MAP_H; ++y) {
    map[y] = [];
    terrainMap[y] = [];
    for (let x = 0; x < MAP_W; ++x) {
      if (x === 0 || y === 0 || x === MAP_W - 1 || y === MAP_H - 1) {
        map[y][x] = WALL;
        terrainMap[y][x] = TERRAIN_TYPES.WALL;
      } else {
        // 기본적으로 잔디 지형으로 설정
        map[y][x] = FLOOR;
        terrainMap[y][x] = TERRAIN_TYPES.GRASS;
      }
    }
  }
  
  // 맵 타입에 따라 다른 생성 방식 적용
  switch (mapType) {
    case 'wilderness': // 자연 환경 중심
      generateTerrainWithNoise();
      generateBiomes();
      createForestClusters(5, 10, 15);
      createRockClusters(4, 8, 12);
      placeBuildingRandomly(TERRAIN_TYPES.HOUSE, 3);
      createVillages(1);
      createRandomDangerZones(1);
      break;
      
    case 'dungeon': // 던전 중심
      generateMaze(10, 10, 30, 30);
      generateMaze(60, 60, 30, 30);
      createTunnelSystem(8);
      createRuins(5);
      placeBuildingRandomly(TERRAIN_TYPES.CASTLE, 2);
      createRandomDangerZones(3);
      break;
      
    case 'village': // 마을 중심
      generateTerrainWithNoise();
      createVillages(4);
      placeBuildingRandomly(TERRAIN_TYPES.HOUSE, 10);
      placeBuildingRandomly(TERRAIN_TYPES.CHURCH, 2);
      placeBuildingRandomly(TERRAIN_TYPES.CASTLE, 1);
      createForestClusters(2, 5, 8);
      break;
      
    case 'wasteland': // 황무지 중심
      for (let y = 1; y < MAP_H - 1; y++) {
        for (let x = 1; x < MAP_W - 1; x++) {
          terrainMap[y][x] = TERRAIN_TYPES.WASTELAND;
        }
      }
      createRuins(8);
      createRandomDangerZones(5);
      break;
      
    case 'mixed': // 혼합형 (기본값)
    default:
      // 프랙탈 노이즈로 자연스러운 지형 생성
      generateTerrainWithNoise();
      
      // 바이옴 생성
      generateBiomes();
      
      // 미로 생성 (맵의 특정 영역에 미로 생성)
      generateMaze(10, 10, 20, 20); // 좌상단에 미로 생성
      generateMaze(70, 70, 20, 20); // 우하단에 미로 생성
      
      // 통로 시스템 생성
      createTunnelSystem(5);
      
      // 숲 지역 생성 (나무 클러스터)
      createForestClusters(3, 8, 12);
      
      // 바위 지역 생성
      createRockClusters(2, 6, 8);
      
      // 건물 배치 (집, 성)
      placeBuildingRandomly(TERRAIN_TYPES.HOUSE, 5);
      placeBuildingRandomly(TERRAIN_TYPES.CASTLE, 1);
      placeBuildingRandomly(TERRAIN_TYPES.CHURCH, 3);
      
      // 마을 생성
      createVillages(2);
      
      // 폐허 생성
      createRuins(3);
      
      // 위험 지역 생성
      createRandomDangerZones(2);
      break;
  }
  
  // 벽 추가 (미로 형태) - 모든 맵 타입에 적용
  addMazeWalls(WALL_RATIO);
  
  // 위험 지역 초기화
  dangerZones = [];
}

// Map generation: fantasy world with various terrain types
function genMap() {
  // 통합 맵 생성 함수 호출
  generateIntegratedMap('mixed');
}

// 바이옴 생성 함수
function generateBiomes() {
  // 바이옴 중심점 설정
  const biomes = [
    { type: TERRAIN_TYPES.FOREST, x: Math.floor(Math.random() * MAP_W * 0.4) + MAP_W * 0.1, y: Math.floor(Math.random() * MAP_H * 0.4) + MAP_H * 0.1, radius: 20 },
    { type: TERRAIN_TYPES.DESERT, x: Math.floor(Math.random() * MAP_W * 0.4) + MAP_W * 0.5, y: Math.floor(Math.random() * MAP_H * 0.4) + MAP_H * 0.1, radius: 15 },
    { type: TERRAIN_TYPES.SWAMP, x: Math.floor(Math.random() * MAP_W * 0.4) + MAP_W * 0.1, y: Math.floor(Math.random() * MAP_H * 0.4) + MAP_H * 0.5, radius: 12 },
    { type: TERRAIN_TYPES.SNOW, x: Math.floor(Math.random() * MAP_W * 0.4) + MAP_W * 0.5, y: Math.floor(Math.random() * MAP_H * 0.4) + MAP_H * 0.5, radius: 18 }
  ];
  
  // 각 바이옴 생성
  for (const biome of biomes) {
    createBiome(biome.type, biome.x, biome.y, biome.radius);
  }
}

// 개별 바이옴 생성 함수
function createBiome(biomeType, centerX, centerY, radius) {
  for (let y = Math.max(1, centerY - radius); y < Math.min(MAP_H - 1, centerY + radius); y++) {
    for (let x = Math.max(1, centerX - radius); x < Math.min(MAP_W - 1, centerX + radius); x++) {
      // 중심점으로부터의 거리 계산
      const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
      
      // 거리에 따른 확률로 바이옴 타일 배치
      if (distance <= radius) {
        const probability = 1 - (distance / radius);
        
        if (Math.random() < probability * 0.8) {
          terrainMap[y][x] = biomeType;
          
          // 바이옴별 특수 지형 생성
          if (biomeType === TERRAIN_TYPES.FOREST) {
            // 숲 바이옴에는 나무를 더 많이 배치
            if (Math.random() < 0.2) {
              map[y][x] = WALL;
              terrainMap[y][x] = TERRAIN_TYPES.TREE;
            }
          } else if (biomeType === TERRAIN_TYPES.DESERT) {
            // 사막 바이옴에는 바위를 간헐적으로 배치
            if (Math.random() < 0.05) {
              map[y][x] = WALL;
              terrainMap[y][x] = TERRAIN_TYPES.ROCK;
            }
          } else if (biomeType === TERRAIN_TYPES.SWAMP) {
            // 늪지대 바이옴에는 물을 간헐적으로 배치
            if (Math.random() < 0.15) {
              map[y][x] = WALL;
              terrainMap[y][x] = TERRAIN_TYPES.WATER;
            }
          } else if (biomeType === TERRAIN_TYPES.SNOW) {
            // 눈 바이옴에는 나무를 간헐적으로 배치
            if (Math.random() < 0.08) {
              map[y][x] = WALL;
              terrainMap[y][x] = TERRAIN_TYPES.TREE;
            }
          }
        }
      }
    }
  }
}

// 마을 생성 함수
function createVillages(count) {
  for (let i = 0; i < count; i++) {
    // 마을 중심점 선택
    const centerX = Math.floor(Math.random() * (MAP_W - 30)) + 15;
    const centerY = Math.floor(Math.random() * (MAP_H - 30)) + 15;
    const radius = Math.floor(Math.random() * 5) + 8;
    
    // 마을 영역 설정
    for (let y = Math.max(1, centerY - radius); y < Math.min(MAP_H - 1, centerY + radius); y++) {
      for (let x = Math.max(1, centerX - radius); x < Math.min(MAP_W - 1, centerX + radius); x++) {
        // 중심점으로부터의 거리 계산
        const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
        
        // 마을 영역 내에 있으면 마을 지형으로 설정
        if (distance <= radius) {
          terrainMap[y][x] = TERRAIN_TYPES.VILLAGE;
          
          // 마을 내에 집과 길 배치
          if (Math.random() < 0.2) {
            map[y][x] = WALL;
            terrainMap[y][x] = TERRAIN_TYPES.HOUSE;
          }
        }
      }
    }
    
    // 마을 중앙에 교회 배치
    terrainMap[centerY][centerX] = TERRAIN_TYPES.CHURCH;
    map[centerY][centerX] = WALL;
  }
}

// 폐허 생성 함수
function createRuins(count) {
  for (let i = 0; i < count; i++) {
    // 폐허 중심점 선택
    const centerX = Math.floor(Math.random() * (MAP_W - 20)) + 10;
    const centerY = Math.floor(Math.random() * (MAP_H - 20)) + 10;
    const radius = Math.floor(Math.random() * 4) + 5;
    
    // 폐허 영역 설정
    for (let y = Math.max(1, centerY - radius); y < Math.min(MAP_H - 1, centerY + radius); y++) {
      for (let x = Math.max(1, centerX - radius); x < Math.min(MAP_W - 1, centerX + radius); x++) {
        // 중심점으로부터의 거리 계산
        const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
        
        // 폐허 영역 내에 있으면 폐허 지형으로 설정
        if (distance <= radius) {
          terrainMap[y][x] = TERRAIN_TYPES.RUINS;
          
          // 폐허 내에 벽 잔해 배치
          if (Math.random() < 0.3) {
            map[y][x] = WALL;
          }
        }
      }
    }
  }
}

// 숲 클러스터 생성 함수
function createForestClusters(numClusters, minSize, maxSize) {
  for (let i = 0; i < numClusters; i++) {
    // 클러스터 중심점 선택
    const centerX = Math.floor(Math.random() * (MAP_W - 20)) + 10;
    const centerY = Math.floor(Math.random() * (MAP_H - 20)) + 10;
    
    // 클러스터 크기 결정
    const clusterSize = Math.floor(Math.random() * (maxSize - minSize + 1)) + minSize;
    
    // 나무 배치
    for (let j = 0; j < clusterSize; j++) {
      const offsetX = Math.floor(Math.random() * 15) - 7;
      const offsetY = Math.floor(Math.random() * 15) - 7;
      const x = Math.min(Math.max(centerX + offsetX, 1), MAP_W - 2);
      const y = Math.min(Math.max(centerY + offsetY, 1), MAP_H - 2);
      
      // 20% 확률로 나무를 배치, 나머지는 잔디로 유지
      if (Math.random() < 0.2) {
        map[y][x] = WALL; // 나무는 벽으로 취급 (통과 불가)
        terrainMap[y][x] = TERRAIN_TYPES.TREE;
      }
    }
  }
}

// 바위 클러스터 생성 함수
function createRockClusters(numClusters, minSize, maxSize) {
  for (let i = 0; i < numClusters; i++) {
    // 클러스터 중심점 선택
    const centerX = Math.floor(Math.random() * (MAP_W - 20)) + 10;
    const centerY = Math.floor(Math.random() * (MAP_H - 20)) + 10;
    
    // 클러스터 크기 결정
    const clusterSize = Math.floor(Math.random() * (maxSize - minSize + 1)) + minSize;
    
    // 바위 배치
    for (let j = 0; j < clusterSize; j++) {
      const offsetX = Math.floor(Math.random() * 10) - 5;
      const offsetY = Math.floor(Math.random() * 10) - 5;
      const x = Math.min(Math.max(centerX + offsetX, 1), MAP_W - 2);
      const y = Math.min(Math.max(centerY + offsetY, 1), MAP_H - 2);
      
      map[y][x] = WALL; // 바위는 벽으로 취급 (통과 불가)
      terrainMap[y][x] = TERRAIN_TYPES.ROCK;
    }
  }
}

// 건물 랜덤 배치 함수
function placeBuildingRandomly(buildingType, count) {
  for (let i = 0; i < count; i++) {
    let x, y;
    let placed = false;
    let attempts = 0;
    
    // 적절한 위치 찾기 (최대 100번 시도)
    while (!placed && attempts < 100) {
      x = Math.floor(Math.random() * (MAP_W - 10)) + 5;
      y = Math.floor(Math.random() * (MAP_H - 10)) + 5;
      
      // 주변 공간이 비어있는지 확인
      let isEmpty = true;
      for (let dy = -2; dy <= 2; dy++) {
        for (let dx = -2; dx <= 2; dx++) {
          const nx = x + dx;
          const ny = y + dy;
          if (inMap(nx, ny) && terrainMap[ny][nx] !== TERRAIN_TYPES.GRASS) {
            isEmpty = false;
            break;
          }
        }
        if (!isEmpty) break;
      }
      
      if (isEmpty) {
        map[y][x] = WALL; // 건물은 벽으로 취급 (통과 불가)
        terrainMap[y][x] = buildingType;
        placed = true;
      }
      
      attempts++;
    }
  }
}

// 미로 형태의 벽 추가
function addMazeWalls(ratio) {
  for (let y = 1; y < MAP_H - 1; y++) {
    for (let x = 1; x < MAP_W - 1; x++) {
      // 이미 특별한 지형이 있는 경우 건너뛰기
      if (terrainMap[y][x] !== TERRAIN_TYPES.GRASS) continue;
      
      if (Math.random() < ratio) {
        map[y][x] = WALL;
        terrainMap[y][x] = TERRAIN_TYPES.WALL;
      }
    }
  }
}

// Place player and monsters
function placeEntities() {
  function randPos() {
    let x, y;
    do {
      x = Math.floor(Math.random() * (MAP_W - 2)) + 1;
      y = Math.floor(Math.random() * (MAP_H - 2)) + 1;
    } while (map[y][x] !== FLOOR ||
      (x === player.x && y === player.y) ||
      monsters.some(m => m.x === x && m.y === y));
    return { x, y };
  }
  // Place player
  let p = randPos();
  player.x = p.x; player.y = p.y;
  player.hp = PLAYER_START_HP;
  player.ammo = PLAYER_AMMO_MAX;
  player.aiming = false;
  player.reloading = false;
  
  // Place monsters
  monsters = [];
  for (let i = 0; i < MONSTER_COUNT; ++i) {
    let m = randPos();
    
    // 몬스터 타입 결정
    const monsterRoll = Math.random();
    let monsterType, hp;
    
    if (monsterRoll < 0.3) { // 30% 확률로 좀비
      monsterType = MONSTER_TYPES.ZOMBIE;
      hp = MONSTER_HP;
    } else if (monsterRoll < 0.6) { // 30% 확률로 오크
      monsterType = MONSTER_TYPES.ORC;
      hp = MONSTER_HP + 1;
    } else if (monsterRoll < 0.8) { // 20% 확률로 고블린
      monsterType = MONSTER_TYPES.GOBLIN;
      hp = MONSTER_HP - 2;
    } else if (monsterRoll < 0.9) { // 10% 확률로 뱀파이어
      monsterType = MONSTER_TYPES.VAMPIRE;
      hp = MONSTER_HP + 3;
    } else if (monsterRoll < 0.98) { // 8% 확률로 요정
      monsterType = MONSTER_TYPES.FAIRY;
      hp = MONSTER_HP - 3;
    } else { // 2% 확률로 드래곤
      monsterType = MONSTER_TYPES.DRAGON;
      hp = MONSTER_HP * 3;
    }
    
    monsters.push({ x: m.x, y: m.y, hp: hp, type: monsterType });
  }
  
  // 유니콘 배치 (특별한 몬스터)
  for (let i = 0; i < UNICORN_COUNT; ++i) {
    let m = randPos();
    monsters.push({ 
      x: m.x, 
      y: m.y, 
      hp: UNICORN_HP, 
      type: MONSTER_TYPES.UNICORN,
      isUnicorn: true,  // 유니콘 식별자
      nextMoveTime: 0,  // 다음 행동 시간 (실시간 턴 시스템용)
      lastSeenPlayer: false, // 플레이어를 마지막으로 본 상태
      targetMonster: null // 공격 대상 몬스터
    });
  }
}

// Check if in map
function inMap(x, y) { return x >= 0 && y >= 0 && x < MAP_W && y < MAP_H; }

// Bresenham line for FOV and shooting
function los(x0, y0, x1, y1, fn) {
  let dx = Math.abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
  let dy = -Math.abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
  let err = dx + dy, e2;
  for (; ;) {
    if (fn(x0, y0) === false) return false;
    if (x0 === x1 && y0 === y1) break;
    e2 = 2 * err;
    if (e2 >= dy) { err += dy; x0 += sx; }
    if (e2 <= dx) { err += dx; y0 += sy; }
  }
  return true;
}

// Field of view (returns set of visible positions)
function calcFOV() {
  let vis = {};
  for (let dy = -VIEW_R; dy <= VIEW_R; ++dy)
    for (let dx = -VIEW_R; dx <= VIEW_R; ++dx) {
      let tx = player.x + dx, ty = player.y + dy;
      if (inMap(tx, ty) && Math.sqrt(dx * dx + dy * dy) <= VIEW_R) {
        los(player.x, player.y, tx, ty, (x, y) => {
          vis[`${x},${y}`] = true;
          // 탐사한 지역 기록
          exploredMap[`${x},${y}`] = map[y][x];
          return map[y][x] !== WALL;
        });
      }
    }
  return vis;
}

// 경로 시각화 함수
function calculatePath(startX, startY, endX, endY) {
  let path = [];
  
  // Bresenham 알고리즘으로 경로 계산
  let dx = Math.abs(endX - startX), sx = startX < endX ? 1 : -1;
  let dy = -Math.abs(endY - startY), sy = startY < endY ? 1 : -1;
  let err = dx + dy, e2;
  
  let x = startX, y = startY;
  
  while (true) {
    // 시작점은 경로에 포함하지 않음
    if (!(x === startX && y === startY)) {
      path.push({x, y});
    }
    
    if (x === endX && y === endY) break;
    
    e2 = 2 * err;
    if (e2 >= dy) { err += dy; x += sx; }
    if (e2 <= dx) { err += dx; y += sy; }
    
    // 벽을 만나면 경로 중단
    if (inMap(x, y) && map[y][x] === WALL) break;
  }
  
  return path;
}

// 조준 경로 표시 함수
function showAimPath(startX, startY, endX, endY) {
  // 이전 하이라이트 제거
  clearHighlights();
  
  // 경로 계산
  const path = calculatePath(startX, startY, endX, endY);
  player.aimPath = path;
  
  // 방향 결정
  const dx = Math.sign(endX - startX);
  const dy = Math.sign(endY - startY);
  
  let direction;
  if (dx === 1 && dy === 0) direction = 'right';
  else if (dx === -1 && dy === 0) direction = 'left';
  else if (dx === 0 && dy === -1) direction = 'up';
  else if (dx === 0 && dy === 1) direction = 'down';
  else if (dx === 1 && dy === -1) direction = 'up-right';
  else if (dx === 1 && dy === 1) direction = 'down-right';
  else if (dx === -1 && dy === 1) direction = 'down-left';
  else if (dx === -1 && dy === -1) direction = 'up-left';
  else direction = 'right'; // 기본값
  
  const aimEmoji = AIM_EMOJIS[direction];
  
  // 경로 표시
  path.forEach((pos, index) => {
    const cellIndex = (pos.y - Math.max(0, Math.min(MAP_H - SCREEN_H, player.y - Math.floor(SCREEN_H / 2)))) * SCREEN_W + 
                      (pos.x - Math.max(0, Math.min(MAP_W - SCREEN_W, player.x - Math.floor(SCREEN_W / 2))));
    const cells = document.getElementById('game-grid').children;
    
    if (cellIndex >= 0 && cellIndex < cells.length) {
      const cell = cells[cellIndex];
      
      // CSS 클래스 추가로 하이라이트
      cell.classList.add('aim-path');
      
      // 조준선 이모티콘 표시
      const originalContent = cell.textContent;
      cell.textContent = aimEmoji;
      cell.style.color = '#ffcc00'; // 노란색으로 표시
      
      // 원래 내용 저장 (나중에 복원하기 위해)
      cell.dataset.originalContent = originalContent;
      
      highlightedCells.push(cell);
    }
  });
  
  // 시작점과 끝점 특별 표시
  if (path.length > 0) {
    // 시작점 표시 (첫 번째 경로 지점)
    const startPos = path[0];
    const startCellIndex = (startPos.y - Math.max(0, Math.min(MAP_H - SCREEN_H, player.y - Math.floor(SCREEN_H / 2)))) * SCREEN_W + 
                          (startPos.x - Math.max(0, Math.min(MAP_W - SCREEN_W, player.x - Math.floor(SCREEN_W / 2))));
    const cells = document.getElementById('game-grid').children;
    
    if (startCellIndex >= 0 && startCellIndex < cells.length) {
      const startCell = cells[startCellIndex];
      startCell.textContent = AIM_START_EMOJI;
      startCell.style.color = '#ff0000'; // 빨간색으로 표시
    }
    
    // 끝점 표시 (마지막 경로 지점)
    const endPos = path[path.length - 1];
    const endCellIndex = (endPos.y - Math.max(0, Math.min(MAP_H - SCREEN_H, player.y - Math.floor(SCREEN_H / 2)))) * SCREEN_W + 
                        (endPos.x - Math.max(0, Math.min(MAP_W - SCREEN_W, player.x - Math.floor(SCREEN_W / 2))));
    
    if (endCellIndex >= 0 && endCellIndex < cells.length) {
      const endCell = cells[endCellIndex];
      endCell.textContent = AIM_END_EMOJI;
      endCell.style.color = '#00ff00'; // 녹색으로 표시
    }
  }
}

// 하이라이트 제거 함수
function clearHighlights() {
  highlightedCells.forEach(cell => {
    // CSS 클래스 제거
    cell.classList.remove('aim-path');
    
    // 원래 내용 복원
    if (cell.dataset.originalContent) {
      cell.textContent = cell.dataset.originalContent;
      delete cell.dataset.originalContent;
    }
    
    // 색상 초기화
    cell.style.color = '';
  });
  
  highlightedCells = [];
  player.aimPath = [];
}

// 가장 가까운 몬스터 찾기
function findNearestVisibleMonster() {
  let vis = calcFOV();
  let nearestMonster = null;
  let minDistance = Infinity;
  
  monsters.forEach(m => {
    if (m.hp <= 0) return; // 죽은 몬스터는 제외
    
    // 시야 내에 있는지 확인
    if (vis[`${m.x},${m.y}`]) {
      // 맨해튼 거리 계산
      let distance = Math.abs(m.x - player.x) + Math.abs(m.y - player.y);
      
      // 더 가까운 몬스터 발견 시 업데이트
      if (distance < minDistance) {
        minDistance = distance;
        nearestMonster = m;
      }
    }
  });
  
  return nearestMonster;
}

// 자동 조준 함수
function autoAim() {
  const nearestMonster = findNearestVisibleMonster();
  
  if (nearestMonster) {
    // 몬스터 방향으로 조준 설정
    const dx = Math.sign(nearestMonster.x - player.x);
    const dy = Math.sign(nearestMonster.y - player.y);
    
    player.aimDir = { dx, dy };
    player.aimTarget = { x: nearestMonster.x, y: nearestMonster.y };
    
    // 궤적 표시
    showAimPath(player.x, player.y, nearestMonster.x, nearestMonster.y);
    
    addMsg(`조준: ${nearestMonster.x},${nearestMonster.y}의 몬스터`);
    return true;
  }
  
  addMsg('시야 내에 몬스터가 없습니다.');
  return false; // 시야 내에 몬스터가 없음
}

// Render the game
function render() {
  // 레이저 효과가 진행 중이면 렌더링 건너뛰기
  if (window.laserEffectActive && Date.now() < window.laserEffectActive) {
    console.log("레이저 효과 중 - 렌더링 건너뜀");
    return;
  }
  
  let vis = calcFOV();
  let gameGrid = document.getElementById('game-grid');
  let statusBar = document.getElementById('status-bar');
  let messageLog = document.getElementById('message-log');
  let turnTimer = document.getElementById('turn-timer');
  let turnTimerBar = document.getElementById('turn-timer-bar');
  
  // Clear previous content
  gameGrid.innerHTML = '';
  
  // Set grid template
  gameGrid.style.gridTemplateColumns = `repeat(${SCREEN_W}, 1fr)`;
  
  // Calculate view area
  let sx = Math.max(0, Math.min(MAP_W - SCREEN_W, player.x - Math.floor(SCREEN_W / 2)));
  let sy = Math.max(0, Math.min(MAP_H - SCREEN_H, player.y - Math.floor(SCREEN_H / 2)));
  
  // Create grid cells
  for (let y = sy; y < sy + SCREEN_H; ++y) {
    for (let x = sx; x < sx + SCREEN_W; ++x) {
      let cell = document.createElement('div');
      cell.className = 'cell';
      
      // 타일 좌표 저장 (클릭 이벤트용)
      cell.dataset.x = x;
      cell.dataset.y = y;
      
      // Determine cell content
      let cellType = 'HIDDEN';
      let isExplored = exploredMap[`${x},${y}`] !== undefined;
      
      if (vis[`${x},${y}`]) {
        // 현재 시야 내에 있는 경우
        if (player.x === x && player.y === y) {
          cellType = 'PLAYER';
        } else {
          let m = monsters.find(m => m.x === x && m.y === y);
          if (m) {
            if (m.hp <= 0) {
              cellType = 'MONSTER_DEAD';
            } else {
              cellType = m.type; // 몬스터 타입 사용
              // Add monster HP display
              cell.style.position = 'relative';
              let hpDisplay = document.createElement('div');
              hpDisplay.style.position = 'absolute';
              hpDisplay.style.bottom = '0';
              hpDisplay.style.right = '0';
              hpDisplay.style.fontSize = '8px';
              hpDisplay.style.backgroundColor = 'rgba(0,0,0,0.5)';
              hpDisplay.style.color = '#fff';
              hpDisplay.style.padding = '1px';
              hpDisplay.textContent = m.hp;
              cell.appendChild(hpDisplay);
            }
          } else {
            // 지형 타입에 따라 타일 결정
            if (inMap(x, y) && terrainMap[y] && terrainMap[y][x]) {
              cellType = terrainMap[y][x];
            } else {
              cellType = map[y][x] === WALL ? 'WALL' : 'FLOOR';
            }
          }
        }
      } else if (isExplored) {
        // 시야 밖이지만 이전에 탐사한 지역인 경우
        // 지형 타입에 따라 타일 결정
        if (inMap(x, y) && terrainMap[y] && terrainMap[y][x]) {
          cellType = terrainMap[y][x];
        } else {
          cellType = exploredMap[`${x},${y}`] === WALL ? 'WALL' : 'FLOOR';
        }
        
        // 어두운 반투명 효과 적용
        cell.style.filter = 'brightness(0.5)';
        cell.style.opacity = '0.7';
      } else {
        // 시야 밖이고 탐사하지 않은 지역은 검은색으로 표시
        cell.classList.add('hidden-cell');
      }
      
      // Add appropriate CSS class
      if (cellType === 'WALL' || cellType === TERRAIN_TYPES.TREE || 
          cellType === TERRAIN_TYPES.ROCK || cellType === TERRAIN_TYPES.CASTLE || 
          cellType === TERRAIN_TYPES.HOUSE || cellType === TERRAIN_TYPES.CHURCH) {
        cell.classList.add('wall');
      } else if (cellType === 'FLOOR' || cellType === TERRAIN_TYPES.GRASS) {
        cell.classList.add('floor');
      } else if (cellType === TERRAIN_TYPES.DESERT) {
        cell.classList.add('desert');
      } else if (cellType === TERRAIN_TYPES.WATER) {
        cell.classList.add('water');
      } else if (cellType === TERRAIN_TYPES.MOUNTAIN) {
        cell.classList.add('mountain');
      } else if (cellType === TERRAIN_TYPES.LAVA) {
        cell.classList.add('lava');
      } else if (cellType === TERRAIN_TYPES.FOREST) {
        cell.classList.add('forest');
      } else if (cellType === TERRAIN_TYPES.SWAMP) {
        cell.classList.add('swamp');
      } else if (cellType === TERRAIN_TYPES.SNOW) {
        cell.classList.add('snow');
      } else if (cellType === TERRAIN_TYPES.RUINS) {
        cell.classList.add('ruins');
      } else if (cellType === TERRAIN_TYPES.CAVE) {
        cell.classList.add('cave');
      } else if (cellType === TERRAIN_TYPES.VILLAGE) {
        cell.classList.add('village');
      } else if (cellType === TERRAIN_TYPES.WASTELAND) {
        cell.classList.add('wasteland');
      } else if (cellType === TERRAIN_TYPES.DUNGEON) {
        cell.classList.add('dungeon');
      }
      
      // Set emoji content
      cell.textContent = TILES[cellType] ? TILES[cellType].emoji : TILES['FLOOR'].emoji;
      
      // 조준 모드일 때 클릭 이벤트 추가
      if (player.aiming && vis[`${x},${y}`]) {
        cell.style.cursor = 'crosshair';
        
        // 클릭 이벤트 리스너 추가
        cell.addEventListener('click', function() {
          const targetX = parseInt(this.dataset.x);
          const targetY = parseInt(this.dataset.y);
          
          // 벽이나 플레이어 위치는 조준 불가
          if (map[targetY][targetX] === WALL || (targetX === player.x && targetY === player.y)) {
            addMsg('유효하지 않은 조준 위치입니다.');
            return;
          }
          
          // 조준 방향 설정
          const dx = Math.sign(targetX - player.x);
          const dy = Math.sign(targetY - player.y);
          
          player.aimDir = { dx, dy };
          player.aimTarget = { x: targetX, y: targetY };
          
          // 궤적 표시
          showAimPath(player.x, player.y, targetX, targetY);
          
          addMsg(`조준: ${targetX},${targetY} 위치`);
        });
      }
      
      // Add to grid
      gameGrid.appendChild(cell);
    }
  }
  
  // Update status bar
  let statusText = `HP: ${player.hp} | Ammo: ${player.ammo} | 무기: ${getWeaponEmoji(player.currentWeapon)} ${getWeaponName(player.currentWeapon)} | 몬스터: ${monsters.filter(m => m.hp > 0).length}`;
  
  // 실시간 턴 시스템 상태 표시
  if (realTimeTurnActive) {
    statusText += ' | 실시간 턴 활성화!';
  }
  
  statusBar.innerHTML = statusText;
  
  // Update turn timer display
  if (realTimeTurnActive) {
    turnTimer.style.display = 'block';
    const now = Date.now();
    const elapsed = now - currentTurnTime;
    const remaining = Math.max(0, turnDuration - elapsed);
    const percent = (remaining / turnDuration) * 100;
    
    turnTimerBar.style.width = `${percent}%`;
    
    // 남은 시간에 따라 색상 변경
    if (percent > 60) {
      turnTimerBar.style.backgroundColor = '#0f0'; // 녹색
    } else if (percent > 30) {
      turnTimerBar.style.backgroundColor = '#ff0'; // 노란색
    } else {
      turnTimerBar.style.backgroundColor = '#f00'; // 빨간색
    }
  } else {
    turnTimer.style.display = 'none';
  }
  
  // Update message log
  messageLog.innerHTML = '';
  if (player.aiming) {
    let aimingMsg = document.createElement('div');
    aimingMsg.textContent = '조준 중: 방향키로 방향 선택 또는 타일 클릭, 다시 🔫 버튼을 눌러 발사';
    aimingMsg.style.color = '#ffcc00';
    messageLog.appendChild(aimingMsg);
    
    // 무기별 힌트 표시
    let weaponHint = document.createElement('div');
    switch(player.currentWeapon) {
      case 'gun':
        weaponHint.textContent = '권총: 단일 대상에게 중간 데미지';
        break;
      case 'rocket':
        weaponHint.textContent = '로켓: 폭발로 주변 몬스터에게도 데미지';
        break;
      case 'laser':
        weaponHint.textContent = '레이저: 여러 몬스터를 관통하는 빔';
        break;
    }
    weaponHint.style.color = '#aaffaa';
    messageLog.appendChild(weaponHint);
    
    // 무기 전환 힌트
    let switchHint = document.createElement('div');
    switchHint.textContent = '무기 전환: 키보드 1-3 또는 🎒 버튼';
    switchHint.style.color = '#aaaaff';
    messageLog.appendChild(switchHint);
  } else {
    let controlMsg = document.createElement('div');
    controlMsg.textContent = '이동: 방향키 | 🔫: 조준/발사 | 🔄: 재장전 | 🎒: 무기 전환';
    messageLog.appendChild(controlMsg);
  }
  
  // Add game messages
  msg.forEach(m => {
    let msgElement = document.createElement('div');
    msgElement.textContent = m;
    messageLog.appendChild(msgElement);
  });
  
  // Game over message
  if (gameOver) {
    let gameOverMsg = document.createElement('div');
    gameOverMsg.textContent = '게임 오버! 새로고침하여 다시 시작';
    gameOverMsg.style.color = 'red';
    gameOverMsg.style.fontWeight = 'bold';
    messageLog.appendChild(gameOverMsg);
  }
  
  // 조준 경로 다시 표시 (렌더링 후)
  if (player.aiming && player.aimTarget) {
    showAimPath(player.x, player.y, player.aimTarget.x, player.aimTarget.y);
  }
}

// 무기 이름 반환 함수
function getWeaponName(weaponType) {
  switch(weaponType) {
    case 'gun': return '권총';
    case 'rocket': return '로켓';
    case 'laser': return '레이저';
    default: return '권총';
  }
}

// 무기 이모지 반환 함수
function getWeaponEmoji(weaponType) {
  switch(weaponType) {
    case 'gun': return '🔫';
    case 'rocket': return '🚀';
    case 'laser': return '⚡';
    default: return '🔫';
  }
}

// Move player
function tryMove(dx, dy) {
  let nx = player.x + dx, ny = player.y + dy;
  if (!inMap(nx, ny)) return false;
  if (map[ny][nx] === WALL) return false;
  let m = monsters.find(m => m.x === nx && m.y === ny && m.hp > 0);
  if (m) {
    m.hp -= 2 + Math.floor(Math.random() * 2); // melee attack
    addMsg('You punch the monster!');
    if (m.hp <= 0) addMsg('Monster dies!');
    
    // 실시간 턴 시스템에서 플레이어 행동 처리
    if (realTimeTurnActive) {
      playerActedThisTurn = true;
    }
  } else {
    player.x = nx; player.y = ny;
    
    // 실시간 턴 시스템에서 플레이어 행동 처리
    if (realTimeTurnActive) {
      playerActedThisTurn = true;
    }
  }
  
  // 이동 후 시야 공유 상태 업데이트
  updateSightGroups();
  
  return true;
}

// Monster AI: very simple, move toward player if in FOV, else random walk
function monsterTurn() {
  let vis = calcFOV();
  monsters.forEach(m => {
    // 유니콘은 플레이어 시야에 있을 때만 일반 턴에서 제외
    const isUnicornInRealTimeTurn = m.isUnicorn && vis[`${m.x},${m.y}`] && realTimeTurnActive;
    
    if (isUnicornInRealTimeTurn) return;
    
    if (m.hp <= 0) return;
    let dx = player.x - m.x, dy = player.y - m.y;
    let dist = Math.max(Math.abs(dx), Math.abs(dy));
    if (dist === 1) { // adjacent, attack
      // 유니콘은 플레이어를 공격하지 않음
      if (m.isUnicorn) return;
      
      player.hp -= 2;
      addMsg('Monster hits you!');
      if (player.hp <= 0) { gameOver = true; addMsg('You died!'); }
      return;
    }
    if (vis[`${m.x},${m.y}`]) {
      // Move closer
      let mx = dx ? dx / Math.abs(dx) : 0, my = dy ? dy / Math.abs(dy) : 0;
      let nx = m.x + mx, ny = m.y + my;
      
      // 유니콘은 플레이어를 향해 이동하지 않고, 다른 몬스터를 향해 이동
      if (m.isUnicorn) {
        // 유니콘의 시야 내 가장 가까운 몬스터 찾기
        const unicornFOV = calcMonsterFOV(m);
        let nearestMonster = null;
        let minDistance = Infinity;
        
        monsters.forEach(target => {
          // 자기 자신이거나 유니콘이거나 이미 죽은 몬스터는 제외
          if (target === m || target.isUnicorn || target.hp <= 0) return;
          
          // 시야 내에 있는지 확인
          if (unicornFOV[`${target.x},${target.y}`]) {
            // 거리 계산
            const distance = Math.abs(target.x - m.x) + Math.abs(target.y - m.y);
            
            // 더 가까운 몬스터 발견 시 업데이트
            if (distance < minDistance) {
              minDistance = distance;
              nearestMonster = target;
            }
          }
        });
        
        // 가까운 몬스터가 있으면 그 방향으로 이동 또는 공격
        if (nearestMonster) {
          const mdx = Math.sign(nearestMonster.x - m.x);
          const mdy = Math.sign(nearestMonster.y - m.y);
          const mdist = Math.max(Math.abs(nearestMonster.x - m.x), Math.abs(nearestMonster.y - m.y));
          
          if (mdist <= 1) {
            // 몬스터와 인접해 있으면 공격
            nearestMonster.hp -= 4; // 유니콘은 강한 공격력
            addMsg('유니콘이 몬스터를 공격했습니다!');
            
            if (nearestMonster.hp <= 0) {
              addMsg('유니콘이 몬스터를 처치했습니다!');
            }
          } else {
            // 몬스터 방향으로 이동 시도
            const nx = m.x + mdx;
            const ny = m.y + mdy;
            
            if (inMap(nx, ny) && map[ny][nx] !== WALL && 
                !monsters.some(mm => mm !== m && mm.x === nx && mm.y === ny && mm.hp > 0)) {
              m.x = nx;
              m.y = ny;
            }
          }
        } else {
          // 몬스터가 없으면 랜덤 이동
          let d = DIRS[Math.floor(Math.random() * 8)];
          let nx = m.x + d.dx, ny = m.y + d.dy;
          if (inMap(nx, ny) && map[ny][nx] !== WALL && 
              !monsters.some(mm => mm !== m && mm.x === nx && mm.y === ny && mm.hp > 0) && 
              (player.x !== nx || player.y !== ny)) {
            m.x = nx;
            m.y = ny;
          }
        }
      } else {
        // 일반 몬스터는 플레이어를 향해 이동
        if (inMap(nx, ny) && map[ny][nx] !== WALL && 
            !monsters.some(mm => mm !== m && mm.x === nx && mm.y === ny && mm.hp > 0) && 
            (player.x !== nx || player.y !== ny)) {
          m.x = nx;
          m.y = ny;
        }
      }
    } else {
      // Random move
      let d = DIRS[Math.floor(Math.random() * 8)];
      let nx = m.x + d.dx, ny = m.y + d.dy;
      if (inMap(nx, ny) && map[ny][nx] !== WALL && 
          !monsters.some(mm => mm !== m && mm.x === nx && mm.y === ny && mm.hp > 0) && 
          (player.x !== nx || player.y !== ny)) {
        m.x = nx;
        m.y = ny;
      }
    }
  });
  
  // 몬스터 턴 후 시야 공유 상태 업데이트
  updateSightGroups();
  
  // 위험 지역 업데이트
  updateDangerZones();
  
  // 랜덤하게 새로운 위험 지역 생성 (0.5% 확률)
  if (Math.random() < 0.005) {
    createRandomDangerZones(1);
    addMsg('새로운 위험 지역이 발생했습니다!');
  }
}

// Reload (now takes a real turn)
function doReload() {
  if (player.ammo === PLAYER_AMMO_MAX) { addMsg('이미 장전되어 있습니다.'); render(); return; }
  player.ammo = PLAYER_AMMO_MAX;
  addMsg('재장전 완료!');
  monsterTurn(); // Monsters act immediately (reload is a turn)
  render();
}

// Keyboard input
document.addEventListener('keydown', function (e) {
  if (gameOver) return;
  
  // 조준 모드일 때
  if (player.aiming) {
    // ESC: 조준 취소
    if (e.key === 'Escape') { 
      player.aiming = false; 
      player.aimTarget = null;
      clearHighlights();
      render(); 
      return; 
    }
    
    // 방향키로 조준 방향 설정
    let d = NUM_DIR_KEYS[e.keyCode];
    if (d !== undefined && d !== 4) {
      player.aimDir = DIRS[d];
      
      // 해당 방향으로 조준 경로 표시
      const targetX = player.x + player.aimDir.dx * 10; // 충분히 먼 거리
      const targetY = player.y + player.aimDir.dy * 10;
      player.aimTarget = { x: targetX, y: targetY };
      
      showAimPath(player.x, player.y, targetX, targetY);
      render();
      return;
    }
    
    // F: 발사
    if (e.key === 'f' || e.key === 'F') {
      if (player.aimTarget) {
        // 조준된 타겟으로 발사
        console.log("키보드: 조준 타겟으로 발사", player.aimTarget);
        
        fireWeapon(player.aimDir.dx, player.aimDir.dy);
        player.aiming = false;
        player.aimTarget = null;
        clearHighlights();
        monsterTurn();
        render();
      } else {
        addMsg('방향키로 방향을 선택하거나 타일을 클릭하세요!');
      }
      return;
    }
    
    // 숫자키 1-3: 무기 전환
    if (e.key === '1' || e.key === '2' || e.key === '3') {
      const weaponIndex = parseInt(e.key) - 1;
      const weapons = ['gun', 'rocket', 'laser'];
      if (weaponIndex >= 0 && weaponIndex < weapons.length) {
        player.currentWeapon = weapons[weaponIndex];
        addMsg(`무기 전환: ${getWeaponName(player.currentWeapon)}`);
        updateWeaponButton();
        render();
      }
      return;
    }
    
    return;
  }
  
  // 조준 모드가 아닐 때
  
  // F: 조준 모드 시작
  if (e.key === 'f' || e.key === 'F') {
    player.aiming = true; 
    player.aimDir = { dx: 0, dy: 0 };
    
    // 자동 조준 시도
    autoAim();
    
    render(); 
    return;
  }
  
  // R: 재장전
  if (e.key === 'r' || e.key === 'R') { 
    doReload(); 
    return; 
  }
  
  // 숫자키 1-3: 무기 전환
  if (e.key === '1' || e.key === '2' || e.key === '3') {
    const weaponIndex = parseInt(e.key) - 1;
    const weapons = ['gun', 'rocket', 'laser'];
    if (weaponIndex >= 0 && weaponIndex < weapons.length) {
      player.currentWeapon = weapons[weaponIndex];
      addMsg(`무기 전환: ${getWeaponName(player.currentWeapon)}`);
      updateWeaponButton();
      render();
    }
    return;
  }
  
  // 방향키: 이동
  let d = NUM_DIR_KEYS[e.keyCode];
  if (d !== undefined && d !== 4) {
    tryMove(DIRS[d].dx, DIRS[d].dy);
    monsterTurn();
    render();
    return;
  }
});
function init() {
  console.log("게임 초기화 함수 시작");
  
  // 맵 선택 UI 표시
  showMapSelectionUI();
  
  console.log("게임 초기화 완료");
}

// 맵 선택 UI 표시 함수
function showMapSelectionUI() {
  const mapSelectContainer = document.getElementById('map-select-container');
  const mapOptions = document.querySelectorAll('.map-option');
  
  // 맵 선택 UI 표시
  mapSelectContainer.style.display = 'flex';
  
  // 맵 옵션 클릭 이벤트 설정
  mapOptions.forEach(option => {
    option.addEventListener('click', function() {
      const mapType = this.getAttribute('data-map-type');
      
      // 선택한 맵 타입으로 게임 시작
      startGameWithMapType(mapType);
      
      // 맵 선택 UI 숨김
      mapSelectContainer.style.display = 'none';
    });
  });
}

// 선택한 맵 타입으로 게임 시작
function startGameWithMapType(mapType) {
  console.log(`맵 타입 '${mapType}'으로 게임 시작`);
  
  // 맵 생성
  generateIntegratedMap(mapType);
  
  // 엔티티 배치
  placeEntities();
  
  // 메시지 초기화
  msg = ['Welcome to Doom Emoji RL!', `${getMapTypeName(mapType)} 맵에서 게임을 시작합니다!`];
  
  // 모바일 컨트롤 이벤트 설정
  setupMobileControls();
  
  // 무기 버튼 초기화
  updateWeaponButton();
  
  // 시야 공유 상태 초기화
  updateSightGroups();
  
  // 게임 루프 시작
  startGameLoop();
  
  // 초기 게임 상태 렌더링
  render();
}

// 맵 타입 이름 반환 함수
function getMapTypeName(mapType) {
  switch (mapType) {
    case 'mixed': return '혼합형';
    case 'wilderness': return '자연 환경';
    case 'dungeon': return '던전';
    case 'village': return '마을';
    case 'wasteland': return '황무지';
    default: return '혼합형';
  }
}

// 모바일 컨트롤 설정
function setupMobileControls() {
  // 모바일 터치 이벤트 최적화
  document.addEventListener('touchstart', function(e) {
    if (e.target.tagName === 'BUTTON') {
      e.preventDefault(); // 기본 터치 동작 방지
    }
  }, { passive: false });
  
  // 더블 탭 줌 방지
  document.addEventListener('dblclick', function(e) {
    e.preventDefault();
  });

  // 방향 버튼 이벤트
  const dirButtons = document.querySelectorAll('.dir-btn');
  dirButtons.forEach(btn => {
    // 클릭 이벤트와 터치 이벤트 모두 처리
    ['click', 'touchstart'].forEach(eventType => {
      btn.addEventListener(eventType, function(e) {
        if (eventType === 'touchstart') e.preventDefault();
        if (gameOver) return;
        
        const dirIndex = parseInt(this.getAttribute('data-dir'));
        if (player.aiming) {
          // 조준 중일 때는 조준 방향 설정
          player.aimDir = DIRS[dirIndex];
          
          // 해당 방향으로 조준 경로 표시
          const targetX = player.x + player.aimDir.dx * 10; // 충분히 먼 거리
          const targetY = player.y + player.aimDir.dy * 10;
          player.aimTarget = { x: targetX, y: targetY };
          
          showAimPath(player.x, player.y, targetX, targetY);
          render();
        } else {
          // 일반 이동
          tryMove(DIRS[dirIndex].dx, DIRS[dirIndex].dy);
          monsterTurn();
          render();
        }
      });
    });
  });
  
  // 조준/발사 버튼
  const aimBtn = document.getElementById('aim-btn');
  ['click', 'touchstart'].forEach(eventType => {
    aimBtn.addEventListener(eventType, function(e) {
      if (eventType === 'touchstart') e.preventDefault();
      if (gameOver) return;
      
      if (player.aiming) {
        // 이미 조준 중이면 발사
        if (player.aimTarget) {
          // 조준된 타겟으로 발사
          console.log("조준 타겟으로 발사:", player.aimTarget);
          
          // 현재 무기에 따라 다른 발사 효과 사용
          fireWeapon(player.aimDir.dx, player.aimDir.dy);
          player.aiming = false;
          player.aimTarget = null;
          clearHighlights();
          monsterTurn();
          render();
        } else {
          addMsg('방향키로 방향을 선택하거나 타일을 클릭하세요!');
        }
      } else {
        // 조준 모드 시작 및 자동 조준 시도
        player.aiming = true;
        player.aimDir = { dx: 0, dy: 0 };
        
        // 자동 조준 시도
        autoAim();
        
        render();
      }
    });
  });
  
  // 재장전 버튼
  const reloadBtn = document.getElementById('reload-btn');
  ['click', 'touchstart'].forEach(eventType => {
    reloadBtn.addEventListener(eventType, function(e) {
      if (eventType === 'touchstart') e.preventDefault();
      if (gameOver) return;
      doReload();
    });
  });
  
  // 달리기 버튼 (2칸 이동)
  const runBtn = document.getElementById('run-btn');
  ['click', 'touchstart'].forEach(eventType => {
    runBtn.addEventListener(eventType, function(e) {
      if (eventType === 'touchstart') e.preventDefault();
      if (gameOver || player.aiming) return;
      
      addMsg('Run mode: Choose direction');
      // 다음 방향키 입력을 기다렸다가 2칸 이동
      const runHandler = function(e) {
        if (e.target.classList.contains('dir-btn')) {
          const dirIndex = parseInt(e.target.getAttribute('data-dir'));
          const dir = DIRS[dirIndex];
          
          // 첫 번째 칸 이동
          if (tryMove(dir.dx, dir.dy)) {
            // 두 번째 칸 이동 시도
            tryMove(dir.dx, dir.dy);
          }
          
          monsterTurn();
          render();
          
          // 이벤트 리스너 제거
          document.getElementById('mobile-controls').removeEventListener('click', runHandler);
          document.getElementById('mobile-controls').removeEventListener('touchstart', runHandler);
        }
      };
      
      document.getElementById('mobile-controls').addEventListener('click', runHandler);
      document.getElementById('mobile-controls').addEventListener('touchstart', runHandler);
    });
  });
  
  // 인벤토리 버튼 (무기 전환으로 변경)
  const inventoryBtn = document.getElementById('weapon-btn');
  ['click', 'touchstart'].forEach(eventType => {
    inventoryBtn.addEventListener(eventType, function(e) {
      if (eventType === 'touchstart') e.preventDefault();
      if (gameOver) return;
      
      // 무기 전환
      switchWeapon();
      render();
    });
  });
  
  // 모든 환경에서 컨트롤 패널 표시
  document.getElementById('mobile-controls').style.display = 'flex';
}

// 무기 전환 버튼 업데이트 함수
function updateWeaponButton() {
  const weaponBtn = document.getElementById('weapon-btn');
  if (weaponBtn) {
    // 현재 무기에 따라 다음 무기 아이콘 표시
    switch(player.currentWeapon) {
      case 'gun':
        weaponBtn.innerHTML = '🚀'; // 다음 무기는 로켓
        break;
      case 'rocket':
        weaponBtn.innerHTML = '⚡'; // 다음 무기는 레이저
        break;
      case 'laser':
        weaponBtn.innerHTML = '🔫'; // 다음 무기는 권총
        break;
    }
  }
}

// 무기 전환 함수
function switchWeapon() {
  const weapons = ['gun', 'rocket', 'laser'];
  const currentIndex = weapons.indexOf(player.currentWeapon);
  const nextIndex = (currentIndex + 1) % weapons.length;
  player.currentWeapon = weapons[nextIndex];
  addMsg(`무기 전환: ${getWeaponName(player.currentWeapon)}`);
  
  // 무기 전환 버튼 업데이트
  updateWeaponButton();
}

// 무기별 발사 함수
function fireWeapon(dx, dy) {
  if (player.ammo <= 0) { 
    addMsg('탄약이 없습니다! R키나 🔄 버튼으로 재장전하세요.'); 
    return; 
  }
  
  // 조준 타겟이 있는 경우, 정확한 타겟 좌표를 사용
  if (player.aimTarget) {
    // 타겟까지의 경로 계산
    const path = calculatePath(player.x, player.y, player.aimTarget.x, player.aimTarget.y);
    
    console.log("발사 경로:", path);
    addMsg(`발사: ${player.aimTarget.x},${player.aimTarget.y} 방향`);
    
    switch(player.currentWeapon) {
      case 'gun':
        fireGunWithPath(path);
        break;
      case 'rocket':
        fireRocketWithPath(path);
        break;
      case 'laser':
        fireLaserWithPath(path);
        break;
      default:
        fireGunWithPath(path);
    }
  } else {
    // 기존 방식 - 방향만 사용
    switch(player.currentWeapon) {
      case 'gun':
        fireGun(dx, dy);
        break;
      case 'rocket':
        fireRocket(dx, dy);
        break;
      case 'laser':
        fireLaser(dx, dy);
        break;
      default:
        fireGun(dx, dy);
    }
  }
  
  player.ammo--;
}

// 일반 총 발사 (궤적 표시)
function fireGun(dx, dy) {
  let x = player.x, y = player.y;
  let hit = false;
  
  // 경로 계산
  const path = [];
  for (let i = 0; i < MAP_W; ++i) {
    x += dx; y += dy;
    if (!inMap(x, y) || map[y][x] === WALL) break;
    path.push({x, y});
    
    let m = monsters.find(m => m.x === x && m.y === y && m.hp > 0);
    if (m) {
      let dmg = GUN_DAMAGE_MIN + Math.floor(Math.random() * (GUN_DAMAGE_MAX - GUN_DAMAGE_MIN + 1));
      m.hp -= dmg;
      addMsg(`몬스터를 총으로 쏩니다! (${dmg} 데미지)`);
      if (m.hp <= 0) addMsg('몬스터가 쓰러집니다!');
      hit = true;
      break;
    }
  }
  
  if (!hit) addMsg('총알이 어둠 속으로 사라집니다.');
  
  // 총알 궤적 표시
  showBulletTrail(path);
}

// 경로 기반 권총 발사 함수
function fireGunWithPath(path) {
  let hit = false;
  
  // 경로를 따라 몬스터 확인
  for (let i = 0; i < path.length; i++) {
    const pos = path[i];
    
    // 벽을 만나면 중단
    if (map[pos.y][pos.x] === WALL) {
      // 벽에 부딪힌 지점까지의 경로만 사용
      path = path.slice(0, i);
      break;
    }
    
    // 몬스터를 만나면 데미지 적용
    let m = monsters.find(m => m.x === pos.x && m.y === pos.y && m.hp > 0);
    if (m) {
      let dmg = GUN_DAMAGE_MIN + Math.floor(Math.random() * (GUN_DAMAGE_MAX - GUN_DAMAGE_MIN + 1));
      m.hp -= dmg;
      addMsg(`몬스터를 총으로 쏩니다! (${dmg} 데미지)`);
      if (m.hp <= 0) addMsg('몬스터가 쓰러집니다!');
      hit = true;
      
      // 몬스터에 맞은 지점까지의 경로만 사용
      path = path.slice(0, i + 1);
      break;
    }
  }
  
  if (!hit) addMsg('총알이 어둠 속으로 사라집니다.');
  
  // 총알 궤적 표시
  showBulletTrail(path);
}

// 로켓 발사 (애니메이션 효과)
function fireRocket(dx, dy) {
  let x = player.x, y = player.y;
  let hit = false;
  
  // 경로 계산
  const path = [];
  for (let i = 0; i < MAP_W; ++i) {
    x += dx; y += dy;
    if (!inMap(x, y) || map[y][x] === WALL) break;
    path.push({x, y});
    
    let m = monsters.find(m => m.x === x && m.y === y && m.hp > 0);
    if (m) {
      let dmg = 5 + Math.floor(Math.random() * 3); // 로켓은 더 강력함
      m.hp -= dmg;
      addMsg(`로켓이 몬스터에게 명중! (${dmg} 데미지)`);
      if (m.hp <= 0) addMsg('몬스터가 폭발과 함께 쓰러집니다!');
      hit = true;
      
      // 주변 몬스터에게 피해 (폭발 효과)
      monsters.forEach(nearby => {
        if (nearby !== m && nearby.hp > 0) {
          const distance = Math.abs(nearby.x - m.x) + Math.abs(nearby.y - m.y);
          if (distance <= 2) {
            nearby.hp -= Math.max(1, 3 - distance);
            if (nearby.hp <= 0) addMsg('주변 몬스터도 폭발에 휘말려 쓰러집니다!');
          }
        }
      });
      
      break;
    }
  }
  
  if (!hit) addMsg('로켓이 날아가 폭발합니다.');
  
  // 로켓 애니메이션 표시
  animateRocket(path);
}

// 경로 기반 로켓 발사 함수
function fireRocketWithPath(path) {
  let hit = false;
  let hitPos = null;
  
  // 경로를 따라 몬스터 확인
  for (let i = 0; i < path.length; i++) {
    const pos = path[i];
    
    // 벽을 만나면 중단
    if (map[pos.y][pos.x] === WALL) {
      // 벽에 부딪힌 지점까지의 경로만 사용
      path = path.slice(0, i);
      break;
    }
    
    // 몬스터를 만나면 데미지 적용
    let m = monsters.find(m => m.x === pos.x && m.y === pos.y && m.hp > 0);
    if (m) {
      let dmg = 5 + Math.floor(Math.random() * 3); // 로켓은 더 강력함
      m.hp -= dmg;
      addMsg(`로켓이 몬스터에게 명중! (${dmg} 데미지)`);
      if (m.hp <= 0) addMsg('몬스터가 폭발과 함께 쓰러집니다!');
      hit = true;
      hitPos = pos;
      
      // 주변 몬스터에게 피해 (폭발 효과)
      monsters.forEach(nearby => {
        if (nearby !== m && nearby.hp > 0) {
          const distance = Math.abs(nearby.x - pos.x) + Math.abs(nearby.y - pos.y);
          if (distance <= 2) {
            nearby.hp -= Math.max(1, 3 - distance);
            if (nearby.hp <= 0) addMsg('주변 몬스터도 폭발에 휘말려 쓰러집니다!');
          }
        }
      });
      
      // 몬스터에 맞은 지점까지의 경로만 사용
      path = path.slice(0, i + 1);
      break;
    }
  }
  
  if (!hit) {
    addMsg('로켓이 날아가 폭발합니다.');
    // 경로 끝에서 폭발 효과 (마지막 위치 주변 몬스터에게 피해)
    if (path.length > 0) {
      const lastPos = path[path.length - 1];
      monsters.forEach(nearby => {
        if (nearby.hp > 0) {
          const distance = Math.abs(nearby.x - lastPos.x) + Math.abs(nearby.y - lastPos.y);
          if (distance <= 1) { // 폭발 범위 축소
            nearby.hp -= 2;
            addMsg('폭발이 몬스터에게 피해를 입힙니다!');
            if (nearby.hp <= 0) addMsg('몬스터가 쓰러집니다!');
          }
        }
      });
    }
  }
  
  // 로켓 애니메이션 표시
  animateRocket(path);
}

// 레이저 발사 (광선 효과)
function fireLaser(dx, dy) {
  let x = player.x, y = player.y;
  let hit = false;
  
  // 경로 계산
  const path = [];
  for (let i = 0; i < MAP_W; ++i) {
    x += dx; y += dy;
    if (!inMap(x, y) || map[y][x] === WALL) break;
    path.push({x, y});
    
    let m = monsters.find(m => m.x === x && m.y === y && m.hp > 0);
    if (m) {
      let dmg = 3; // 레이저는 고정 데미지
      m.hp -= dmg;
      addMsg(`레이저가 몬스터를 관통합니다! (${dmg} 데미지)`);
      if (m.hp <= 0) addMsg('몬스터가 쓰러집니다!');
      hit = true;
      // 레이저는 관통함 (break 하지 않음)
    }
  }
  
  if (!hit) addMsg('레이저가 허공을 가립니다.');
  
  // 레이저 광선 효과 표시
  showLaserBeam(path);
}

// 경로 기반 레이저 발사 함수
function fireLaserWithPath(path) {
  let hit = false;
  
  // 벽을 만나는 지점 찾기
  let wallIndex = -1;
  for (let i = 0; i < path.length; i++) {
    const pos = path[i];
    if (map[pos.y][pos.x] === WALL) {
      wallIndex = i;
      break;
    }
  }
  
  // 벽이 있으면 해당 지점까지만 경로 사용
  if (wallIndex !== -1) {
    path = path.slice(0, wallIndex);
  }
  
  // 경로를 따라 모든 몬스터에게 데미지 적용 (관통)
  path.forEach(pos => {
    let m = monsters.find(m => m.x === pos.x && m.y === pos.y && m.hp > 0);
    if (m) {
      let dmg = 3; // 레이저는 고정 데미지
      m.hp -= dmg;
      addMsg(`레이저가 몬스터를 관통합니다! (${dmg} 데미지)`);
      if (m.hp <= 0) addMsg('몬스터가 쓰러집니다!');
      hit = true;
    }
  });
  
  if (!hit) addMsg('레이저가 허공을 가립니다.');
  
  // 레이저 광선 효과 표시
  showLaserBeam(path);
}

// 총알 궤적 표시 함수
function showBulletTrail(path) {
  // 경로에 점 표시
  path.forEach((pos, index) => {
    setTimeout(() => {
      const cellIndex = (pos.y - Math.max(0, Math.min(MAP_H - SCREEN_H, player.y - Math.floor(SCREEN_H / 2)))) * SCREEN_W + 
                        (pos.x - Math.max(0, Math.min(MAP_W - SCREEN_W, player.x - Math.floor(SCREEN_W / 2))));
      const cells = document.getElementById('game-grid').children;
      
      if (cellIndex >= 0 && cellIndex < cells.length) {
        const cell = cells[cellIndex];
        const originalContent = cell.innerHTML;
        
        // 총알 효과 표시
        cell.innerHTML = '·';
        cell.style.color = 'yellow';
        
        // 잠시 후 원래대로 복원
        setTimeout(() => {
          cell.innerHTML = originalContent;
          cell.style.color = '';
        }, 100);
      }
    }, index * 30); // 30ms 간격으로 순차 표시
  });
}

// 로켓 애니메이션 함수
function animateRocket(path) {
  let currentIndex = 0;
  
  const interval = setInterval(() => {
    // 이전 로켓 지우기
    if (currentIndex > 0) {
      const prevPos = path[currentIndex - 1];
      const prevCellIndex = (prevPos.y - Math.max(0, Math.min(MAP_H - SCREEN_H, player.y - Math.floor(SCREEN_H / 2)))) * SCREEN_W + 
                           (prevPos.x - Math.max(0, Math.min(MAP_W - SCREEN_W, player.x - Math.floor(SCREEN_W / 2))));
      const cells = document.getElementById('game-grid').children;
      
      if (prevCellIndex >= 0 && prevCellIndex < cells.length) {
        const cell = cells[prevCellIndex];
        // 원래 내용 복원 (간단히 처리)
        cell.innerHTML = TILES.FLOOR.emoji;
        cell.style.color = '';
      }
    }
    
    // 현재 위치에 로켓 표시
    if (currentIndex < path.length) {
      const pos = path[currentIndex];
      const cellIndex = (pos.y - Math.max(0, Math.min(MAP_H - SCREEN_H, player.y - Math.floor(SCREEN_H / 2)))) * SCREEN_W + 
                        (pos.x - Math.max(0, Math.min(MAP_W - SCREEN_W, player.x - Math.floor(SCREEN_W / 2))));
      const cells = document.getElementById('game-grid').children;
      
      if (cellIndex >= 0 && cellIndex < cells.length) {
        const cell = cells[cellIndex];
        
        // 로켓 효과 표시
        cell.innerHTML = '🚀';
        cell.style.color = 'orange';
      }
      
      currentIndex++;
    } else {
      // 애니메이션 종료 및 폭발 효과
      clearInterval(interval);
      
      if (path.length > 0) {
        const lastPos = path[path.length - 1];
        const lastCellIndex = (lastPos.y - Math.max(0, Math.min(MAP_H - SCREEN_H, player.y - Math.floor(SCREEN_H / 2)))) * SCREEN_W + 
                             (lastPos.x - Math.max(0, Math.min(MAP_W - SCREEN_W, player.x - Math.floor(SCREEN_W / 2))));
        const cells = document.getElementById('game-grid').children;
        
        if (lastCellIndex >= 0 && lastCellIndex < cells.length) {
          const cell = cells[lastCellIndex];
          
          // 폭발 효과
          cell.innerHTML = '💥';
          
          // 잠시 후 원래대로 복원
          setTimeout(() => {
            cell.innerHTML = TILES.FLOOR.emoji;
            cell.style.color = '';
          }, 300);
        }
      }
    }
  }, 100); // 100ms 간격으로 애니메이션
}

// 레이저 광선 효과 함수
function showLaserBeam(path) {
  console.log("레이저 경로 표시 시작", path);
  
  if (!path || path.length === 0) {
    console.log("경로가 비어있습니다!");
    return;
  }
  
  // 렌더링 방지 플래그 설정 (이 시간 동안 추가 렌더링 방지)
  const preventRenderUntil = Date.now() + 1000;
  window.laserEffectActive = preventRenderUntil;
  
  // 각 셀의 원래 내용 저장
  const originalContents = [];
  const cellsToUpdate = [];
  
  // 모든 셀 정보 수집
  path.forEach((pos, index) => {
    const cellIndex = (pos.y - Math.max(0, Math.min(MAP_H - SCREEN_H, player.y - Math.floor(SCREEN_H / 2)))) * SCREEN_W + 
                      (pos.x - Math.max(0, Math.min(MAP_W - SCREEN_W, player.x - Math.floor(SCREEN_W / 2))));
    const cells = document.getElementById('game-grid').children;
    
    if (cellIndex >= 0 && cellIndex < cells.length) {
      const cell = cells[cellIndex];
      originalContents.push({
        cell: cell,
        content: cell.innerHTML,
        backgroundColor: cell.style.backgroundColor,
        color: cell.style.color
      });
      cellsToUpdate.push(cell);
    }
  });
  
  console.log(`레이저 경로에 있는 셀 수: ${cellsToUpdate.length}`);
  
  // 1단계: 강렬한 노란색 레이저 빔 (0ms)
  cellsToUpdate.forEach(cell => {
    cell.innerHTML = '⚡'; // 레이저 이모티콘
    cell.style.setProperty('color', '#FFFF00', 'important'); // 노란색
    cell.style.setProperty('background-color', '#880000', 'important'); // 어두운 빨간색 배경
  });
  
  // 2단계: 중간 강도 (300ms)
  setTimeout(() => {
    cellsToUpdate.forEach(cell => {
      cell.innerHTML = '✨'; // 다른 이모티콘
      cell.style.setProperty('color', '#FFDD00', 'important');
      cell.style.setProperty('background-color', '#660000', 'important');
    });
  }, 300);
  
  // 3단계: 옅은 효과 (600ms)
  setTimeout(() => {
    cellsToUpdate.forEach(cell => {
      cell.innerHTML = '·'; // 더 작은 이모티콘
      cell.style.setProperty('color', '#FFEE88', 'important');
      cell.style.setProperty('background-color', '#440000', 'important');
    });
  }, 600);
  
  // 원래 상태로 복원 (900ms)
  setTimeout(() => {
    originalContents.forEach(item => {
      const cell = item.cell;
      if (cell) {
        cell.innerHTML = item.content;
        cell.style.removeProperty('color');
        cell.style.removeProperty('background-color');
        
        // 원래 스타일이 있었다면 복원
        if (item.backgroundColor) cell.style.backgroundColor = item.backgroundColor;
        if (item.color) cell.style.color = item.color;
      }
    });
    
    // 렌더링 방지 플래그 해제
    window.laserEffectActive = false;
    console.log("레이저 경로 표시 종료");
    
    // 강제 렌더링으로 화면 업데이트
    setTimeout(render, 50);
  }, 900);
}

// 게임 초기화 호출
window.onload = function() {
  console.log("게임 초기화 시작");
  init();
  console.log("게임 초기화 완료");
};

// 몬스터의 시야 계산 함수
function calcMonsterFOV(monster) {
  let vis = {};
  for (let dy = -VIEW_R; dy <= VIEW_R; ++dy)
    for (let dx = -VIEW_R; dx <= VIEW_R; ++dx) {
      let tx = monster.x + dx, ty = monster.y + dy;
      if (inMap(tx, ty) && Math.sqrt(dx * dx + dy * dy) <= VIEW_R) {
        los(monster.x, monster.y, tx, ty, (x, y) => {
          vis[`${x},${y}`] = true;
          return map[y][x] !== WALL;
        });
      }
    }
  return vis;
}

// 시야 공유 그룹 업데이트 함수
function updateSightGroups() {
  // 기존 그룹 초기화
  sightGroups = [];
  
  // 모든 유니콘과 플레이어의 시야 계산
  const playerFOV = calcFOV();
  const unicorns = monsters.filter(m => m.isUnicorn && m.hp > 0);
  
  // 각 유니콘의 시야 계산
  const unicornFOVs = unicorns.map(unicorn => ({
    unicorn: unicorn,
    fov: calcMonsterFOV(unicorn)
  }));
  
  // 시야 공유 관계 확인
  const entities = [{ type: 'player', fov: playerFOV }, ...unicornFOVs];
  const connections = [];
  
  // 플레이어의 시야에 유니콘이 있는지 직접 확인
  let playerCanSeeUnicorn = false;
  if (unicorns.length > 0) {
    playerCanSeeUnicorn = unicorns.some(unicorn => playerFOV[`${unicorn.x},${unicorn.y}`]);
  }
  
  // 모든 엔티티 쌍에 대해 시야 공유 확인
  for (let i = 0; i < entities.length; i++) {
    for (let j = i + 1; j < entities.length; j++) {
      const entity1 = entities[i];
      const entity2 = entities[j];
      
      // 시야 공유 여부 확인
      let sharesSight = false;
      
      // 엔티티1이 엔티티2를 볼 수 있는지 확인
      if (entity1.type === 'player') {
        const unicorn = entity2.unicorn;
        if (entity1.fov[`${unicorn.x},${unicorn.y}`]) {
          sharesSight = true;
        }
      } else if (entity2.type === 'player') {
        const unicorn = entity1.unicorn;
        if (entity2.fov[`${unicorn.x},${unicorn.y}`]) {
          sharesSight = true;
        }
      } else {
        // 유니콘끼리의 시야 공유 확인
        const unicorn1 = entity1.unicorn;
        const unicorn2 = entity2.unicorn;
        if (entity1.fov[`${unicorn2.x},${unicorn2.y}`]) {
          sharesSight = true;
        }
      }
      
      if (sharesSight) {
        connections.push([i, j]);
      }
    }
  }
  
  // 연결 관계를 기반으로 그룹 형성
  const visited = new Array(entities.length).fill(false);
  
  for (let i = 0; i < entities.length; i++) {
    if (visited[i]) continue;
    
    // BFS로 연결된 모든 엔티티 찾기
    const group = [];
    const queue = [i];
    visited[i] = true;
    
    while (queue.length > 0) {
      const current = queue.shift();
      group.push(current);
      
      // 현재 엔티티와 연결된 모든 엔티티 찾기
      for (const [a, b] of connections) {
        let next = -1;
        if (a === current && !visited[b]) next = b;
        if (b === current && !visited[a]) next = a;
        
        if (next !== -1) {
          visited[next] = true;
          queue.push(next);
        }
      }
    }
    
    // 그룹에 플레이어가 포함되어 있는지 확인
    const hasPlayer = group.some(idx => entities[idx].type === 'player');
    
    // 그룹에 포함된 유니콘들 수집
    const groupUnicorns = group
      .filter(idx => entities[idx].type !== 'player')
      .map(idx => entities[idx].unicorn);
    
    // 유효한 그룹만 추가 (플레이어가 있거나 유니콘이 2마리 이상)
    if (hasPlayer || groupUnicorns.length > 1) {
      sightGroups.push({
        hasPlayer: hasPlayer,
        unicorns: groupUnicorns
      });
    }
  }
  
  // 실시간 턴 시스템 활성화 여부 결정
  const playerGroup = sightGroups.find(group => group.hasPlayer);
  const unicornGroup = sightGroups.find(group => !group.hasPlayer && group.unicorns.length > 1);
  const wasActive = realTimeTurnActive;
  
  // 플레이어가 직접 유니콘을 볼 수 있을 때만 실시간 턴 시스템 활성화
  realTimeTurnActive = playerCanSeeUnicorn;
  
  // 실시간 턴 시스템 상태 변경 시 처리
  if (!wasActive && realTimeTurnActive) {
    // 실시간 턴 시스템 활성화
    startRealTimeTurn();
    
    if (playerCanSeeUnicorn) {
      addMsg('유니콘과 시야가 겹쳤습니다! 실시간 턴 시스템이 활성화됩니다.');
      
      // 플레이어 시야에 있는 유니콘들에게 플레이어 감지 상태 설정
      unicorns.forEach(unicorn => {
        if (playerFOV[`${unicorn.x},${unicorn.y}`]) {
          unicorn.lastSeenPlayer = true;
        }
      });
    }
  } else if (wasActive && !realTimeTurnActive) {
    // 실시간 턴 시스템 비활성화
    addMsg('실시간 턴 시스템이 비활성화되었습니다. 일반 턴 시스템으로 돌아갑니다.');
  }
}

// 실시간 턴 시작 함수
function startRealTimeTurn() {
  currentTurnTime = Date.now();
  playerActedThisTurn = false;
  
  // 플레이어가 속한 그룹의 유니콘들에게 랜덤 행동 시간 설정
  const playerGroup = sightGroups.find(group => group.hasPlayer);
  if (playerGroup) {
    playerGroup.unicorns.forEach(unicorn => {
      // 0~500ms 사이의 랜덤한 시간에 행동
      unicorn.nextMoveTime = currentTurnTime + Math.floor(Math.random() * turnDuration);
    });
  }
  
  // 유니콘끼리 시야가 겹치는 그룹의 유니콘들에게 랜덤 행동 시간 설정
  const unicornGroups = sightGroups.filter(group => !group.hasPlayer && group.unicorns.length > 1);
  unicornGroups.forEach(group => {
    group.unicorns.forEach(unicorn => {
      // 0~500ms 사이의 랜덤한 시간에 행동
      unicorn.nextMoveTime = currentTurnTime + Math.floor(Math.random() * turnDuration);
    });
  });
}

// 실시간 턴 처리 함수 (게임 루프에서 호출)
function processRealTimeTurn() {
  if (!realTimeTurnActive) return;
  
  const now = Date.now();
  const elapsed = now - currentTurnTime;
  
  // 턴 시간이 지났는지 확인
  if (elapsed >= turnDuration) {
    // 턴 종료, 새 턴 시작
    endRealTimeTurn();
    startRealTimeTurn();
    return;
  }
  
  // 모든 실시간 턴 그룹 처리
  sightGroups.forEach(group => {
    // 그룹에 속한 유니콘들의 행동 처리
    group.unicorns.forEach(unicorn => {
      // 이 턴에 행동할 시간이 되었고, 아직 행동하지 않았다면
      if (now >= unicorn.nextMoveTime && unicorn.nextMoveTime >= currentTurnTime) {
        // 유니콘 행동 처리
        unicornAction(unicorn);
        
        // 행동 완료 표시 (이번 턴에 다시 행동하지 않도록)
        unicorn.nextMoveTime = currentTurnTime - 1;
      }
    });
  });
}

// 턴 종료 함수
function endRealTimeTurn() {
  // 플레이어가 포함된 그룹이 있는 경우에만 메시지 표시
  const playerInvolved = sightGroups.some(group => group.hasPlayer);
  
  // 플레이어가 이번 턴에 행동하지 않았다면 메시지 표시 (플레이어가 포함된 경우만)
  if (playerInvolved && !playerActedThisTurn) {
    addMsg('턴이 지나갔습니다! 빠르게 행동하세요.');
  }
  
  // 시야 공유 그룹 업데이트
  updateSightGroups();
  
  // 실시간 턴이 계속 활성화되어 있다면 UI 업데이트
  if (realTimeTurnActive) {
    render();
  }
}

// 유니콘 행동 함수
function unicornAction(unicorn) {
  // 이미 죽었다면 행동하지 않음
  if (unicorn.hp <= 0) return;
  
  // 시야 내 몬스터 찾기 (유니콘은 다른 몬스터만 공격)
  const unicornFOV = calcMonsterFOV(unicorn);
  let nearestMonster = null;
  let minDistance = Infinity;
  
  monsters.forEach(m => {
    // 자기 자신이거나 유니콘이거나 이미 죽은 몬스터는 제외
    if (m === unicorn || m.isUnicorn || m.hp <= 0) return;
    
    // 시야 내에 있는지 확인
    if (unicornFOV[`${m.x},${m.y}`]) {
      // 거리 계산
      const distance = Math.abs(m.x - unicorn.x) + Math.abs(m.y - unicorn.y);
      
      // 더 가까운 몬스터 발견 시 업데이트
      if (distance < minDistance) {
        minDistance = distance;
        nearestMonster = m;
      }
    }
  });
  
  // 가까운 몬스터가 있으면 그 방향으로 이동 또는 공격
  if (nearestMonster) {
    unicorn.targetMonster = nearestMonster;
    const dx = Math.sign(nearestMonster.x - unicorn.x);
    const dy = Math.sign(nearestMonster.y - unicorn.y);
    const dist = Math.max(Math.abs(nearestMonster.x - unicorn.x), Math.abs(nearestMonster.y - unicorn.y));
    
    if (dist <= 1) {
      // 몬스터와 인접해 있으면 공격
      nearestMonster.hp -= 4; // 유니콘은 강한 공격력
      addMsg('유니콘이 몬스터를 공격했습니다!');
      
      if (nearestMonster.hp <= 0) {
        addMsg('유니콘이 몬스터를 처치했습니다!');
        unicorn.targetMonster = null;
      }
    } else {
      // 몬스터 방향으로 이동 시도
      const nx = unicorn.x + dx;
      const ny = unicorn.y + dy;
      
      if (inMap(nx, ny) && map[ny][nx] !== WALL && 
          !monsters.some(m => m !== unicorn && m.x === nx && m.y === ny && m.hp > 0)) {
        unicorn.x = nx;
        unicorn.y = ny;
        addMsg('유니콘이 몬스터를 향해 움직입니다.');
      }
    }
  } else if (unicorn.lastSeenPlayer) {
    // 몬스터가 없고 플레이어를 본 적이 있으면 플레이어 근처로 이동
    const dx = Math.sign(player.x - unicorn.x);
    const dy = Math.sign(player.y - unicorn.y);
    const dist = Math.max(Math.abs(player.x - unicorn.x), Math.abs(player.y - unicorn.y));
    
    // 플레이어와 너무 가까우면 거리를 유지
    if (dist <= 2) {
      // 플레이어로부터 멀어지는 방향 찾기
      const nx = unicorn.x - dx;
      const ny = unicorn.y - dy;
      
      if (inMap(nx, ny) && map[ny][nx] !== WALL && 
          !monsters.some(m => m !== unicorn && m.x === nx && m.y === ny && m.hp > 0)) {
        unicorn.x = nx;
        unicorn.y = ny;
      }
    } else if (dist > 5) {
      // 플레이어와 너무 멀면 가까워짐
      const nx = unicorn.x + dx;
      const ny = unicorn.y + dy;
      
      if (inMap(nx, ny) && map[ny][nx] !== WALL && 
          !monsters.some(m => m !== unicorn && m.x === nx && m.y === ny && m.hp > 0)) {
        unicorn.x = nx;
        unicorn.y = ny;
      }
    } else {
      // 적절한 거리면 랜덤 이동
      randomUnicornMovement(unicorn);
    }
  } else {
    // 플레이어를 본 적이 없으면 랜덤 이동
    randomUnicornMovement(unicorn);
  }
  
  // 행동 후 시야 공유 상태 업데이트는 플레이어가 시야에 있을 가능성이 있을 때만 수행
  if (unicorn.lastSeenPlayer) {
    updateSightGroups();
  }
}

// 유니콘 랜덤 이동 헬퍼 함수
function randomUnicornMovement(unicorn) {
  const directions = [
    { dx: -1, dy: 0 }, { dx: 1, dy: 0 }, { dx: 0, dy: -1 }, { dx: 0, dy: 1 },
    { dx: -1, dy: -1 }, { dx: 1, dy: -1 }, { dx: -1, dy: 1 }, { dx: 1, dy: 1 }
  ];
  
  // 랜덤 방향 선택
  const dir = directions[Math.floor(Math.random() * directions.length)];
  const nx = unicorn.x + dir.dx;
  const ny = unicorn.y + dir.dy;
  
  // 유효한 위치라면 이동
  if (inMap(nx, ny) && map[ny][nx] !== WALL && 
      !monsters.some(m => m !== unicorn && m.x === nx && m.y === ny && m.hp > 0)) {
    unicorn.x = nx;
    unicorn.y = ny;
  }
}

// 게임 루프 함수
function startGameLoop() {
  // 게임 루프 간격 (밀리초)
  const GAME_LOOP_INTERVAL = 50; // 50ms마다 업데이트 (초당 20회)
  
  // 게임 루프 설정
  window.gameLoopInterval = setInterval(() => {
    // 게임 오버 상태면 루프 중단
    if (gameOver) {
      clearInterval(window.gameLoopInterval);
      return;
    }
    
    // 실시간 턴 시스템 처리
    if (realTimeTurnActive) {
      processRealTimeTurn();
      
      // 턴 타이머 UI 업데이트
      const turnTimer = document.getElementById('turn-timer');
      const turnTimerBar = document.getElementById('turn-timer-bar');
      
      if (turnTimer && turnTimerBar) {
        // 실시간 턴 시스템이 활성화된 경우에만 타이머 표시 (이미 플레이어가 유니콘을 볼 수 있는지 확인됨)
        turnTimer.style.display = 'block';
        const now = Date.now();
        const elapsed = now - currentTurnTime;
        const remaining = Math.max(0, turnDuration - elapsed);
        const percent = (remaining / turnDuration) * 100;
        
        turnTimerBar.style.width = `${percent}%`;
        
        // 남은 시간에 따라 색상 변경
        if (percent > 60) {
          turnTimerBar.style.backgroundColor = '#0f0'; // 녹색
        } else if (percent > 30) {
          turnTimerBar.style.backgroundColor = '#ff0'; // 노란색
        } else {
          turnTimerBar.style.backgroundColor = '#f00'; // 빨간색
        }
      }
    } else {
      // 실시간 턴 시스템이 비활성화된 경우 타이머 숨김
      const turnTimer = document.getElementById('turn-timer');
      if (turnTimer) {
        turnTimer.style.display = 'none';
      }
    }
  }, GAME_LOOP_INTERVAL);
}

// 프랙탈 노이즈 생성을 위한 유틸리티 함수
function generateNoise(width, height, scale, octaves, persistence, lacunarity, seed) {
  // 2D 노이즈 맵 초기화
  const noiseMap = new Array(height);
  for (let y = 0; y < height; y++) {
    noiseMap[y] = new Array(width);
  }
  
  // 시드 기반 랜덤 함수
  const seededRandom = function(x, y) {
    const dot = x * 12.9898 + y * 78.233 + seed;
    let value = Math.sin(dot) * 43758.5453123;
    value = value - Math.floor(value);
    return value;
  };
  
  // 보간 함수
  const smoothstep = function(a, b, t) {
    t = Math.max(0, Math.min(1, (t - a) / (b - a)));
    return t * t * (3 - 2 * t);
  };
  
  // 2D 값 노이즈 생성
  const valueNoise2D = function(x, y) {
    // 격자점 좌표
    const x0 = Math.floor(x);
    const y0 = Math.floor(y);
    const x1 = x0 + 1;
    const y1 = y0 + 1;
    
    // 각 격자점에서의 랜덤값
    const v00 = seededRandom(x0, y0);
    const v10 = seededRandom(x1, y0);
    const v01 = seededRandom(x0, y1);
    const v11 = seededRandom(x1, y1);
    
    // 보간 가중치
    const sx = smoothstep(0, 1, x - x0);
    const sy = smoothstep(0, 1, y - y0);
    
    // 수평 보간
    const a = v00 * (1 - sx) + v10 * sx;
    const b = v01 * (1 - sx) + v11 * sx;
    
    // 수직 보간
    return a * (1 - sy) + b * sy;
  };
  
  // 옥타브 노이즈 생성
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      let amplitude = 1;
      let frequency = 1;
      let noiseValue = 0;
      let normalizer = 0;
      
      // 여러 옥타브의 노이즈를 합성
      for (let o = 0; o < octaves; o++) {
        const sampleX = x / scale * frequency;
        const sampleY = y / scale * frequency;
        
        const noise = valueNoise2D(sampleX, sampleY) * 2 - 1;
        noiseValue += noise * amplitude;
        normalizer += amplitude;
        
        amplitude *= persistence;
        frequency *= lacunarity;
      }
      
      // 정규화
      noiseValue = noiseValue / normalizer;
      noiseMap[y][x] = (noiseValue + 1) / 2; // 0~1 범위로 변환
    }
  }
  
  return noiseMap;
}

// 프랙탈 노이즈를 이용한 자연스러운 지형 생성
function generateTerrainWithNoise() {
  // 노이즈 맵 생성
  const noiseMap = generateNoise(MAP_W, MAP_H, 20, 4, 0.5, 2, Math.random() * 10000);
  
  // 노이즈 값에 따른 지형 설정
  for (let y = 1; y < MAP_H - 1; y++) {
    for (let x = 1; x < MAP_W - 1; x++) {
      const noiseValue = noiseMap[y][x];
      
      // 이미 특별한 바이옴이나 구조물이 있는 경우 건너뛰기
      if (terrainMap[y][x] !== TERRAIN_TYPES.GRASS) continue;
      
      // 노이즈 값에 따른 지형 결정
      if (noiseValue < 0.3) {
        // 물
        terrainMap[y][x] = TERRAIN_TYPES.WATER;
        map[y][x] = WALL; // 물은 통과 불가능
      } else if (noiseValue < 0.4) {
        // 늪지대
        terrainMap[y][x] = TERRAIN_TYPES.SWAMP;
      } else if (noiseValue < 0.6) {
        // 잔디 (기본값)
        terrainMap[y][x] = TERRAIN_TYPES.GRASS;
      } else if (noiseValue < 0.75) {
        // 숲
        terrainMap[y][x] = TERRAIN_TYPES.FOREST;
        if (Math.random() < 0.3) {
          map[y][x] = WALL;
          terrainMap[y][x] = TERRAIN_TYPES.TREE;
        }
      } else {
        // 산
        terrainMap[y][x] = TERRAIN_TYPES.MOUNTAIN;
        if (noiseValue > 0.85) {
          map[y][x] = WALL;
          terrainMap[y][x] = TERRAIN_TYPES.ROCK;
        }
      }
    }
  }
}

// 동적 위험 지역 관련 변수
let dangerZones = [];
const DANGER_TYPES = {
  LAVA: { name: 'LAVA', emoji: '🌋', damage: 3, spreadChance: 0.05, duration: 20 },
  POISON: { name: 'POISON', emoji: '☣️', damage: 1, spreadChance: 0.1, duration: 15 },
  RADIATION: { name: 'RADIATION', emoji: '☢️', damage: 2, spreadChance: 0.03, duration: 30 }
};

// 동적 위험 지역 생성 함수
function createDangerZone(type, x, y, radius, duration) {
  const dangerType = DANGER_TYPES[type];
  if (!dangerType) return;
  
  // 새로운 위험 지역 생성
  const newZone = {
    type: dangerType,
    center: { x, y },
    radius: radius,
    tiles: [],
    remainingTurns: duration || dangerType.duration,
    lastSpreadTurn: 0
  };
  
  // 초기 위험 지역 타일 설정
  for (let dy = -radius; dy <= radius; dy++) {
    for (let dx = -radius; dx <= radius; dx++) {
      const tx = x + dx;
      const ty = y + dy;
      
      if (!inMap(tx, ty)) continue;
      
      // 중심으로부터의 거리 계산
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      if (distance <= radius) {
        // 거리에 따른 확률로 위험 지역 타일 설정
        const probability = 1 - (distance / radius);
        
        if (Math.random() < probability * 0.7) {
          // 위험 지역 타일 추가
          newZone.tiles.push({ x: tx, y: ty });
          
          // 지형 업데이트 (시각적 표시)
          if (type === 'LAVA') {
            terrainMap[ty][tx] = TERRAIN_TYPES.LAVA;
          } else if (type === 'POISON') {
            terrainMap[ty][tx] = TERRAIN_TYPES.SWAMP;
          } else if (type === 'RADIATION') {
            terrainMap[ty][tx] = TERRAIN_TYPES.WASTELAND;
          }
        }
      }
    }
  }
  
  // 위험 지역 등록
  dangerZones.push(newZone);
}

// 위험 지역 업데이트 함수 (턴마다 호출)
function updateDangerZones() {
  // 플레이어가 위험 지역에 있는지 확인
  for (const zone of dangerZones) {
    // 플레이어가 위험 지역 타일에 있는지 확인
    const playerInDanger = zone.tiles.some(tile => tile.x === player.x && tile.y === player.y);
    
    if (playerInDanger) {
      // 플레이어에게 데미지
      player.hp -= zone.type.damage;
      addMsg(`${zone.type.name} 지역에서 ${zone.type.damage}의 데미지를 입었습니다!`);
      
      if (player.hp <= 0) {
        gameOver = true;
        addMsg('위험 지역에서 사망했습니다!');
      }
    }
    
    // 위험 지역 지속 시간 감소
    zone.remainingTurns--;
    
    // 위험 지역 확산 (3턴마다)
    if (zone.remainingTurns % 3 === 0) {
      spreadDangerZone(zone);
    }
    
    // 지속 시간이 끝난 위험 지역 제거
    if (zone.remainingTurns <= 0) {
      // 지형 복원
      for (const tile of zone.tiles) {
        terrainMap[tile.y][tile.x] = TERRAIN_TYPES.GRASS;
      }
    }
  }
  
  // 지속 시간이 끝난 위험 지역 필터링
  dangerZones = dangerZones.filter(zone => zone.remainingTurns > 0);
}

// 위험 지역 확산 함수
function spreadDangerZone(zone) {
  const newTiles = [];
  
  // 기존 타일에서 확산
  for (const tile of zone.tiles) {
    // 인접한 4방향 확인
    const directions = [
      { dx: 0, dy: -1 }, // 상
      { dx: 1, dy: 0 },  // 우
      { dx: 0, dy: 1 },  // 하
      { dx: -1, dy: 0 }  // 좌
    ];
    
    for (const dir of directions) {
      const nx = tile.x + dir.dx;
      const ny = tile.y + dir.dy;
      
      // 맵 범위 확인
      if (!inMap(nx, ny)) continue;
      
      // 이미 위험 지역인지 확인
      const alreadyDanger = zone.tiles.some(t => t.x === nx && t.y === ny) || 
                           newTiles.some(t => t.x === nx && t.y === ny);
      
      if (!alreadyDanger && Math.random() < zone.type.spreadChance) {
        // 새로운 위험 지역 타일 추가
        newTiles.push({ x: nx, y: ny });
        
        // 지형 업데이트 (시각적 표시)
        if (zone.type.name === 'LAVA') {
          terrainMap[ny][nx] = TERRAIN_TYPES.LAVA;
        } else if (zone.type.name === 'POISON') {
          terrainMap[ny][nx] = TERRAIN_TYPES.SWAMP;
        } else if (zone.type.name === 'RADIATION') {
          terrainMap[ny][nx] = TERRAIN_TYPES.WASTELAND;
        }
      }
    }
  }
  
  // 새로운 타일 추가
  zone.tiles = [...zone.tiles, ...newTiles];
}

// 랜덤 위험 지역 생성
function createRandomDangerZones(count) {
  const dangerTypes = Object.keys(DANGER_TYPES);
  
  for (let i = 0; i < count; i++) {
    // 랜덤 위치 선택
    let x, y;
    let validPosition = false;
    let attempts = 0;
    
    while (!validPosition && attempts < 100) {
      x = Math.floor(Math.random() * (MAP_W - 20)) + 10;
      y = Math.floor(Math.random() * (MAP_H - 20)) + 10;
      
      // 플레이어와의 거리 확인
      const distToPlayer = Math.sqrt(Math.pow(x - player.x, 2) + Math.pow(y - player.y, 2));
      
      // 플레이어로부터 충분히 떨어져 있는지 확인
      if (distToPlayer > 15) {
        validPosition = true;
      }
      
      attempts++;
    }
    
    if (validPosition) {
      // 랜덤 위험 타입 선택
      const randomType = dangerTypes[Math.floor(Math.random() * dangerTypes.length)];
      
      // 위험 지역 생성
      const radius = Math.floor(Math.random() * 3) + 3; // 3~5 범위
      createDangerZone(randomType, x, y, radius);
    }
  }
}

// 미로 생성 함수 (깊이 우선 탐색)
function generateMaze(startX, startY, width, height) {
  // 미로 영역 초기화 (모두 벽으로)
  for (let y = startY; y < startY + height; y++) {
    for (let x = startX; x < startX + width; x++) {
      if (inMap(x, y)) {
        map[y][x] = WALL;
        terrainMap[y][x] = TERRAIN_TYPES.WALL;
      }
    }
  }
  
  // 미로 생성을 위한 방문 배열
  const visited = Array(height).fill().map(() => Array(width).fill(false));
  
  // 깊이 우선 탐색으로 미로 생성
  function dfs(x, y) {
    visited[y][x] = true;
    
    // 실제 맵 좌표로 변환
    const mapX = x * 2 + startX;
    const mapY = y * 2 + startY;
    
    // 현재 셀을 길로 설정
    if (inMap(mapX, mapY)) {
      map[mapY][mapX] = FLOOR;
      terrainMap[mapY][mapX] = TERRAIN_TYPES.DUNGEON;
    }
    
    // 이동 방향 (상, 우, 하, 좌)
    const directions = [
      { dx: 0, dy: -1 }, // 상
      { dx: 1, dy: 0 },  // 우
      { dx: 0, dy: 1 },  // 하
      { dx: -1, dy: 0 }  // 좌
    ];
    
    // 방향 랜덤 섞기
    for (let i = directions.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [directions[i], directions[j]] = [directions[j], directions[i]];
    }
    
    // 각 방향으로 탐색
    for (const dir of directions) {
      const nx = x + dir.dx;
      const ny = y + dir.dy;
      
      // 범위 체크
      if (nx < 0 || ny < 0 || nx >= Math.floor(width / 2) || ny >= Math.floor(height / 2)) continue;
      
      // 방문하지 않은 셀이면 이동
      if (!visited[ny][nx]) {
        // 중간 벽 제거 (통로 생성)
        const wallX = mapX + dir.dx;
        const wallY = mapY + dir.dy;
        
        if (inMap(wallX, wallY)) {
          map[wallY][wallX] = FLOOR;
          terrainMap[wallY][wallX] = TERRAIN_TYPES.DUNGEON;
        }
        
        // 다음 셀로 이동
        dfs(nx, ny);
      }
    }
  }
  
  // 시작점에서 미로 생성 시작
  dfs(0, 0);
  
  // 미로에 입구와 출구 생성
  createMazeEntrances(startX, startY, width, height);
}

// 미로 입구와 출구 생성
function createMazeEntrances(startX, startY, width, height) {
  // 입구 생성 (미로 외부에서 접근 가능한 위치)
  const entranceDirections = [
    { dx: 0, dy: -1, side: 'top' },    // 상단
    { dx: width, dy: 0, side: 'right' }, // 우측
    { dx: 0, dy: height, side: 'bottom' }, // 하단
    { dx: -1, dy: 0, side: 'left' }    // 좌측
  ];
  
  // 각 방향에서 입구 생성 시도
  for (const dir of entranceDirections) {
    // 해당 방향에서 적절한 입구 위치 찾기
    let entranceX, entranceY;
    let found = false;
    let attempts = 0;
    
    while (!found && attempts < 10) {
      if (dir.side === 'top' || dir.side === 'bottom') {
        // 상단 또는 하단 입구
        entranceX = startX + Math.floor(Math.random() * (width - 2)) + 1;
        entranceY = startY + (dir.side === 'top' ? 0 : height - 1);
      } else {
        // 좌측 또는 우측 입구
        entranceX = startX + (dir.side === 'left' ? 0 : width - 1);
        entranceY = startY + Math.floor(Math.random() * (height - 2)) + 1;
      }
      
      // 입구 위치가 유효한지 확인
      if (inMap(entranceX, entranceY) && 
          inMap(entranceX + dir.dx, entranceY + dir.dy)) {
        // 입구 생성
        map[entranceY][entranceX] = FLOOR;
        terrainMap[entranceY][entranceX] = TERRAIN_TYPES.DUNGEON;
        
        // 입구 주변도 길로 설정 (접근 가능하도록)
        const outsideX = entranceX + dir.dx;
        const outsideY = entranceY + dir.dy;
        
        if (map[outsideY][outsideX] === WALL) {
          map[outsideY][outsideX] = FLOOR;
          terrainMap[outsideY][outsideX] = TERRAIN_TYPES.GRASS;
        }
        
        found = true;
      }
      
      attempts++;
    }
  }
}

// 통로 시스템 생성 함수
function createTunnelSystem(count) {
  for (let i = 0; i < count; i++) {
    // 시작점과 끝점 선택
    let startX, startY, endX, endY;
    let validPoints = false;
    let attempts = 0;
    
    while (!validPoints && attempts < 100) {
      // 시작점 선택
      startX = Math.floor(Math.random() * (MAP_W - 20)) + 10;
      startY = Math.floor(Math.random() * (MAP_H - 20)) + 10;
      
      // 끝점 선택 (시작점으로부터 일정 거리 떨어진 위치)
      const angle = Math.random() * Math.PI * 2;
      const distance = 15 + Math.random() * 20;
      endX = Math.floor(startX + Math.cos(angle) * distance);
      endY = Math.floor(startY + Math.sin(angle) * distance);
      
      // 맵 범위 내인지 확인
      if (inMap(startX, startY) && inMap(endX, endY)) {
        validPoints = true;
      }
      
      attempts++;
    }
    
    if (validPoints) {
      // 통로 생성 (A* 알고리즘)
      createTunnel(startX, startY, endX, endY);
    }
  }
}

// A* 알고리즘을 이용한 통로 생성
function createTunnel(startX, startY, endX, endY) {
  // 휴리스틱 함수 (맨해튼 거리)
  const heuristic = (x, y) => Math.abs(x - endX) + Math.abs(y - endY);
  
  // 우선순위 큐 구현 (간단한 배열로)
  const openSet = [{ x: startX, y: startY, g: 0, h: heuristic(startX, startY) }];
  const closedSet = new Set();
  const cameFrom = {};
  
  // g 점수 (시작점으로부터의 비용)
  const gScore = {};
  gScore[`${startX},${startY}`] = 0;
  
  while (openSet.length > 0) {
    // f 점수가 가장 낮은 노드 찾기
    let lowestIndex = 0;
    for (let i = 1; i < openSet.length; i++) {
      if (openSet[i].g + openSet[i].h < openSet[lowestIndex].g + openSet[lowestIndex].h) {
        lowestIndex = i;
      }
    }
    
    const current = openSet[lowestIndex];
    
    // 목적지에 도달한 경우
    if (current.x === endX && current.y === endY) {
      // 경로 재구성
      let path = [];
      let currentKey = `${current.x},${current.y}`;
      
      while (currentKey in cameFrom) {
        const [x, y] = currentKey.split(',').map(Number);
        path.push({ x, y });
        currentKey = cameFrom[currentKey];
      }
      
      // 시작점 추가
      path.push({ x: startX, y: startY });
      path.reverse();
      
      // 통로 생성
      for (const pos of path) {
        if (inMap(pos.x, pos.y)) {
          map[pos.y][pos.x] = FLOOR;
          
          // 통로 주변 지형 설정
          const surroundingType = Math.random() < 0.5 ? TERRAIN_TYPES.CAVE : TERRAIN_TYPES.DUNGEON;
          terrainMap[pos.y][pos.x] = surroundingType;
          
          // 통로 주변 약간 넓히기 (20% 확률)
          if (Math.random() < 0.2) {
            const dx = Math.random() < 0.5 ? -1 : 1;
            const dy = Math.random() < 0.5 ? -1 : 1;
            
            if (inMap(pos.x + dx, pos.y) && map[pos.y][pos.x + dx] === WALL) {
              map[pos.y][pos.x + dx] = FLOOR;
              terrainMap[pos.y][pos.x + dx] = surroundingType;
            }
            
            if (inMap(pos.x, pos.y + dy) && map[pos.y + dy][pos.x] === WALL) {
              map[pos.y + dy][pos.x] = FLOOR;
              terrainMap[pos.y + dy][pos.x] = surroundingType;
            }
          }
        }
      }
      
      return;
    }
    
    // 현재 노드 처리 완료
    openSet.splice(lowestIndex, 1);
    closedSet.add(`${current.x},${current.y}`);
    
    // 이웃 노드 탐색
    const neighbors = [
      { dx: 0, dy: -1 }, // 상
      { dx: 1, dy: 0 },  // 우
      { dx: 0, dy: 1 },  // 하
      { dx: -1, dy: 0 }  // 좌
    ];
    
    for (const dir of neighbors) {
      const nx = current.x + dir.dx;
      const ny = current.y + dir.dy;
      
      // 맵 범위 체크
      if (!inMap(nx, ny)) continue;
      
      // 이미 처리한 노드인지 확인
      if (closedSet.has(`${nx},${ny}`)) continue;
      
      // 이웃 노드까지의 비용
      const tentativeGScore = gScore[`${current.x},${current.y}`] + 1;
      
      // 이웃 노드가 openSet에 없거나, 더 나은 경로를 찾은 경우
      const neighborKey = `${nx},${ny}`;
      if (!openSet.some(node => node.x === nx && node.y === ny) || 
          tentativeGScore < (gScore[neighborKey] || Infinity)) {
        // 경로 업데이트
        cameFrom[neighborKey] = `${current.x},${current.y}`;
        gScore[neighborKey] = tentativeGScore;
        
        // openSet에 없으면 추가
        if (!openSet.some(node => node.x === nx && node.y === ny)) {
          openSet.push({
            x: nx,
            y: ny,
            g: tentativeGScore,
            h: heuristic(nx, ny)
          });
        }
      }
    }
  }
}
</script>
</body>
</html>