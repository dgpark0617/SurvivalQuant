<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <title>Doom Emoji RL (Emoji-based, JS, One File, Customizable, True Turn-based Reload)</title>
  <style>
    body { 
      background: #222; 
      color: #eee; 
      font-family: 'Courier New', monospace; 
      text-align: center;
      margin: 0;
      padding: 20px;
    }
    #game-container {
      display: inline-block;
      margin: 0 auto;
      max-width: 100%;
    }
    #game-grid {
      display: grid;
      grid-template-columns: repeat(30, 1fr);
      gap: 0px;
      margin-bottom: 10px;
      background-color: #111;
      border: 2px solid #444;
      padding: 5px;
    }
    .cell {
      width: 20px;
      height: 20px;
      font-size: 18px;
      line-height: 20px;
      text-align: center;
      user-select: none;
    }
    #status-bar {
      font-size: 16px;
      margin-bottom: 5px;
      padding: 5px;
      background-color: #333;
      border: 1px solid #555;
      text-align: left;
    }
    #message-log {
      height: 80px;
      overflow-y: auto;
      font-size: 14px;
      margin-top: 5px;
      margin-bottom: 10px;
      padding: 5px;
      background-color: #333;
      border: 1px solid #555;
      text-align: left;
    }
    #mobile-controls {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-top: 15px;
      user-select: none;
    }
    .controls-row {
      display: flex;
      justify-content: center;
      margin-bottom: 5px;
    }
    .dir-btn, .action-btn {
      width: 50px;
      height: 50px;
      margin: 0 5px;
      font-size: 24px;
      background-color: #444;
      border: 2px solid #666;
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
    }
    .dir-btn:active, .action-btn:active {
      background-color: #666;
      transform: scale(0.95);
    }
    .action-row {
      margin-top: 10px;
    }
    .action-btn {
      background-color: #553355;
    }
    /* ëª¨ë°”ì¼ ìµœì í™” */
    @media (max-width: 768px) {
      body {
        padding: 10px 5px;
      }
      .cell {
        width: 18px;
        height: 18px;
        font-size: 16px;
      }
      .dir-btn, .action-btn {
        width: 45px;
        height: 45px;
        margin: 0 3px;
      }
    }
    /* ì‘ì€ í™”ë©´ ìµœì í™” */
    @media (max-width: 480px) {
      .cell {
        width: 16px;
        height: 16px;
        font-size: 14px;
      }
      .dir-btn, .action-btn {
        width: 40px;
        height: 40px;
        font-size: 20px;
      }
    }
    .hidden {
      visibility: hidden;
    }
    .wall { background-color: #555; }
    .floor { background-color: #222; }  /* ë°”ë‹¥ ë°°ê²½ìƒ‰ ì–´ë‘¡ê²Œ ì„¤ì • */
  </style>
</head>
<body>
<div id="game-container">
  <div id="status-bar"></div>
  <div id="game-grid"></div>
  <div id="message-log"></div>
  <div id="mobile-controls">
    <div class="controls-row">
      <button class="dir-btn" data-dir="6">â†–ï¸</button>
      <button class="dir-btn" data-dir="7">â¬†ï¸</button>
      <button class="dir-btn" data-dir="8">â†—ï¸</button>
    </div>
    <div class="controls-row">
      <button class="dir-btn" data-dir="3">â¬…ï¸</button>
      <button class="action-btn" id="aim-btn">ğŸ”«</button>
      <button class="dir-btn" data-dir="5">â¡ï¸</button>
    </div>
    <div class="controls-row">
      <button class="dir-btn" data-dir="0">â†™ï¸</button>
      <button class="dir-btn" data-dir="1">â¬‡ï¸</button>
      <button class="dir-btn" data-dir="2">â†˜ï¸</button>
    </div>
    <div class="controls-row action-row">
      <button class="action-btn" id="reload-btn">ğŸ”„</button>
      <button class="action-btn" id="run-btn">ğŸ‘Ÿ</button>
      <button class="action-btn" id="weapon-btn">ğŸ”«âš¡</button>
    </div>
  </div>
</div>
<script>
// ======= Game configuration (difficulty & settings) =======
const MAP_W = 100;            // Map width
const MAP_H = 100;            // Map height
const VIEW_R = 8;             // Sight radius
const SCREEN_W = 30;          // Displayed area width
const SCREEN_H = 20;          // Displayed area height
const MONSTER_COUNT = 100;     // Number of monsters
const PLAYER_START_HP = 10;   // Player HP
const PLAYER_AMMO_MAX = 6;    // Gun max ammo
const MONSTER_HP = 5;         // Monster HP (raise for harder game)
const WALL_RATIO = 0.08;      // Wall generation ratio (0~1)
const GUN_DAMAGE_MIN = 2;     // Gun minimum damage
const GUN_DAMAGE_MAX = 3;     // Gun maximum damage (inclusive)
// ==========================================================

// Map symbols with emoji
const TILES = {
  FLOOR: { symbol: '.', emoji: 'â¬œ' },  // ë°”ë‹¥ì€ í°ìƒ‰ ì‚¬ê°í˜•ìœ¼ë¡œ ë³€ê²½
  WALL: { symbol: '#', emoji: 'ğŸ§±' },   // ë²½ì€ ë²½ëŒ ì´ëª¨ì§€
  PLAYER: { symbol: '@', emoji: 'ğŸ¤º' },
  MONSTER: { symbol: 'M', emoji: 'ğŸ‘¹' },
  MONSTER_WEAK: { symbol: 'M', emoji: 'ğŸ‘º' },
  MONSTER_STRONG: { symbol: 'M', emoji: 'ğŸ‘¿' },
  MONSTER_DEAD: { symbol: 'M', emoji: 'ğŸ’€' },
  BULLET: { symbol: '*', emoji: 'ğŸ’¥' },
  HIDDEN: { symbol: ' ', emoji: 'â¬›' }  // ì‹œì•¼ ë°–ì€ ê²€ì€ìƒ‰ ì‚¬ê°í˜•
};

// For compatibility with existing code
const FLOOR = '.', WALL = '#', PLAYER = '@', MONSTER = 'M', BULLET = '*';

// Game state
let map = [];
let player = {
  x: Math.floor(MAP_W / 2),
  y: Math.floor(MAP_H / 2),
  hp: PLAYER_START_HP,
  ammo: PLAYER_AMMO_MAX,
  aiming: false,
  aimDir: { dx: 0, dy: 0 },
  aimTarget: null,      // ì¡°ì¤€ ì¤‘ì¸ íƒ€ê²Ÿ ìœ„ì¹˜ {x, y}
  aimPath: [],          // ì¡°ì¤€ ê²½ë¡œ [{x, y}, ...]
  currentWeapon: 'gun'  // í˜„ì¬ ë¬´ê¸° (gun, rocket, laser)
};
let monsters = [];
let msg = [];
let gameOver = false;
let highlightedCells = []; // í•˜ì´ë¼ì´íŠ¸ëœ ì…€ ì¶”ì 
let exploredMap = {}; // íƒì‚¬í•œ ì§€ì—­ì„ ê¸°ì–µí•˜ëŠ” ê°ì²´

// Directions for keypad (1-9, skip 5)
const DIRS = [
  { dx: -1, dy: 1 }, { dx: 0, dy: 1 }, { dx: 1, dy: 1 },
  { dx: -1, dy: 0 }, { dx: 0, dy: 0 }, { dx: 1, dy: 0 },
  { dx: -1, dy: -1 }, { dx: 0, dy: -1 }, { dx: 1, dy: -1 }
];
// Keypad keycode mapping (numpad and numbers)
const NUM_DIR_KEYS = {
  "97": 0, "98": 1, "99": 2, // Numpad 1,2,3
  "100": 3, "101": 4, "102": 5, // Numpad 4,5,6
  "103": 6, "104": 7, "105": 8, // Numpad 7,8,9
  "49": 0, "50": 1, "51": 2, // 1,2,3
  "52": 3, "53": 4, "54": 5, // 4,5,6
  "55": 6, "56": 7, "57": 8  // 7,8,9
};
function addMsg(s) { 
  msg.unshift(s); 
  if (msg.length > 5) msg.length = 5; 
}

// Map generation: simple empty with border and some random walls
function genMap() {
  for (let y = 0; y < MAP_H; ++y) {
    map[y] = [];
    for (let x = 0; x < MAP_W; ++x) {
      if (x === 0 || y === 0 || x === MAP_W - 1 || y === MAP_H - 1)
        map[y][x] = WALL;
      else
        map[y][x] = (Math.random() < WALL_RATIO) ? WALL : FLOOR;
    }
  }
}

// Place player and monsters
function placeEntities() {
  function randPos() {
    let x, y;
    do {
      x = Math.floor(Math.random() * (MAP_W - 2)) + 1;
      y = Math.floor(Math.random() * (MAP_H - 2)) + 1;
    } while (map[y][x] !== FLOOR ||
      (x === player.x && y === player.y) ||
      monsters.some(m => m.x === x && m.y === y));
    return { x, y };
  }
  // Place player
  let p = randPos();
  player.x = p.x; player.y = p.y;
  player.hp = PLAYER_START_HP;
  player.ammo = PLAYER_AMMO_MAX;
  player.aiming = false;
  player.reloading = false;
  // Place monsters
  monsters = [];
  for (let i = 0; i < MONSTER_COUNT; ++i) {
    let m = randPos();
    // Create different monster types
    let monsterType = Math.random();
    if (monsterType < 0.7) { // Regular monster
      monsters.push({ x: m.x, y: m.y, hp: MONSTER_HP, type: 'MONSTER' });
    } else if (monsterType < 0.9) { // Weak monster
      monsters.push({ x: m.x, y: m.y, hp: MONSTER_HP - 2, type: 'MONSTER_WEAK' });
    } else { // Strong monster
      monsters.push({ x: m.x, y: m.y, hp: MONSTER_HP + 2, type: 'MONSTER_STRONG' });
    }
  }
}

// Check if in map
function inMap(x, y) { return x >= 0 && y >= 0 && x < MAP_W && y < MAP_H; }

// Bresenham line for FOV and shooting
function los(x0, y0, x1, y1, fn) {
  let dx = Math.abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
  let dy = -Math.abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
  let err = dx + dy, e2;
  for (; ;) {
    if (fn(x0, y0) === false) return false;
    if (x0 === x1 && y0 === y1) break;
    e2 = 2 * err;
    if (e2 >= dy) { err += dy; x0 += sx; }
    if (e2 <= dx) { err += dx; y0 += sy; }
  }
  return true;
}

// Field of view (returns set of visible positions)
function calcFOV() {
  let vis = {};
  for (let dy = -VIEW_R; dy <= VIEW_R; ++dy)
    for (let dx = -VIEW_R; dx <= VIEW_R; ++dx) {
      let tx = player.x + dx, ty = player.y + dy;
      if (inMap(tx, ty) && Math.sqrt(dx * dx + dy * dy) <= VIEW_R) {
        los(player.x, player.y, tx, ty, (x, y) => {
          vis[`${x},${y}`] = true;
          // íƒì‚¬í•œ ì§€ì—­ ê¸°ë¡
          exploredMap[`${x},${y}`] = map[y][x];
          return map[y][x] !== WALL;
        });
      }
    }
  return vis;
}

// ê²½ë¡œ ì‹œê°í™” í•¨ìˆ˜
function calculatePath(startX, startY, endX, endY) {
  let path = [];
  
  // Bresenham ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ê²½ë¡œ ê³„ì‚°
  let dx = Math.abs(endX - startX), sx = startX < endX ? 1 : -1;
  let dy = -Math.abs(endY - startY), sy = startY < endY ? 1 : -1;
  let err = dx + dy, e2;
  
  let x = startX, y = startY;
  
  while (true) {
    // ì‹œì‘ì ì€ ê²½ë¡œì— í¬í•¨í•˜ì§€ ì•ŠìŒ
    if (!(x === startX && y === startY)) {
      path.push({x, y});
    }
    
    if (x === endX && y === endY) break;
    
    e2 = 2 * err;
    if (e2 >= dy) { err += dy; x += sx; }
    if (e2 <= dx) { err += dx; y += sy; }
    
    // ë²½ì„ ë§Œë‚˜ë©´ ê²½ë¡œ ì¤‘ë‹¨
    if (inMap(x, y) && map[y][x] === WALL) break;
  }
  
  return path;
}

// ì¡°ì¤€ ê²½ë¡œ í‘œì‹œ í•¨ìˆ˜
function showAimPath(startX, startY, endX, endY) {
  // ì´ì „ í•˜ì´ë¼ì´íŠ¸ ì œê±°
  clearHighlights();
  
  // ê²½ë¡œ ê³„ì‚°
  const path = calculatePath(startX, startY, endX, endY);
  player.aimPath = path;
  
  // ê²½ë¡œ í‘œì‹œ
  path.forEach(pos => {
    const cellIndex = (pos.y - Math.max(0, Math.min(MAP_H - SCREEN_H, player.y - Math.floor(SCREEN_H / 2)))) * SCREEN_W + 
                      (pos.x - Math.max(0, Math.min(MAP_W - SCREEN_W, player.x - Math.floor(SCREEN_W / 2))));
    const cells = document.getElementById('game-grid').children;
    
    if (cellIndex >= 0 && cellIndex < cells.length) {
      const cell = cells[cellIndex];
      cell.style.border = '1px solid yellow';
      cell.style.boxShadow = 'inset 0 0 5px yellow';
      highlightedCells.push(cell);
    }
  });
}

// í•˜ì´ë¼ì´íŠ¸ ì œê±° í•¨ìˆ˜
function clearHighlights() {
  highlightedCells.forEach(cell => {
    cell.style.border = '';
    cell.style.boxShadow = '';
  });
  highlightedCells = [];
  player.aimPath = [];
}

// ê°€ì¥ ê°€ê¹Œìš´ ëª¬ìŠ¤í„° ì°¾ê¸°
function findNearestVisibleMonster() {
  let vis = calcFOV();
  let nearestMonster = null;
  let minDistance = Infinity;
  
  monsters.forEach(m => {
    if (m.hp <= 0) return; // ì£½ì€ ëª¬ìŠ¤í„°ëŠ” ì œì™¸
    
    // ì‹œì•¼ ë‚´ì— ìˆëŠ”ì§€ í™•ì¸
    if (vis[`${m.x},${m.y}`]) {
      // ë§¨í•´íŠ¼ ê±°ë¦¬ ê³„ì‚°
      let distance = Math.abs(m.x - player.x) + Math.abs(m.y - player.y);
      
      // ë” ê°€ê¹Œìš´ ëª¬ìŠ¤í„° ë°œê²¬ ì‹œ ì—…ë°ì´íŠ¸
      if (distance < minDistance) {
        minDistance = distance;
        nearestMonster = m;
      }
    }
  });
  
  return nearestMonster;
}

// ìë™ ì¡°ì¤€ í•¨ìˆ˜
function autoAim() {
  const nearestMonster = findNearestVisibleMonster();
  
  if (nearestMonster) {
    // ëª¬ìŠ¤í„° ë°©í–¥ìœ¼ë¡œ ì¡°ì¤€ ì„¤ì •
    const dx = Math.sign(nearestMonster.x - player.x);
    const dy = Math.sign(nearestMonster.y - player.y);
    
    player.aimDir = { dx, dy };
    player.aimTarget = { x: nearestMonster.x, y: nearestMonster.y };
    
    // ê¶¤ì  í‘œì‹œ
    showAimPath(player.x, player.y, nearestMonster.x, nearestMonster.y);
    
    addMsg(`ì¡°ì¤€: ${nearestMonster.x},${nearestMonster.y}ì˜ ëª¬ìŠ¤í„°`);
    return true;
  }
  
  addMsg('ì‹œì•¼ ë‚´ì— ëª¬ìŠ¤í„°ê°€ ì—†ìŠµë‹ˆë‹¤.');
  return false; // ì‹œì•¼ ë‚´ì— ëª¬ìŠ¤í„°ê°€ ì—†ìŒ
}

// Render the game
function render() {
  // ë ˆì´ì € íš¨ê³¼ê°€ ì§„í–‰ ì¤‘ì´ë©´ ë Œë”ë§ ê±´ë„ˆë›°ê¸°
  if (window.laserEffectActive && Date.now() < window.laserEffectActive) {
    console.log("ë ˆì´ì € íš¨ê³¼ ì¤‘ - ë Œë”ë§ ê±´ë„ˆëœ€");
    return;
  }
  
  let vis = calcFOV();
  let gameGrid = document.getElementById('game-grid');
  let statusBar = document.getElementById('status-bar');
  let messageLog = document.getElementById('message-log');
  
  // Clear previous content
  gameGrid.innerHTML = '';
  
  // Set grid template
  gameGrid.style.gridTemplateColumns = `repeat(${SCREEN_W}, 1fr)`;
  
  // Calculate view area
  let sx = Math.max(0, Math.min(MAP_W - SCREEN_W, player.x - Math.floor(SCREEN_W / 2)));
  let sy = Math.max(0, Math.min(MAP_H - SCREEN_H, player.y - Math.floor(SCREEN_H / 2)));
  
  // Create grid cells
  for (let y = sy; y < sy + SCREEN_H; ++y) {
    for (let x = sx; x < sx + SCREEN_W; ++x) {
      let cell = document.createElement('div');
      cell.className = 'cell';
      
      // íƒ€ì¼ ì¢Œí‘œ ì €ì¥ (í´ë¦­ ì´ë²¤íŠ¸ìš©)
      cell.dataset.x = x;
      cell.dataset.y = y;
      
      // Determine cell content
      let cellType = 'HIDDEN';
      let isExplored = exploredMap[`${x},${y}`] !== undefined;
      
      if (vis[`${x},${y}`]) {
        // í˜„ì¬ ì‹œì•¼ ë‚´ì— ìˆëŠ” ê²½ìš°
        if (player.x === x && player.y === y) {
          cellType = 'PLAYER';
        } else {
          let m = monsters.find(m => m.x === x && m.y === y);
          if (m) {
            if (m.hp <= 0) {
              cellType = 'MONSTER_DEAD';
            } else {
              cellType = m.type || 'MONSTER';
              // Add monster HP display
              cell.style.position = 'relative';
              let hpDisplay = document.createElement('div');
              hpDisplay.style.position = 'absolute';
              hpDisplay.style.bottom = '0';
              hpDisplay.style.right = '0';
              hpDisplay.style.fontSize = '8px';
              hpDisplay.style.backgroundColor = 'rgba(0,0,0,0.5)';
              hpDisplay.style.color = '#fff';
              hpDisplay.style.padding = '1px';
              hpDisplay.textContent = m.hp;
              cell.appendChild(hpDisplay);
            }
          } else {
            cellType = map[y][x] === WALL ? 'WALL' : 'FLOOR';
          }
        }
      } else if (isExplored) {
        // ì‹œì•¼ ë°–ì´ì§€ë§Œ ì´ì „ì— íƒì‚¬í•œ ì§€ì—­ì¸ ê²½ìš°
        cellType = exploredMap[`${x},${y}`] === WALL ? 'WALL' : 'FLOOR';
        // ì–´ë‘ìš´ ë°˜íˆ¬ëª… íš¨ê³¼ ì ìš©
        cell.style.filter = 'brightness(0.5)';
        cell.style.opacity = '0.7';
      }
      
      // Add appropriate CSS class
      if (cellType === 'WALL') cell.classList.add('wall');
      if (cellType === 'FLOOR') cell.classList.add('floor');
      
      // Set emoji content
      cell.textContent = TILES[cellType].emoji;
      
      // ì¡°ì¤€ ëª¨ë“œì¼ ë•Œ í´ë¦­ ì´ë²¤íŠ¸ ì¶”ê°€
      if (player.aiming && vis[`${x},${y}`]) {
        cell.style.cursor = 'crosshair';
        
        // í´ë¦­ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
        cell.addEventListener('click', function() {
          const targetX = parseInt(this.dataset.x);
          const targetY = parseInt(this.dataset.y);
          
          // ë²½ì´ë‚˜ í”Œë ˆì´ì–´ ìœ„ì¹˜ëŠ” ì¡°ì¤€ ë¶ˆê°€
          if (map[targetY][targetX] === WALL || (targetX === player.x && targetY === player.y)) {
            addMsg('ìœ íš¨í•˜ì§€ ì•Šì€ ì¡°ì¤€ ìœ„ì¹˜ì…ë‹ˆë‹¤.');
            return;
          }
          
          // ì¡°ì¤€ ë°©í–¥ ì„¤ì •
          const dx = Math.sign(targetX - player.x);
          const dy = Math.sign(targetY - player.y);
          
          player.aimDir = { dx, dy };
          player.aimTarget = { x: targetX, y: targetY };
          
          // ê¶¤ì  í‘œì‹œ
          showAimPath(player.x, player.y, targetX, targetY);
          
          addMsg(`ì¡°ì¤€: ${targetX},${targetY} ìœ„ì¹˜`);
        });
      }
      
      // Add to grid
      gameGrid.appendChild(cell);
    }
  }
  
  // Update status bar
  statusBar.innerHTML = `HP: ${player.hp} | Ammo: ${player.ammo} | ë¬´ê¸°: ${getWeaponEmoji(player.currentWeapon)} ${getWeaponName(player.currentWeapon)} | ëª¬ìŠ¤í„°: ${monsters.filter(m => m.hp > 0).length}`;
  
  // Update message log
  messageLog.innerHTML = '';
  if (player.aiming) {
    let aimingMsg = document.createElement('div');
    aimingMsg.textContent = 'ì¡°ì¤€ ì¤‘: ë°©í–¥í‚¤ë¡œ ë°©í–¥ ì„ íƒ ë˜ëŠ” íƒ€ì¼ í´ë¦­, ë‹¤ì‹œ ğŸ”« ë²„íŠ¼ì„ ëˆŒëŸ¬ ë°œì‚¬';
    aimingMsg.style.color = '#ffcc00';
    messageLog.appendChild(aimingMsg);
    
    // ë¬´ê¸°ë³„ íŒíŠ¸ í‘œì‹œ
    let weaponHint = document.createElement('div');
    switch(player.currentWeapon) {
      case 'gun':
        weaponHint.textContent = 'ê¶Œì´: ë‹¨ì¼ ëŒ€ìƒì—ê²Œ ì¤‘ê°„ ë°ë¯¸ì§€';
        break;
      case 'rocket':
        weaponHint.textContent = 'ë¡œì¼“: í­ë°œë¡œ ì£¼ë³€ ëª¬ìŠ¤í„°ì—ê²Œë„ ë°ë¯¸ì§€';
        break;
      case 'laser':
        weaponHint.textContent = 'ë ˆì´ì €: ì—¬ëŸ¬ ëª¬ìŠ¤í„°ë¥¼ ê´€í†µí•˜ëŠ” ë¹”';
        break;
    }
    weaponHint.style.color = '#aaffaa';
    messageLog.appendChild(weaponHint);
    
    // ë¬´ê¸° ì „í™˜ íŒíŠ¸
    let switchHint = document.createElement('div');
    switchHint.textContent = 'ë¬´ê¸° ì „í™˜: í‚¤ë³´ë“œ 1-3 ë˜ëŠ” ğŸ’ ë²„íŠ¼';
    switchHint.style.color = '#aaaaff';
    messageLog.appendChild(switchHint);
  } else {
    let controlMsg = document.createElement('div');
    controlMsg.textContent = 'ì´ë™: ë°©í–¥í‚¤ | ğŸ”«: ì¡°ì¤€/ë°œì‚¬ | ğŸ”„: ì¬ì¥ì „ | ğŸ’: ë¬´ê¸° ì „í™˜';
    messageLog.appendChild(controlMsg);
  }
  
  // Add game messages
  msg.forEach(m => {
    let msgElement = document.createElement('div');
    msgElement.textContent = m;
    messageLog.appendChild(msgElement);
  });
  
  // Game over message
  if (gameOver) {
    let gameOverMsg = document.createElement('div');
    gameOverMsg.textContent = 'ê²Œì„ ì˜¤ë²„! ìƒˆë¡œê³ ì¹¨í•˜ì—¬ ë‹¤ì‹œ ì‹œì‘';
    gameOverMsg.style.color = 'red';
    gameOverMsg.style.fontWeight = 'bold';
    messageLog.appendChild(gameOverMsg);
  }
  
  // ì¡°ì¤€ ê²½ë¡œ ë‹¤ì‹œ í‘œì‹œ (ë Œë”ë§ í›„)
  if (player.aiming && player.aimTarget) {
    showAimPath(player.x, player.y, player.aimTarget.x, player.aimTarget.y);
  }
}

// ë¬´ê¸° ì´ë¦„ ë°˜í™˜ í•¨ìˆ˜
function getWeaponName(weaponType) {
  switch(weaponType) {
    case 'gun': return 'ê¶Œì´';
    case 'rocket': return 'ë¡œì¼“';
    case 'laser': return 'ë ˆì´ì €';
    default: return 'ê¶Œì´';
  }
}

// ë¬´ê¸° ì´ëª¨ì§€ ë°˜í™˜ í•¨ìˆ˜
function getWeaponEmoji(weaponType) {
  switch(weaponType) {
    case 'gun': return 'ğŸ”«';
    case 'rocket': return 'ğŸš€';
    case 'laser': return 'âš¡';
    default: return 'ğŸ”«';
  }
}

// Move player
function tryMove(dx, dy) {
  let nx = player.x + dx, ny = player.y + dy;
  if (!inMap(nx, ny)) return false;
  if (map[ny][nx] === WALL) return false;
  let m = monsters.find(m => m.x === nx && m.y === ny && m.hp > 0);
  if (m) {
    m.hp -= 2 + Math.floor(Math.random() * 2); // melee attack
    addMsg('You punch the monster!');
    if (m.hp <= 0) addMsg('Monster dies!');
  } else {
    player.x = nx; player.y = ny;
  }
  return true;
}

// Monster AI: very simple, move toward player if in FOV, else random walk
function monsterTurn() {
  let vis = calcFOV();
  monsters.forEach(m => {
    if (m.hp <= 0) return;
    let dx = player.x - m.x, dy = player.y - m.y;
    let dist = Math.max(Math.abs(dx), Math.abs(dy));
    if (dist === 1) { // adjacent, attack
      player.hp -= 2;
      addMsg('Monster hits you!');
      if (player.hp <= 0) { gameOver = true; addMsg('You died!'); }
      return;
    }
    if (vis[`${m.x},${m.y}`]) {
      // Move closer
      let mx = dx ? dx / Math.abs(dx) : 0, my = dy ? dy / Math.abs(dy) : 0;
      let nx = m.x + mx, ny = m.y + my;
      if (inMap(nx, ny) && map[ny][nx] !== WALL && !monsters.find(mm => mm !== m && mm.x === nx && mm.y === ny) && (player.x !== nx || player.y !== ny))
        { m.x = nx; m.y = ny; }
    } else {
      // Random move
      let d = DIRS[Math.floor(Math.random() * 8)];
      let nx = m.x + d.dx, ny = m.y + d.dy;
      if (inMap(nx, ny) && map[ny][nx] !== WALL && !monsters.find(mm => mm !== m && mm.x === nx && mm.y === ny) && (player.x !== nx || player.y !== ny))
        { m.x = nx; m.y = ny; }
    }
  });
}

// Reload (now takes a real turn)
function doReload() {
  if (player.ammo === PLAYER_AMMO_MAX) { addMsg('ì´ë¯¸ ì¥ì „ë˜ì–´ ìˆìŠµë‹ˆë‹¤.'); render(); return; }
  player.ammo = PLAYER_AMMO_MAX;
  addMsg('ì¬ì¥ì „ ì™„ë£Œ!');
  monsterTurn(); // Monsters act immediately (reload is a turn)
  render();
}

// Keyboard input
document.addEventListener('keydown', function (e) {
  if (gameOver) return;
  
  // ì¡°ì¤€ ëª¨ë“œì¼ ë•Œ
  if (player.aiming) {
    // ESC: ì¡°ì¤€ ì·¨ì†Œ
    if (e.key === 'Escape') { 
      player.aiming = false; 
      player.aimTarget = null;
      clearHighlights();
      render(); 
      return; 
    }
    
    // ë°©í–¥í‚¤ë¡œ ì¡°ì¤€ ë°©í–¥ ì„¤ì •
    let d = NUM_DIR_KEYS[e.keyCode];
    if (d !== undefined && d !== 4) {
      player.aimDir = DIRS[d];
      
      // í•´ë‹¹ ë°©í–¥ìœ¼ë¡œ ì¡°ì¤€ ê²½ë¡œ í‘œì‹œ
      const targetX = player.x + player.aimDir.dx * 10; // ì¶©ë¶„íˆ ë¨¼ ê±°ë¦¬
      const targetY = player.y + player.aimDir.dy * 10;
      player.aimTarget = { x: targetX, y: targetY };
      
      showAimPath(player.x, player.y, targetX, targetY);
      render();
      return;
    }
    
    // F: ë°œì‚¬
    if (e.key === 'f' || e.key === 'F') {
      if (player.aimTarget) {
        // ì¡°ì¤€ëœ íƒ€ê²Ÿìœ¼ë¡œ ë°œì‚¬
        console.log("í‚¤ë³´ë“œ: ì¡°ì¤€ íƒ€ê²Ÿìœ¼ë¡œ ë°œì‚¬", player.aimTarget);
        
        fireWeapon(player.aimDir.dx, player.aimDir.dy);
        player.aiming = false;
        player.aimTarget = null;
        clearHighlights();
        monsterTurn();
        render();
      } else {
        addMsg('ë°©í–¥í‚¤ë¡œ ë°©í–¥ì„ ì„ íƒí•˜ê±°ë‚˜ íƒ€ì¼ì„ í´ë¦­í•˜ì„¸ìš”!');
      }
      return;
    }
    
    // ìˆ«ìí‚¤ 1-3: ë¬´ê¸° ì „í™˜
    if (e.key === '1' || e.key === '2' || e.key === '3') {
      const weaponIndex = parseInt(e.key) - 1;
      const weapons = ['gun', 'rocket', 'laser'];
      if (weaponIndex >= 0 && weaponIndex < weapons.length) {
        player.currentWeapon = weapons[weaponIndex];
        addMsg(`ë¬´ê¸° ì „í™˜: ${getWeaponName(player.currentWeapon)}`);
        updateWeaponButton();
        render();
      }
      return;
    }
    
    return;
  }
  
  // ì¡°ì¤€ ëª¨ë“œê°€ ì•„ë‹ ë•Œ
  
  // F: ì¡°ì¤€ ëª¨ë“œ ì‹œì‘
  if (e.key === 'f' || e.key === 'F') {
    player.aiming = true; 
    player.aimDir = { dx: 0, dy: 0 };
    
    // ìë™ ì¡°ì¤€ ì‹œë„
    autoAim();
    
    render(); 
    return;
  }
  
  // R: ì¬ì¥ì „
  if (e.key === 'r' || e.key === 'R') { 
    doReload(); 
    return; 
  }
  
  // ìˆ«ìí‚¤ 1-3: ë¬´ê¸° ì „í™˜
  if (e.key === '1' || e.key === '2' || e.key === '3') {
    const weaponIndex = parseInt(e.key) - 1;
    const weapons = ['gun', 'rocket', 'laser'];
    if (weaponIndex >= 0 && weaponIndex < weapons.length) {
      player.currentWeapon = weapons[weaponIndex];
      addMsg(`ë¬´ê¸° ì „í™˜: ${getWeaponName(player.currentWeapon)}`);
      updateWeaponButton();
      render();
    }
    return;
  }
  
  // ë°©í–¥í‚¤: ì´ë™
  let d = NUM_DIR_KEYS[e.keyCode];
  if (d !== undefined && d !== 4) {
    tryMove(DIRS[d].dx, DIRS[d].dy);
    monsterTurn();
    render();
    return;
  }
});
function init() {
  console.log("ê²Œì„ ì´ˆê¸°í™” í•¨ìˆ˜ ì‹œì‘");
  
  // Generate map and place entities
  console.log("ë§µ ìƒì„± ì‹œì‘");
  genMap();
  console.log("ë§µ ìƒì„± ì™„ë£Œ");
  
  console.log("ì—”í‹°í‹° ë°°ì¹˜ ì‹œì‘");
  placeEntities();
  console.log("ì—”í‹°í‹° ë°°ì¹˜ ì™„ë£Œ");
  
  // Initialize messages
  msg = ['Welcome to Doom Emoji RL!', 'Hunt down all monsters to win!'];
  console.log("ë©”ì‹œì§€ ì´ˆê¸°í™” ì™„ë£Œ");
  
  // ëª¨ë°”ì¼ ì»¨íŠ¸ë¡¤ ì´ë²¤íŠ¸ ì„¤ì •
  console.log("ëª¨ë°”ì¼ ì»¨íŠ¸ë¡¤ ì„¤ì • ì‹œì‘");
  setupMobileControls();
  console.log("ëª¨ë°”ì¼ ì»¨íŠ¸ë¡¤ ì„¤ì • ì™„ë£Œ");
  
  // ë¬´ê¸° ë²„íŠ¼ ì´ˆê¸°í™”
  console.log("ë¬´ê¸° ë²„íŠ¼ ì´ˆê¸°í™”");
  updateWeaponButton();
  
  // Render initial game state
  console.log("ì´ˆê¸° ê²Œì„ ìƒíƒœ ë Œë”ë§");
  render();
  console.log("ê²Œì„ ì´ˆê¸°í™” ì™„ë£Œ");
}

// ëª¨ë°”ì¼ ì»¨íŠ¸ë¡¤ ì„¤ì •
function setupMobileControls() {
  // ëª¨ë°”ì¼ í„°ì¹˜ ì´ë²¤íŠ¸ ìµœì í™”
  document.addEventListener('touchstart', function(e) {
    if (e.target.tagName === 'BUTTON') {
      e.preventDefault(); // ê¸°ë³¸ í„°ì¹˜ ë™ì‘ ë°©ì§€
    }
  }, { passive: false });
  
  // ë”ë¸” íƒ­ ì¤Œ ë°©ì§€
  document.addEventListener('dblclick', function(e) {
    e.preventDefault();
  });

  // ë°©í–¥ ë²„íŠ¼ ì´ë²¤íŠ¸
  const dirButtons = document.querySelectorAll('.dir-btn');
  dirButtons.forEach(btn => {
    // í´ë¦­ ì´ë²¤íŠ¸ì™€ í„°ì¹˜ ì´ë²¤íŠ¸ ëª¨ë‘ ì²˜ë¦¬
    ['click', 'touchstart'].forEach(eventType => {
      btn.addEventListener(eventType, function(e) {
        if (eventType === 'touchstart') e.preventDefault();
        if (gameOver) return;
        
        const dirIndex = parseInt(this.getAttribute('data-dir'));
        if (player.aiming) {
          // ì¡°ì¤€ ì¤‘ì¼ ë•ŒëŠ” ì¡°ì¤€ ë°©í–¥ ì„¤ì •
          player.aimDir = DIRS[dirIndex];
          
          // í•´ë‹¹ ë°©í–¥ìœ¼ë¡œ ì¡°ì¤€ ê²½ë¡œ í‘œì‹œ
          const targetX = player.x + player.aimDir.dx * 10; // ì¶©ë¶„íˆ ë¨¼ ê±°ë¦¬
          const targetY = player.y + player.aimDir.dy * 10;
          player.aimTarget = { x: targetX, y: targetY };
          
          showAimPath(player.x, player.y, targetX, targetY);
          render();
        } else {
          // ì¼ë°˜ ì´ë™
          tryMove(DIRS[dirIndex].dx, DIRS[dirIndex].dy);
          monsterTurn();
          render();
        }
      });
    });
  });
  
  // ì¡°ì¤€/ë°œì‚¬ ë²„íŠ¼
  const aimBtn = document.getElementById('aim-btn');
  ['click', 'touchstart'].forEach(eventType => {
    aimBtn.addEventListener(eventType, function(e) {
      if (eventType === 'touchstart') e.preventDefault();
      if (gameOver) return;
      
      if (player.aiming) {
        // ì´ë¯¸ ì¡°ì¤€ ì¤‘ì´ë©´ ë°œì‚¬
        if (player.aimTarget) {
          // ì¡°ì¤€ëœ íƒ€ê²Ÿìœ¼ë¡œ ë°œì‚¬
          console.log("ì¡°ì¤€ íƒ€ê²Ÿìœ¼ë¡œ ë°œì‚¬:", player.aimTarget);
          
          // í˜„ì¬ ë¬´ê¸°ì— ë”°ë¼ ë‹¤ë¥¸ ë°œì‚¬ íš¨ê³¼ ì‚¬ìš©
          fireWeapon(player.aimDir.dx, player.aimDir.dy);
          player.aiming = false;
          player.aimTarget = null;
          clearHighlights();
          monsterTurn();
          render();
        } else {
          addMsg('ë°©í–¥í‚¤ë¡œ ë°©í–¥ì„ ì„ íƒí•˜ê±°ë‚˜ íƒ€ì¼ì„ í´ë¦­í•˜ì„¸ìš”!');
        }
      } else {
        // ì¡°ì¤€ ëª¨ë“œ ì‹œì‘ ë° ìë™ ì¡°ì¤€ ì‹œë„
        player.aiming = true;
        player.aimDir = { dx: 0, dy: 0 };
        
        // ìë™ ì¡°ì¤€ ì‹œë„
        autoAim();
        
        render();
      }
    });
  });
  
  // ì¬ì¥ì „ ë²„íŠ¼
  const reloadBtn = document.getElementById('reload-btn');
  ['click', 'touchstart'].forEach(eventType => {
    reloadBtn.addEventListener(eventType, function(e) {
      if (eventType === 'touchstart') e.preventDefault();
      if (gameOver) return;
      doReload();
    });
  });
  
  // ë‹¬ë¦¬ê¸° ë²„íŠ¼ (2ì¹¸ ì´ë™)
  const runBtn = document.getElementById('run-btn');
  ['click', 'touchstart'].forEach(eventType => {
    runBtn.addEventListener(eventType, function(e) {
      if (eventType === 'touchstart') e.preventDefault();
      if (gameOver || player.aiming) return;
      
      addMsg('Run mode: Choose direction');
      // ë‹¤ìŒ ë°©í–¥í‚¤ ì…ë ¥ì„ ê¸°ë‹¤ë ¸ë‹¤ê°€ 2ì¹¸ ì´ë™
      const runHandler = function(e) {
        if (e.target.classList.contains('dir-btn')) {
          const dirIndex = parseInt(e.target.getAttribute('data-dir'));
          const dir = DIRS[dirIndex];
          
          // ì²« ë²ˆì§¸ ì¹¸ ì´ë™
          if (tryMove(dir.dx, dir.dy)) {
            // ë‘ ë²ˆì§¸ ì¹¸ ì´ë™ ì‹œë„
            tryMove(dir.dx, dir.dy);
          }
          
          monsterTurn();
          render();
          
          // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì œê±°
          document.getElementById('mobile-controls').removeEventListener('click', runHandler);
          document.getElementById('mobile-controls').removeEventListener('touchstart', runHandler);
        }
      };
      
      document.getElementById('mobile-controls').addEventListener('click', runHandler);
      document.getElementById('mobile-controls').addEventListener('touchstart', runHandler);
    });
  });
  
  // ì¸ë²¤í† ë¦¬ ë²„íŠ¼ (ë¬´ê¸° ì „í™˜ìœ¼ë¡œ ë³€ê²½)
  const inventoryBtn = document.getElementById('weapon-btn');
  ['click', 'touchstart'].forEach(eventType => {
    inventoryBtn.addEventListener(eventType, function(e) {
      if (eventType === 'touchstart') e.preventDefault();
      if (gameOver) return;
      
      // ë¬´ê¸° ì „í™˜
      switchWeapon();
      render();
    });
  });
  
  // ëª¨ë“  í™˜ê²½ì—ì„œ ì»¨íŠ¸ë¡¤ íŒ¨ë„ í‘œì‹œ
  document.getElementById('mobile-controls').style.display = 'flex';
}

// ë¬´ê¸° ì „í™˜ ë²„íŠ¼ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
function updateWeaponButton() {
  const weaponBtn = document.getElementById('weapon-btn');
  if (weaponBtn) {
    // í˜„ì¬ ë¬´ê¸°ì— ë”°ë¼ ë‹¤ìŒ ë¬´ê¸° ì•„ì´ì½˜ í‘œì‹œ
    switch(player.currentWeapon) {
      case 'gun':
        weaponBtn.innerHTML = 'ğŸš€'; // ë‹¤ìŒ ë¬´ê¸°ëŠ” ë¡œì¼“
        break;
      case 'rocket':
        weaponBtn.innerHTML = 'âš¡'; // ë‹¤ìŒ ë¬´ê¸°ëŠ” ë ˆì´ì €
        break;
      case 'laser':
        weaponBtn.innerHTML = 'ğŸ”«'; // ë‹¤ìŒ ë¬´ê¸°ëŠ” ê¶Œì´
        break;
    }
  }
}

// ë¬´ê¸° ì „í™˜ í•¨ìˆ˜
function switchWeapon() {
  const weapons = ['gun', 'rocket', 'laser'];
  const currentIndex = weapons.indexOf(player.currentWeapon);
  const nextIndex = (currentIndex + 1) % weapons.length;
  player.currentWeapon = weapons[nextIndex];
  addMsg(`ë¬´ê¸° ì „í™˜: ${getWeaponName(player.currentWeapon)}`);
  
  // ë¬´ê¸° ì „í™˜ ë²„íŠ¼ ì—…ë°ì´íŠ¸
  updateWeaponButton();
}

// ë¬´ê¸°ë³„ ë°œì‚¬ í•¨ìˆ˜
function fireWeapon(dx, dy) {
  if (player.ammo <= 0) { 
    addMsg('íƒ„ì•½ì´ ì—†ìŠµë‹ˆë‹¤! Rí‚¤ë‚˜ ğŸ”„ ë²„íŠ¼ìœ¼ë¡œ ì¬ì¥ì „í•˜ì„¸ìš”.'); 
    return; 
  }
  
  // ì¡°ì¤€ íƒ€ê²Ÿì´ ìˆëŠ” ê²½ìš°, ì •í™•í•œ íƒ€ê²Ÿ ì¢Œí‘œë¥¼ ì‚¬ìš©
  if (player.aimTarget) {
    // íƒ€ê²Ÿê¹Œì§€ì˜ ê²½ë¡œ ê³„ì‚°
    const path = calculatePath(player.x, player.y, player.aimTarget.x, player.aimTarget.y);
    
    console.log("ë°œì‚¬ ê²½ë¡œ:", path);
    addMsg(`ë°œì‚¬: ${player.aimTarget.x},${player.aimTarget.y} ë°©í–¥`);
    
    switch(player.currentWeapon) {
      case 'gun':
        fireGunWithPath(path);
        break;
      case 'rocket':
        fireRocketWithPath(path);
        break;
      case 'laser':
        fireLaserWithPath(path);
        break;
      default:
        fireGunWithPath(path);
    }
  } else {
    // ê¸°ì¡´ ë°©ì‹ - ë°©í–¥ë§Œ ì‚¬ìš©
    switch(player.currentWeapon) {
      case 'gun':
        fireGun(dx, dy);
        break;
      case 'rocket':
        fireRocket(dx, dy);
        break;
      case 'laser':
        fireLaser(dx, dy);
        break;
      default:
        fireGun(dx, dy);
    }
  }
  
  player.ammo--;
}

// ì¼ë°˜ ì´ ë°œì‚¬ (ê¶¤ì  í‘œì‹œ)
function fireGun(dx, dy) {
  let x = player.x, y = player.y;
  let hit = false;
  
  // ê²½ë¡œ ê³„ì‚°
  const path = [];
  for (let i = 0; i < MAP_W; ++i) {
    x += dx; y += dy;
    if (!inMap(x, y) || map[y][x] === WALL) break;
    path.push({x, y});
    
    let m = monsters.find(m => m.x === x && m.y === y && m.hp > 0);
    if (m) {
      let dmg = GUN_DAMAGE_MIN + Math.floor(Math.random() * (GUN_DAMAGE_MAX - GUN_DAMAGE_MIN + 1));
      m.hp -= dmg;
      addMsg(`ëª¬ìŠ¤í„°ë¥¼ ì´ìœ¼ë¡œ ì©ë‹ˆë‹¤! (${dmg} ë°ë¯¸ì§€)`);
      if (m.hp <= 0) addMsg('ëª¬ìŠ¤í„°ê°€ ì“°ëŸ¬ì§‘ë‹ˆë‹¤!');
      hit = true;
      break;
    }
  }
  
  if (!hit) addMsg('ì´ì•Œì´ ì–´ë‘  ì†ìœ¼ë¡œ ì‚¬ë¼ì§‘ë‹ˆë‹¤.');
  
  // ì´ì•Œ ê¶¤ì  í‘œì‹œ
  showBulletTrail(path);
}

// ê²½ë¡œ ê¸°ë°˜ ê¶Œì´ ë°œì‚¬ í•¨ìˆ˜
function fireGunWithPath(path) {
  let hit = false;
  
  // ê²½ë¡œë¥¼ ë”°ë¼ ëª¬ìŠ¤í„° í™•ì¸
  for (let i = 0; i < path.length; i++) {
    const pos = path[i];
    
    // ë²½ì„ ë§Œë‚˜ë©´ ì¤‘ë‹¨
    if (map[pos.y][pos.x] === WALL) {
      // ë²½ì— ë¶€ë”ªíŒ ì§€ì ê¹Œì§€ì˜ ê²½ë¡œë§Œ ì‚¬ìš©
      path = path.slice(0, i);
      break;
    }
    
    // ëª¬ìŠ¤í„°ë¥¼ ë§Œë‚˜ë©´ ë°ë¯¸ì§€ ì ìš©
    let m = monsters.find(m => m.x === pos.x && m.y === pos.y && m.hp > 0);
    if (m) {
      let dmg = GUN_DAMAGE_MIN + Math.floor(Math.random() * (GUN_DAMAGE_MAX - GUN_DAMAGE_MIN + 1));
      m.hp -= dmg;
      addMsg(`ëª¬ìŠ¤í„°ë¥¼ ì´ìœ¼ë¡œ ì©ë‹ˆë‹¤! (${dmg} ë°ë¯¸ì§€)`);
      if (m.hp <= 0) addMsg('ëª¬ìŠ¤í„°ê°€ ì“°ëŸ¬ì§‘ë‹ˆë‹¤!');
      hit = true;
      
      // ëª¬ìŠ¤í„°ì— ë§ì€ ì§€ì ê¹Œì§€ì˜ ê²½ë¡œë§Œ ì‚¬ìš©
      path = path.slice(0, i + 1);
      break;
    }
  }
  
  if (!hit) addMsg('ì´ì•Œì´ ì–´ë‘  ì†ìœ¼ë¡œ ì‚¬ë¼ì§‘ë‹ˆë‹¤.');
  
  // ì´ì•Œ ê¶¤ì  í‘œì‹œ
  showBulletTrail(path);
}

// ë¡œì¼“ ë°œì‚¬ (ì• ë‹ˆë©”ì´ì…˜ íš¨ê³¼)
function fireRocket(dx, dy) {
  let x = player.x, y = player.y;
  let hit = false;
  
  // ê²½ë¡œ ê³„ì‚°
  const path = [];
  for (let i = 0; i < MAP_W; ++i) {
    x += dx; y += dy;
    if (!inMap(x, y) || map[y][x] === WALL) break;
    path.push({x, y});
    
    let m = monsters.find(m => m.x === x && m.y === y && m.hp > 0);
    if (m) {
      let dmg = 5 + Math.floor(Math.random() * 3); // ë¡œì¼“ì€ ë” ê°•ë ¥í•¨
      m.hp -= dmg;
      addMsg(`ë¡œì¼“ì´ ëª¬ìŠ¤í„°ì—ê²Œ ëª…ì¤‘! (${dmg} ë°ë¯¸ì§€)`);
      if (m.hp <= 0) addMsg('ëª¬ìŠ¤í„°ê°€ í­ë°œê³¼ í•¨ê»˜ ì“°ëŸ¬ì§‘ë‹ˆë‹¤!');
      hit = true;
      
      // ì£¼ë³€ ëª¬ìŠ¤í„°ì—ê²Œ í”¼í•´ (í­ë°œ íš¨ê³¼)
      monsters.forEach(nearby => {
        if (nearby !== m && nearby.hp > 0) {
          const distance = Math.abs(nearby.x - m.x) + Math.abs(nearby.y - m.y);
          if (distance <= 2) {
            nearby.hp -= Math.max(1, 3 - distance);
            if (nearby.hp <= 0) addMsg('ì£¼ë³€ ëª¬ìŠ¤í„°ë„ í­ë°œì— íœ˜ë§ë ¤ ì“°ëŸ¬ì§‘ë‹ˆë‹¤!');
          }
        }
      });
      
      break;
    }
  }
  
  if (!hit) addMsg('ë¡œì¼“ì´ ë‚ ì•„ê°€ í­ë°œí•©ë‹ˆë‹¤.');
  
  // ë¡œì¼“ ì• ë‹ˆë©”ì´ì…˜ í‘œì‹œ
  animateRocket(path);
}

// ê²½ë¡œ ê¸°ë°˜ ë¡œì¼“ ë°œì‚¬ í•¨ìˆ˜
function fireRocketWithPath(path) {
  let hit = false;
  let hitPos = null;
  
  // ê²½ë¡œë¥¼ ë”°ë¼ ëª¬ìŠ¤í„° í™•ì¸
  for (let i = 0; i < path.length; i++) {
    const pos = path[i];
    
    // ë²½ì„ ë§Œë‚˜ë©´ ì¤‘ë‹¨
    if (map[pos.y][pos.x] === WALL) {
      // ë²½ì— ë¶€ë”ªíŒ ì§€ì ê¹Œì§€ì˜ ê²½ë¡œë§Œ ì‚¬ìš©
      path = path.slice(0, i);
      break;
    }
    
    // ëª¬ìŠ¤í„°ë¥¼ ë§Œë‚˜ë©´ ë°ë¯¸ì§€ ì ìš©
    let m = monsters.find(m => m.x === pos.x && m.y === pos.y && m.hp > 0);
    if (m) {
      let dmg = 5 + Math.floor(Math.random() * 3); // ë¡œì¼“ì€ ë” ê°•ë ¥í•¨
      m.hp -= dmg;
      addMsg(`ë¡œì¼“ì´ ëª¬ìŠ¤í„°ì—ê²Œ ëª…ì¤‘! (${dmg} ë°ë¯¸ì§€)`);
      if (m.hp <= 0) addMsg('ëª¬ìŠ¤í„°ê°€ í­ë°œê³¼ í•¨ê»˜ ì“°ëŸ¬ì§‘ë‹ˆë‹¤!');
      hit = true;
      hitPos = pos;
      
      // ì£¼ë³€ ëª¬ìŠ¤í„°ì—ê²Œ í”¼í•´ (í­ë°œ íš¨ê³¼)
      monsters.forEach(nearby => {
        if (nearby !== m && nearby.hp > 0) {
          const distance = Math.abs(nearby.x - pos.x) + Math.abs(nearby.y - pos.y);
          if (distance <= 2) {
            nearby.hp -= Math.max(1, 3 - distance);
            if (nearby.hp <= 0) addMsg('ì£¼ë³€ ëª¬ìŠ¤í„°ë„ í­ë°œì— íœ˜ë§ë ¤ ì“°ëŸ¬ì§‘ë‹ˆë‹¤!');
          }
        }
      });
      
      // ëª¬ìŠ¤í„°ì— ë§ì€ ì§€ì ê¹Œì§€ì˜ ê²½ë¡œë§Œ ì‚¬ìš©
      path = path.slice(0, i + 1);
      break;
    }
  }
  
  if (!hit) {
    addMsg('ë¡œì¼“ì´ ë‚ ì•„ê°€ í­ë°œí•©ë‹ˆë‹¤.');
    // ê²½ë¡œ ëì—ì„œ í­ë°œ íš¨ê³¼ (ë§ˆì§€ë§‰ ìœ„ì¹˜ ì£¼ë³€ ëª¬ìŠ¤í„°ì—ê²Œ í”¼í•´)
    if (path.length > 0) {
      const lastPos = path[path.length - 1];
      monsters.forEach(nearby => {
        if (nearby.hp > 0) {
          const distance = Math.abs(nearby.x - lastPos.x) + Math.abs(nearby.y - lastPos.y);
          if (distance <= 1) { // í­ë°œ ë²”ìœ„ ì¶•ì†Œ
            nearby.hp -= 2;
            addMsg('í­ë°œì´ ëª¬ìŠ¤í„°ì—ê²Œ í”¼í•´ë¥¼ ì…í™ë‹ˆë‹¤!');
            if (nearby.hp <= 0) addMsg('ëª¬ìŠ¤í„°ê°€ ì“°ëŸ¬ì§‘ë‹ˆë‹¤!');
          }
        }
      });
    }
  }
  
  // ë¡œì¼“ ì• ë‹ˆë©”ì´ì…˜ í‘œì‹œ
  animateRocket(path);
}

// ë ˆì´ì € ë°œì‚¬ (ê´‘ì„  íš¨ê³¼)
function fireLaser(dx, dy) {
  let x = player.x, y = player.y;
  let hit = false;
  
  // ê²½ë¡œ ê³„ì‚°
  const path = [];
  for (let i = 0; i < MAP_W; ++i) {
    x += dx; y += dy;
    if (!inMap(x, y) || map[y][x] === WALL) break;
    path.push({x, y});
    
    let m = monsters.find(m => m.x === x && m.y === y && m.hp > 0);
    if (m) {
      let dmg = 3; // ë ˆì´ì €ëŠ” ê³ ì • ë°ë¯¸ì§€
      m.hp -= dmg;
      addMsg(`ë ˆì´ì €ê°€ ëª¬ìŠ¤í„°ë¥¼ ê´€í†µí•©ë‹ˆë‹¤! (${dmg} ë°ë¯¸ì§€)`);
      if (m.hp <= 0) addMsg('ëª¬ìŠ¤í„°ê°€ ì“°ëŸ¬ì§‘ë‹ˆë‹¤!');
      hit = true;
      // ë ˆì´ì €ëŠ” ê´€í†µí•¨ (break í•˜ì§€ ì•ŠìŒ)
    }
  }
  
  if (!hit) addMsg('ë ˆì´ì €ê°€ í—ˆê³µì„ ê°€ë¦½ë‹ˆë‹¤.');
  
  // ë ˆì´ì € ê´‘ì„  íš¨ê³¼ í‘œì‹œ
  showLaserBeam(path);
}

// ê²½ë¡œ ê¸°ë°˜ ë ˆì´ì € ë°œì‚¬ í•¨ìˆ˜
function fireLaserWithPath(path) {
  let hit = false;
  
  // ë²½ì„ ë§Œë‚˜ëŠ” ì§€ì  ì°¾ê¸°
  let wallIndex = -1;
  for (let i = 0; i < path.length; i++) {
    const pos = path[i];
    if (map[pos.y][pos.x] === WALL) {
      wallIndex = i;
      break;
    }
  }
  
  // ë²½ì´ ìˆìœ¼ë©´ í•´ë‹¹ ì§€ì ê¹Œì§€ë§Œ ê²½ë¡œ ì‚¬ìš©
  if (wallIndex !== -1) {
    path = path.slice(0, wallIndex);
  }
  
  // ê²½ë¡œë¥¼ ë”°ë¼ ëª¨ë“  ëª¬ìŠ¤í„°ì—ê²Œ ë°ë¯¸ì§€ ì ìš© (ê´€í†µ)
  path.forEach(pos => {
    let m = monsters.find(m => m.x === pos.x && m.y === pos.y && m.hp > 0);
    if (m) {
      let dmg = 3; // ë ˆì´ì €ëŠ” ê³ ì • ë°ë¯¸ì§€
      m.hp -= dmg;
      addMsg(`ë ˆì´ì €ê°€ ëª¬ìŠ¤í„°ë¥¼ ê´€í†µí•©ë‹ˆë‹¤! (${dmg} ë°ë¯¸ì§€)`);
      if (m.hp <= 0) addMsg('ëª¬ìŠ¤í„°ê°€ ì“°ëŸ¬ì§‘ë‹ˆë‹¤!');
      hit = true;
    }
  });
  
  if (!hit) addMsg('ë ˆì´ì €ê°€ í—ˆê³µì„ ê°€ë¦½ë‹ˆë‹¤.');
  
  // ë ˆì´ì € ê´‘ì„  íš¨ê³¼ í‘œì‹œ
  showLaserBeam(path);
}

// ì´ì•Œ ê¶¤ì  í‘œì‹œ í•¨ìˆ˜
function showBulletTrail(path) {
  // ê²½ë¡œì— ì  í‘œì‹œ
  path.forEach((pos, index) => {
    setTimeout(() => {
      const cellIndex = (pos.y - Math.max(0, Math.min(MAP_H - SCREEN_H, player.y - Math.floor(SCREEN_H / 2)))) * SCREEN_W + 
                        (pos.x - Math.max(0, Math.min(MAP_W - SCREEN_W, player.x - Math.floor(SCREEN_W / 2))));
      const cells = document.getElementById('game-grid').children;
      
      if (cellIndex >= 0 && cellIndex < cells.length) {
        const cell = cells[cellIndex];
        const originalContent = cell.innerHTML;
        
        // ì´ì•Œ íš¨ê³¼ í‘œì‹œ
        cell.innerHTML = 'Â·';
        cell.style.color = 'yellow';
        
        // ì ì‹œ í›„ ì›ë˜ëŒ€ë¡œ ë³µì›
        setTimeout(() => {
          cell.innerHTML = originalContent;
          cell.style.color = '';
        }, 100);
      }
    }, index * 30); // 30ms ê°„ê²©ìœ¼ë¡œ ìˆœì°¨ í‘œì‹œ
  });
}

// ë¡œì¼“ ì• ë‹ˆë©”ì´ì…˜ í•¨ìˆ˜
function animateRocket(path) {
  let currentIndex = 0;
  
  const interval = setInterval(() => {
    // ì´ì „ ë¡œì¼“ ì§€ìš°ê¸°
    if (currentIndex > 0) {
      const prevPos = path[currentIndex - 1];
      const prevCellIndex = (prevPos.y - Math.max(0, Math.min(MAP_H - SCREEN_H, player.y - Math.floor(SCREEN_H / 2)))) * SCREEN_W + 
                           (prevPos.x - Math.max(0, Math.min(MAP_W - SCREEN_W, player.x - Math.floor(SCREEN_W / 2))));
      const cells = document.getElementById('game-grid').children;
      
      if (prevCellIndex >= 0 && prevCellIndex < cells.length) {
        const cell = cells[prevCellIndex];
        // ì›ë˜ ë‚´ìš© ë³µì› (ê°„ë‹¨íˆ ì²˜ë¦¬)
        cell.innerHTML = TILES.FLOOR.emoji;
        cell.style.color = '';
      }
    }
    
    // í˜„ì¬ ìœ„ì¹˜ì— ë¡œì¼“ í‘œì‹œ
    if (currentIndex < path.length) {
      const pos = path[currentIndex];
      const cellIndex = (pos.y - Math.max(0, Math.min(MAP_H - SCREEN_H, player.y - Math.floor(SCREEN_H / 2)))) * SCREEN_W + 
                        (pos.x - Math.max(0, Math.min(MAP_W - SCREEN_W, player.x - Math.floor(SCREEN_W / 2))));
      const cells = document.getElementById('game-grid').children;
      
      if (cellIndex >= 0 && cellIndex < cells.length) {
        const cell = cells[cellIndex];
        
        // ë¡œì¼“ íš¨ê³¼ í‘œì‹œ
        cell.innerHTML = 'ğŸš€';
        cell.style.color = 'orange';
      }
      
      currentIndex++;
    } else {
      // ì• ë‹ˆë©”ì´ì…˜ ì¢…ë£Œ ë° í­ë°œ íš¨ê³¼
      clearInterval(interval);
      
      if (path.length > 0) {
        const lastPos = path[path.length - 1];
        const lastCellIndex = (lastPos.y - Math.max(0, Math.min(MAP_H - SCREEN_H, player.y - Math.floor(SCREEN_H / 2)))) * SCREEN_W + 
                             (lastPos.x - Math.max(0, Math.min(MAP_W - SCREEN_W, player.x - Math.floor(SCREEN_W / 2))));
        const cells = document.getElementById('game-grid').children;
        
        if (lastCellIndex >= 0 && lastCellIndex < cells.length) {
          const cell = cells[lastCellIndex];
          
          // í­ë°œ íš¨ê³¼
          cell.innerHTML = 'ğŸ’¥';
          
          // ì ì‹œ í›„ ì›ë˜ëŒ€ë¡œ ë³µì›
          setTimeout(() => {
            cell.innerHTML = TILES.FLOOR.emoji;
            cell.style.color = '';
          }, 300);
        }
      }
    }
  }, 100); // 100ms ê°„ê²©ìœ¼ë¡œ ì• ë‹ˆë©”ì´ì…˜
}

// ë ˆì´ì € ê´‘ì„  íš¨ê³¼ í•¨ìˆ˜
function showLaserBeam(path) {
  console.log("ë ˆì´ì € ê²½ë¡œ í‘œì‹œ ì‹œì‘", path);
  
  if (!path || path.length === 0) {
    console.log("ê²½ë¡œê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤!");
    return;
  }
  
  // ë Œë”ë§ ë°©ì§€ í”Œë˜ê·¸ ì„¤ì • (ì´ ì‹œê°„ ë™ì•ˆ ì¶”ê°€ ë Œë”ë§ ë°©ì§€)
  const preventRenderUntil = Date.now() + 1000;
  window.laserEffectActive = preventRenderUntil;
  
  // ê° ì…€ì˜ ì›ë˜ ë‚´ìš© ì €ì¥
  const originalContents = [];
  const cellsToUpdate = [];
  
  // ëª¨ë“  ì…€ ì •ë³´ ìˆ˜ì§‘
  path.forEach((pos, index) => {
    const cellIndex = (pos.y - Math.max(0, Math.min(MAP_H - SCREEN_H, player.y - Math.floor(SCREEN_H / 2)))) * SCREEN_W + 
                      (pos.x - Math.max(0, Math.min(MAP_W - SCREEN_W, player.x - Math.floor(SCREEN_W / 2))));
    const cells = document.getElementById('game-grid').children;
    
    if (cellIndex >= 0 && cellIndex < cells.length) {
      const cell = cells[cellIndex];
      originalContents.push({
        cell: cell,
        content: cell.innerHTML,
        backgroundColor: cell.style.backgroundColor,
        color: cell.style.color
      });
      cellsToUpdate.push(cell);
    }
  });
  
  console.log(`ë ˆì´ì € ê²½ë¡œì— ìˆëŠ” ì…€ ìˆ˜: ${cellsToUpdate.length}`);
  
  // 1ë‹¨ê³„: ê°•ë ¬í•œ ë…¸ë€ìƒ‰ ë ˆì´ì € ë¹” (0ms)
  cellsToUpdate.forEach(cell => {
    cell.innerHTML = 'âš¡'; // ë ˆì´ì € ì´ëª¨í‹°ì½˜
    cell.style.setProperty('color', '#FFFF00', 'important'); // ë…¸ë€ìƒ‰
    cell.style.setProperty('background-color', '#880000', 'important'); // ì–´ë‘ìš´ ë¹¨ê°„ìƒ‰ ë°°ê²½
  });
  
  // 2ë‹¨ê³„: ì¤‘ê°„ ê°•ë„ (300ms)
  setTimeout(() => {
    cellsToUpdate.forEach(cell => {
      cell.innerHTML = 'âœ¨'; // ë‹¤ë¥¸ ì´ëª¨í‹°ì½˜
      cell.style.setProperty('color', '#FFDD00', 'important');
      cell.style.setProperty('background-color', '#660000', 'important');
    });
  }, 300);
  
  // 3ë‹¨ê³„: ì˜…ì€ íš¨ê³¼ (600ms)
  setTimeout(() => {
    cellsToUpdate.forEach(cell => {
      cell.innerHTML = 'Â·'; // ë” ì‘ì€ ì´ëª¨í‹°ì½˜
      cell.style.setProperty('color', '#FFEE88', 'important');
      cell.style.setProperty('background-color', '#440000', 'important');
    });
  }, 600);
  
  // ì›ë˜ ìƒíƒœë¡œ ë³µì› (900ms)
  setTimeout(() => {
    originalContents.forEach(item => {
      const cell = item.cell;
      if (cell) {
        cell.innerHTML = item.content;
        cell.style.removeProperty('color');
        cell.style.removeProperty('background-color');
        
        // ì›ë˜ ìŠ¤íƒ€ì¼ì´ ìˆì—ˆë‹¤ë©´ ë³µì›
        if (item.backgroundColor) cell.style.backgroundColor = item.backgroundColor;
        if (item.color) cell.style.color = item.color;
      }
    });
    
    // ë Œë”ë§ ë°©ì§€ í”Œë˜ê·¸ í•´ì œ
    window.laserEffectActive = false;
    console.log("ë ˆì´ì € ê²½ë¡œ í‘œì‹œ ì¢…ë£Œ");
    
    // ê°•ì œ ë Œë”ë§ìœ¼ë¡œ í™”ë©´ ì—…ë°ì´íŠ¸
    setTimeout(render, 50);
  }, 900);
}

// ê²Œì„ ì´ˆê¸°í™” í˜¸ì¶œ
window.onload = function() {
  console.log("ê²Œì„ ì´ˆê¸°í™” ì‹œì‘");
  init();
  console.log("ê²Œì„ ì´ˆê¸°í™” ì™„ë£Œ");
};
</script>
</body>
</html>