<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>트레이딩 몬테카를로 시뮬레이터</title>
  <style>
    body { font-family: 'Segoe UI', 'Pretendard', 'Apple SD Gothic Neo', Arial, sans-serif; background: #fcfcfc; color: #222; margin:0; padding:0;}
    header { background: #222; color: #fff; padding: 1.5rem 0 1rem 0; text-align: center;}
    h1 { margin: 0 0 0.5rem 0; font-size:2.2rem;}
    h2 { margin-top:2.5rem;}
    main { max-width: 900px; margin: 2rem auto 3rem auto; background: #fff; border-radius: 12px; box-shadow: 0 2px 14px #0001; padding:2rem;}
    label { font-weight:500;}
    .form-row { display:flex; align-items:center; gap:1.5em; margin-bottom:1em;}
    .form-row label {min-width: 180px;}
    .form-row input[type="number"] { width: 100px; padding:0.3em;}
    .form-row input[type="checkbox"] { width:1.1em; height:1.1em; }
    .form-row input[type="range"] { width: 150px;}
    .desc { color: #555; font-size:0.97em; margin-top: -0.7em; margin-bottom:1em; }
    button { background: #222; color: #fff; font-size:1.1em; border:none; border-radius:5px; padding:0.5em 2em; cursor:pointer; margin-top:1em;}
    button:disabled { opacity:0.6;}
    .progress-bar { background: #e8e8e8; border-radius:10px; overflow:hidden; height:22px; margin:1em 0;}
    .progress-inner { background: #2b72ff; height:100%; transition: width 0.15s;}
    .stats-table { width:100%; border-collapse:collapse; margin-top:1.5em;}
    .stats-table th, .stats-table td { border:1px solid #ddd; padding:0.5em 0.7em; text-align:right;}
    .stats-table th { background: #f3f3f3; color:#222;}
    .stats-table td.metric { background: #f9f9f9; text-align:left;}
    .summary-box { background: #f6faff; border-left: 6px solid #2b72ff; padding:1em 1.5em; margin:2em 0 1em 0; border-radius: 8px;}
    .footer { text-align:center; color:#888; margin:2em 0 1em 0; font-size:0.97em;}
    .badge { background: #2b72ff; color:#fff; border-radius:12px; padding:0.15em 0.9em; font-size:0.83em; margin-left:0.4em;}
    .result-section { margin-top:2em;}
    @media (max-width:650px){
      main { padding:1em; }
      .form-row { flex-direction:column; align-items:flex-start;}
      .stats-table th, .stats-table td { font-size:0.93em;}
    }
  </style>
</head>
<body>
  <header>
    <h1>트레이딩 몬테카를로 시뮬레이터</h1>
    <div>전략의 장기적 수익성과 위험을 시뮬레이션으로 검증하세요</div>
  </header>
  <main>
    <form id="sim-form" autocomplete="off">
      <h2>입력 파라미터</h2>
      <div class="form-row">
        <label for="capital">초기 자본(₩)</label>
        <input type="number" id="capital" min="5000" step="1000" value="100000">
      </div>
      <div class="form-row">
        <label for="bet_size">베팅 금액(₩/회)</label>
        <input type="number" id="bet_size" min="100" step="100" value="3000">
      </div>
      <div class="form-row">
        <label for="win_prob">승률(%)</label>
        <input type="range" id="win_prob" min="5" max="95" step="1" value="35" oninput="winProbOut.value=value">
        <output id="winProbOut">35</output> %
      </div>
      <div class="form-row">
        <label for="avg_win_rate">평균 익절률(%)</label>
        <input type="number" id="avg_win_rate" min="0.1" max="100" step="0.01" value="1.4">
        <span class="desc">예: 1.4 → +1.4%</span>
      </div>
      <div class="form-row">
        <label for="avg_loss_rate">평균 손절률(%)</label>
        <input type="number" id="avg_loss_rate" max="-0.01" min="-100" step="0.01" value="-0.5">
        <span class="desc">예: -0.5 → -0.5%</span>
      </div>
      <div class="form-row">
        <label for="commission_rate">수수료(%)</label>
        <input type="number" id="commission_rate" min="0" max="1" step="0.001" value="0.1">
        <span class="desc">거래 1회당(매수/매도 합산), 예: 0.1 → 0.1%</span>
      </div>
      <div class="form-row">
        <label for="num_trades">총 거래 횟수</label>
        <input type="number" id="num_trades" min="10" max="5000" step="10" value="1000">
      </div>
      <div class="form-row">
        <label for="max_streak_simulations">시뮬레이션 반복(회)</label>
        <input type="number" id="max_streak_simulations" min="10" max="3000" step="10" value="500">
      </div>
      <div class="form-row">
        <label for="cluster_coeff">연속성(스티키)</label>
        <input type="range" id="cluster_coeff" min="0" max="1" step="0.01" value="0.5" oninput="clusterCoeffOut.value=value">
        <output id="clusterCoeffOut">0.5</output>
        <span class="desc">0=완전랜덤, 1=연속승/연속패 클러스터</span>
      </div>
      <div class="form-row">
        <label for="enable_black_swan">블랙스완 이벤트</label>
        <input type="checkbox" id="enable_black_swan" checked>
        <span class="desc">희박하지만 치명적 손실 이벤트 활성화</span>
      </div>
      <div class="form-row">
        <label for="black_swan_prob">블랙스완 발생확률(%)</label>
        <input type="number" id="black_swan_prob" min="0" max="1" step="0.001" value="0.1">
        <span class="desc">거래 1회당, 예: 0.1 → 0.1%</span>
      </div>
      <div class="form-row">
        <label for="black_swan_loss_pct">블랙스완 자본손실(%)</label>
        <input type="number" id="black_swan_loss_pct" min="0" max="100" step="0.1" value="10">
        <span class="desc">자본의 몇 % 손실, 예: 10 → 10%</span>
      </div>
      <button type="submit" id="run-btn">시뮬레이션 실행</button>
      <div id="form-error" style="color:#c00; margin-top:0.7em; display:none;"></div>
      <div class="progress-bar" style="display:none;">
        <div class="progress-inner" style="width:0%;"></div>
      </div>
    </form>
    <section class="result-section">
      <div id="result"></div>
    </section>
    <details style="margin-top:2em;">
      <summary><b>Reward/Risk 요구치 표 (참고용)</b></summary>
      <div style="overflow-x:auto; margin-top:1em;">
        <table class="stats-table" style="font-size:0.97em;">
          <thead>
            <tr>
              <th>승률(%)</th>
              <th>10</th><th>15</th><th>20</th><th>25</th><th>30</th><th>35</th><th>40</th><th>45</th><th>50</th>
              <th>55</th><th>60</th><th>65</th><th>70</th><th>75</th><th>80</th><th>85</th><th>90</th><th>95</th>
            </tr>
          </thead>
          <tbody>
            <tr><td>Required R/R</td><td>9.0</td><td>5.7</td><td>4.0</td><td>3.0</td><td>2.3</td><td>1.9</td><td>1.5</td><td>1.2</td><td>1.0</td>
                <td>0.8</td><td>0.7</td><td>0.5</td><td>0.4</td><td>0.3</td><td>0.3</td><td>0.2</td><td>0.1</td><td>0.1</td></tr>
            <tr><td>R/R=1.5+</td><td>13.5</td><td>8.7</td><td>6.0</td><td>4.5</td><td>3.5</td><td>2.8</td><td>2.3</td><td>1.9</td><td>1.5</td>
                <td>1.2</td><td>1.0</td><td>0.8</td><td>0.6</td><td>0.5</td><td>0.4</td><td>0.3</td><td>0.2</td><td>0.1</td></tr>
            <tr><td>R/R=2.0+</td><td>18.0</td><td>11.3</td><td>8.0</td><td>6.0</td><td>4.7</td><td>3.7</td><td>3.0</td><td>2.4</td><td>2.0</td>
                <td>1.6</td><td>1.3</td><td>1.0</td><td>0.7</td><td>0.5</td><td>0.4</td><td>0.3</td><td>0.2</td><td>0.1</td></tr>
            <tr><td>R/R=2.5+</td><td>22.5</td><td>13.9</td><td>10.0</td><td>7.5</td><td>5.8</td><td>4.7</td><td>3.8</td><td>2.8</td><td>2.5</td>
                <td>2.0</td><td>1.7</td><td>1.3</td><td>0.9</td><td>0.7</td><td>0.5</td><td>0.4</td><td>0.2</td><td>0.1</td></tr>
          </tbody>
        </table>
      </div>
      <ul style="margin-top:0.7em; color:#456;">
        <li>Required R/R = (1-승률)/승률</li>
        <li>위 표는 구조적 수익성(장기적으로 수익구조가 가능한지) 참고용입니다.</li>
      </ul>
    </details>
  </main>
  <div class="footer">
    <b>© 2024-2025 Starfox119</b> | 오픈소스 코드 기반 | <a href="https://github.com/Starfox119" target="_blank">GitHub</a>
  </div>
  <script>
    // =========================
    // Utility (JS version)
    // =========================
    function calcKelly(win_prob, win_rate, loss_rate) {
      const b = loss_rate !== 0 ? win_rate / Math.abs(loss_rate) : 0;
      const p = win_prob;
      const q = 1 - p;
      const kelly = b !== 0 ? (b * p - q) / b : 0;
      return Math.max(0, kelly * 100);
    }
    function minRequiredWinProfit(win_rate, avg_loss, fee_rate) {
      const f = 2 * fee_rate;
      const p = win_rate;
      const L = avg_loss;
      if (p === 0) return Infinity;
      return (f - L) / p + L;
    }
    // =========================
    // Core Simulation (JS)
    // =========================
    function simulateStrategy(cfg, trackStreak=true, trackMdd=true) {
      let wins = 0, losses = 0, total_profit = 0, total_loss = 0, total_commission = 0;
      let streak = 0, max_lose_streak = 0;
      let capital = cfg.initial_capital, max_capital = cfg.initial_capital;
      let mdd = 0, mdd_pct = 0;
      const bet_size = cfg.bet_size;
      const win_prob = cfg.win_prob;
      const avg_win_rate = cfg.avg_win_rate;
      const avg_loss_rate = cfg.avg_loss_rate;
      const num_trades = cfg.num_trades;
      const commission_rate = cfg.commission_rate;
      const cluster_coeff = cfg.cluster_coeff;
      const black_swan_prob = cfg.black_swan_prob;
      const black_swan_loss_pct = cfg.black_swan_loss_pct;
      const enable_black_swan = cfg.enable_black_swan;
      let prev_win = Math.random() < win_prob;
      for(let i=0; i<num_trades; ++i){
        if(capital < bet_size) break;
        // Black Swan
        if(enable_black_swan && Math.random() < black_swan_prob){
          capital -= capital * black_swan_loss_pct;
        }
        // Clustered win/loss
        let curr_win;
        if(Math.random() < cluster_coeff){
          curr_win = prev_win;
        }else{
          curr_win = Math.random() < win_prob;
        }
        const commission = bet_size * commission_rate;
        total_commission += commission;
        if(curr_win){
          const profit = bet_size * avg_win_rate;
          capital += profit - commission;
          total_profit += profit;
          wins += 1;
          if(trackStreak) streak = 0;
          prev_win = true;
        }else{
          const loss = bet_size * Math.abs(avg_loss_rate);
          capital -= (loss + commission);
          total_loss += loss;
          losses += 1;
          if(trackStreak){
            streak += 1;
            if(streak > max_lose_streak) max_lose_streak = streak;
          }
          prev_win = false;
        }
        if(trackMdd){
          if(capital > max_capital){
            max_capital = capital;
          }
          const drawdown = max_capital - capital;
          mdd_pct = Math.max(mdd_pct, (max_capital>0 ? drawdown/max_capital : 0));
          mdd = Math.max(mdd, drawdown);
        }
      }
      const profit_factor = total_loss !== 0 ? (total_profit/total_loss) : (total_profit>0?Infinity:-Infinity);
      const recovery_factor = mdd !== 0 ? (total_profit/mdd) : (total_profit>0?Infinity:-Infinity);
      const seed_change = (capital-cfg.initial_capital)/cfg.initial_capital*100;
      const expectancy = win_prob*avg_win_rate + (1-win_prob)*avg_loss_rate;
      const kelly_pct = calcKelly(win_prob, avg_win_rate, avg_loss_rate);
      return {
        'Final Capital': capital,
        'Seed Change (%)': seed_change,
        'Total Profit': total_profit,
        'Total Loss': total_loss,
        'Profit Factor': profit_factor,
        'Total Commission': total_commission,
        'Win Count': wins,
        'Loss Count': losses,
        'Total Trades': wins+losses,
        'Max Losing Streak': max_lose_streak,
        'Max Drawdown': mdd,
        'Max Drawdown (%)': mdd_pct*100,
        'Recovery Factor': recovery_factor,
        'Expectancy (%)': expectancy*100,
        'Kelly Ratio (%)': kelly_pct
      };
    }
    async function montecarloSimulation(cfg, onProgress) {
      const N = cfg.max_streak_simulations;
      let results = [];
      for(let i=0; i<N; ++i){
        results.push(simulateStrategy(cfg, true, true));
        if(i%10===0 && onProgress) onProgress(i/N);
        // for UI responsiveness
        if(i%50===0) await new Promise(r=>setTimeout(r,0));
      }
      if(onProgress) onProgress(1);
      return results;
    }
    // =========================
    // Statistics & Reporting
    // =========================
    function calcStatsFromList(arr){
      arr = arr.slice().sort((a,b)=>a-b);
      const mean = arr.reduce((a,b)=>a+b,0)/arr.length;
      const median = arr.length%2===1 ? arr[(arr.length-1)/2] : (arr[arr.length/2-1]+arr[arr.length/2])/2;
      const min = arr[0], max = arr[arr.length-1];
      const std = Math.sqrt(arr.reduce((a,b)=>a+(b-mean)*(b-mean),0)/arr.length);
      function percentile(p){
        if(arr.length===0) return 0;
        const idx = Math.ceil((p/100)*arr.length)-1;
        return arr[Math.max(0,Math.min(arr.length-1,idx))];
      }
      return {
        'Median': median,
        'Mean': mean,
        'Min': min,
        'Max': max,
        'Std': std,
        '90%tile': percentile(90),
        '95%tile': percentile(95),
        '99%tile': percentile(99)
      };
    }
    function summarizeMontecarloResults(results, metrics){
      let summary = {};
      for(const metric of metrics){
        summary[metric] = calcStatsFromList(results.map(r=>r[metric]));
      }
      return summary;
    }
    function formatNum(n, digits=2){ 
      if(!isFinite(n)) return '∞';
      return n>=1e6 ? n.toFixed(0).replace(/\B(?=(\d{3})+(?!\d))/g,',') : n.toFixed(digits);
    }
    function formatPct(n){
      if(!isFinite(n)) return '∞';
      return (n>=0?'+':'') + n.toFixed(2) + ' %';
    }
    function formatMetricTable(summary, config){
      const col_order = ["Median", "Mean", "Min", "Max", "Std", "90%tile", "95%tile", "99%tile"];
      let rows = [];
      const metrics = Object.keys(summary);
      // config rows
      rows.push(['<b>초기 자본</b>', ...col_order.map(()=>formatNum(config.initial_capital,0))]);
      rows.push(['<b>베팅 금액</b>', ...col_order.map(()=>formatNum(config.bet_size,0))]);
      // stat rows
      for(const metric of metrics){
        const isPct = metric.match(/%/);
        rows.push([
          metric,
          ...col_order.map(c=>isPct ? formatPct(summary[metric][c]) : formatNum(summary[metric][c]))
        ]);
      }
      // header
      let thead = '<tr><th>지표</th>' + col_order.map(c=>`<th>${c}</th>`).join('') + '</tr>';
      let tbody = rows.map(r=>'<tr>' + r.map((v,i)=>i===0?`<td class="metric">${v}</td>`:`<td>${v}</td>`).join('') + '</tr>').join('');
      return `<table class="stats-table">${thead}${tbody}</table>`;
    }
    function analyzeStrategy(summary, config){
      const seed_change = summary["Seed Change (%)"]["Mean"];
      const expectancy = summary["Expectancy (%)"]["Mean"];
      const mdd = summary["Max Drawdown (%)"]["Mean"];
      const profit_factor = summary["Profit Factor"]["Mean"];
      const max_streak = summary["Max Losing Streak"]["Mean"];
      const kelly_pct = summary["Kelly Ratio (%)"]["Mean"];
      const min_win_profit = minRequiredWinProfit(
        config.win_prob,
        config.avg_loss_rate,
        config.commission_rate
      );
      const avg_win_rate = config.avg_win_rate;
      let html = `<div class="summary-box"><b>전략 성과 요약</b><br/><br/>`;
      html += `<b>켈리 이론 베팅비율:</b> ${formatPct(kelly_pct)}<br/>`;
      html += `<b>기대값 (Expectancy):</b> ${formatPct(expectancy)}<br/>`;
      html += `<b>평균 Seed 변화:</b> ${formatPct(seed_change)}<br/>`;
      html += `<b>평균 Max Drawdown:</b> ${formatPct(mdd)}<br/>`;
      html += `<b>Profit Factor:</b> ${formatNum(profit_factor)}<br/>`;
      html += `<b>최대 연속 손실:</b> ${formatNum(max_streak,1)}<br/>`;
      html += `<b>최소 요구 익절률:</b> ${formatPct(min_win_profit*100)}<br/>`;
      html += `<b>현재 평균 익절률:</b> ${formatPct(avg_win_rate*100)}<br/>`;
      html += `<hr style="margin:0.7em 0;"/>`;
      if(avg_win_rate < min_win_profit){
        html += `<span style="color:#c00"><b>- 현재 평균 익절률이 최소 요구치보다 낮아 구조적으로 적자 전략입니다.</b></span><br/>`;
      }else if(seed_change < 0 || expectancy < 0){
        html += `<span style="color:#c00"><b>- 기대값 또는 평균 seed 변화가 0 이하입니다. 장기적으로 자본이 감소할 수 있습니다.</b></span><br/>`;
      }else{
        html += `<span style="color:#295"><b>- 장기적으로 자본이 증가하는 구조입니다.</b></span><br/>`;
      }
      html += `<br/><b>추천사항</b><ul style="margin-top:0.3em;">`;
      if(avg_win_rate < min_win_profit){
        html += `<li>익절률을 높이거나 손실률/수수료를 낮추는 구조 개선 필요</li>`;
      }
      if(profit_factor < 1.5){
        html += `<li>Profit Factor(손익비)가 1.5 미만 → 수익/위험 구조 개선 필요</li>`;
      }
      if(mdd > 50){
        html += `<li>평균 Max Drawdown이 50% 초과 → 리스크 관리 강화 필요</li>`;
      }
      if(max_streak > 20){
        html += `<li>최대 연속 손실이 20회 초과 → 포지션 사이즈/손절 전략 점검 필요</li>`;
      }
      if(expectancy > 0 && expectancy < 0.5){
        html += `<li>기대값이 0.5% 미만 → 전략 개선 필요</li>`;
      }
      if(avg_win_rate >= min_win_profit && seed_change >= 0 && expectancy >= 0 &&
         profit_factor >= 1.5 && mdd <= 50 && max_streak <= 20 && expectancy >= 0.5){
        html += `<li>모든 주요 리스크/수익 지표가 양호합니다.</li>`;
      }
      html += `</ul></div>`;
      return html;
    }
    // =========================
    // Form & Event Logic
    // =========================
    function getFormConfig(){
      function val(id, fn){ return fn(document.getElementById(id).value);}
      function valC(id){ return document.getElementById(id).checked;}
      return {
        initial_capital: val('capital', Number),
        bet_size: val('bet_size', Number),
        win_prob: val('win_prob', v=>Number(v)/100),
        avg_win_rate: val('avg_win_rate', v=>Number(v)/100),
        avg_loss_rate: val('avg_loss_rate', v=>Number(v)/100),
        num_trades: val('num_trades', Number),
        commission_rate: val('commission_rate', v=>Number(v)/100),
        max_streak_simulations: val('max_streak_simulations', Number),
        cluster_coeff: val('cluster_coeff', Number),
        black_swan_prob: val('black_swan_prob', v=>Number(v)/100),
        black_swan_loss_pct: val('black_swan_loss_pct', v=>Number(v)/100),
        enable_black_swan: valC('enable_black_swan')
      };
    }
    function validateConfig(cfg){
      if(cfg.bet_size > cfg.initial_capital) return "베팅 금액이 초기 자본보다 큽니다.";
      if(cfg.win_prob < 0.01 || cfg.win_prob > 0.99) return "승률은 1~99% 범위로 입력하세요.";
      if(cfg.avg_win_rate <= 0) return "평균 익절률은 양수여야 합니다.";
      if(cfg.avg_loss_rate >= 0) return "평균 손절률은 음수여야 합니다.";
      if(cfg.num_trades < 10) return "거래횟수는 10회 이상이어야 합니다.";
      if(cfg.max_streak_simulations < 10) return "시뮬레이션 반복 횟수는 10회 이상이어야 합니다.";
      if(cfg.commission_rate < 0) return "수수료는 0 이상이어야 합니다.";
      if(cfg.cluster_coeff < 0 || cfg.cluster_coeff>1) return "연속성은 0~1 범위여야 합니다.";
      if(cfg.black_swan_prob < 0 || cfg.black_swan_prob > 1) return "블랙스완 확률은 0~1% 범위로 입력하세요.";
      if(cfg.black_swan_loss_pct < 0 || cfg.black_swan_loss_pct > 1) return "블랙스완 손실률은 0~100% 범위로 입력하세요.";
      return "";
    }
    function showProgress(pct){
      const bar = document.querySelector('.progress-bar');
      const inner = document.querySelector('.progress-inner');
      bar.style.display='block';
      inner.style.width = (pct*100).toFixed(1)+'%';
    }
    function hideProgress(){
      document.querySelector('.progress-bar').style.display='none';
      document.querySelector('.progress-inner').style.width = '0%';
    }
    document.getElementById('sim-form').addEventListener('submit', async function(e){
      e.preventDefault();
      hideProgress();
      document.getElementById('result').innerHTML = '';
      document.getElementById('form-error').style.display='none';
      const cfg = getFormConfig();
      const err = validateConfig(cfg);
      if(err){
        document.getElementById('form-error').innerText=err;
        document.getElementById('form-error').style.display='block';
        return;
      }
      document.getElementById('run-btn').disabled=true;
      showProgress(0);
      const METRICS = [
        "Final Capital", "Seed Change (%)", "Profit Factor", "Recovery Factor",
        "Max Drawdown (%)", "Max Losing Streak", "Total Trades",
        "Expectancy (%)", "Kelly Ratio (%)"
      ];
      const results = await montecarloSimulation(cfg, showProgress);
      hideProgress();
      const summary = summarizeMontecarloResults(results, METRICS);
      let html = '<h2>시뮬레이션 결과</h2>';
      html += formatMetricTable(summary, cfg);
      html += analyzeStrategy(summary, cfg);
      document.getElementById('result').innerHTML = html;
      document.getElementById('run-btn').disabled=false;
      window.scrollTo({top:document.getElementById('result').offsetTop-40, behavior:'smooth'});
    });
    // Live output for sliders
    document.getElementById('win_prob').addEventListener('input',function(){ winProbOut.value=this.value; });
    document.getElementById('cluster_coeff').addEventListener('input',function(){ clusterCoeffOut.value=this.value; });
    // Disable black swan probability/loss if unchecked
    document.getElementById('enable_black_swan').addEventListener('change',function(){
      document.getElementById('black_swan_prob').disabled = !this.checked;
      document.getElementById('black_swan_loss_pct').disabled = !this.checked;
      document.getElementById('black_swan_prob').style.background = this.checked?'':'#eee';
      document.getElementById('black_swan_loss_pct').style.background = this.checked?'':'#eee';
    });
    // Init
    if(!document.getElementById('enable_black_swan').checked){
      document.getElementById('black_swan_prob').disabled = true;
      document.getElementById('black_swan_loss_pct').disabled = true;
    }
  </script>
</body>
</html>