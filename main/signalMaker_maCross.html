<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Binance BTC/USDT ì´ë™í‰ê·  ë° ì¶”ì„¸ (ì‚¬ìš©ì ì„ íƒ)</title>
  <style>
    body { font-family: monospace; }
    h1 { font-size: 1em; margin-bottom: 0.5em; }
    #output div {
      line-height: 1.4em;
    }
    .label {
      display: inline-block;
      width: 20ch;  /* ë„‰ë„‰í•˜ê²Œ ì„¤ì •í•´ í•œ ì¤„ í‘œì‹œ */
      font-weight: bold;
    }
    .trend-up { color: #f44336; font-weight: bold; }
    .trend-down { color: #1976d2; font-weight: bold; }
    label, select {
      margin-right: 1em;
    }
  </style>
</head>
<body>
  <h1>Binance BTC/USDT ì´ë™í‰ê·  ë° ì¶”ì„¸</h1>

  <label for="timeframe-select">ë´‰ ê°„ê²©:</label>
  <select id="timeframe-select">
    <option value="1m">1ë¶„</option>
    <option value="3m">3ë¶„</option>
    <option value="5m" selected>5ë¶„</option>
  </select>

  <label for="short-ma-select">ë‹¨ê¸° ì´ë™í‰ê· :</label>
  <select id="short-ma-select">
    <option value="3">3</option>
    <option value="5" selected>5</option>
    <option value="7">7</option>
  </select>

  <label for="long-ma-select">ì¥ê¸° ì´ë™í‰ê· :</label>
  <select id="long-ma-select">
    <option value="10">10</option>
    <option value="20" selected>20</option>
    <option value="30">30</option>
  </select>

  <button id="apply-btn">ì ìš©</button>

  <div id="output" style="margin-top:1em;"></div>
  <div id="trend" style="margin-top:0.5em;"></div>
  <div id="notification-status" style="margin-top:0.5em; font-size:0.9em; color:#666;"></div>

  <script src="https://cdn.jsdelivr.net/npm/ccxt@4.1.31/dist/ccxt.browser.js"></script>
  <script>
    function simpleMA(data, period) {
      if (data.length < period) return null;
      const slice = data.slice(data.length - period);
      const sum = slice.reduce((a, b) => a + b, 0);
      return sum / period;
    }

    function to2(num) {
      return num !== null ? num.toFixed(2) : 'ë°ì´í„° ë¶€ì¡±';
    }

    const binance = new ccxt.binance({ options: { defaultType: 'future' } });

    const outputDiv = document.getElementById('output');
    const trendDiv = document.getElementById('trend');
    const notificationStatusDiv = document.getElementById('notification-status');
    const timeframeSelect = document.getElementById('timeframe-select');
    const shortMASelect = document.getElementById('short-ma-select');
    const longMASelect = document.getElementById('long-ma-select');
    const applyBtn = document.getElementById('apply-btn');

    let autoRefreshInterval = null;
    let currentTimeframe = timeframeSelect.value;
    let currentShortMA = parseInt(shortMASelect.value);
    let currentLongMA = parseInt(longMASelect.value);
    let message_sent = 0; // ë§¤ìˆ˜ ì•Œë¦¼ ë°œì†¡ ìƒíƒœ ì¶”ì 

    // í™”ë©´ ì•Œë¦¼ ì‹œìŠ¤í…œ ì´ˆê¸°í™”
    notificationStatusDiv.textContent = 'í™”ë©´ ì•Œë¦¼ ëª¨ë“œë¡œ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤.';

    async function fetchAndShow(timeframe, shortMA, longMA) {
      try {
        const ohlcv = await binance.fetchOHLCV('BTC/USDT', timeframe, undefined, 100);
        const closes = ohlcv.map(x => x[4]);

        const maShort = simpleMA(closes, shortMA);
        const maLong = simpleMA(closes, longMA);

        const latest = ohlcv[ohlcv.length - 1];
        const [ts, open, high, low, close, volume] = latest;
        const barTime = new Date(ts).toLocaleString();
        const nowStr = new Date().toLocaleTimeString();

        const lines = [
          {label: 'ë°ì´í„° ì‹œê°„:', value: barTime},
          {label: 'í˜„ì¬ ì‹œê°„:', value: nowStr},
          {label: 'ì‹œê°€:', value: to2(open)},
          {label: 'ê³ ê°€:', value: to2(high)},
          {label: 'ì €ê°€:', value: to2(low)},
          {label: 'ì¢…ê°€:', value: to2(close)},
          {label: `ë‹¨ê¸° ì´ë™í‰ê· (${shortMA}):`, value: to2(maShort)},
          {label: `ì¥ê¸° ì´ë™í‰ê· (${longMA}):`, value: to2(maLong)},
        ];

        outputDiv.innerHTML = '';
        lines.forEach(({label, value}) => {
          const line = document.createElement('div');
          const labelSpan = document.createElement('span');
          labelSpan.className = 'label';
          labelSpan.textContent = label;
          line.appendChild(labelSpan);
          line.appendChild(document.createTextNode(value));
          outputDiv.appendChild(line);
        });

        if (maShort !== null && maLong !== null) {
          if (maShort > maLong) {
            trendDiv.innerHTML = '<span class="trend-up">ì¶”ì„¸: ìƒìŠ¹</span>';
            
            // ìƒìŠ¹ ìƒíƒœì—ì„œ ì¢…ê°€ê°€ ë‹¨ê¸°ì´ë™í‰ê· ì„ ë³´ë‹¤ ë†’ê³ , ì•„ì§ ì•Œë¦¼ì„ ë³´ë‚´ì§€ ì•Šì•˜ë‹¤ë©´
            if (close > maShort && message_sent === 0) {
              // í™”ë©´ ì•Œë¦¼ ë°œì†¡
              message_sent = 1;
              notificationStatusDiv.innerHTML = '<span style="color: #f44336; font-weight: bold; font-size: 1.2em;">ğŸš¨ ë§¤ìˆ˜ ì‹ í˜¸! ğŸš¨</span><br>í˜„ì¬ê°€: ' + to2(close) + ' | ë‹¨ê¸°MA: ' + to2(maShort) + ' | ì¥ê¸°MA: ' + to2(maLong);
              
              // í™”ë©´ ê¹œë¹¡ì„ íš¨ê³¼
              document.body.style.backgroundColor = '#fff3cd';
              setTimeout(() => {
                document.body.style.backgroundColor = '#f8f9fa';
              }, 1000);
            }
          } else if (maShort < maLong) {
            trendDiv.innerHTML = '<span class="trend-down">ì¶”ì„¸: í•˜ë½</span>';
            message_sent = 0; // í•˜ë½ ìƒíƒœê°€ ë˜ë©´ ì•Œë¦¼ ìƒíƒœ ë¦¬ì…‹
            notificationStatusDiv.textContent = 'ì•Œë¦¼ ìƒíƒœ ë¦¬ì…‹ë¨ - ë‹¤ìŒ ë§¤ìˆ˜ ê¸°íšŒ ëŒ€ê¸° ì¤‘';
          } else {
            trendDiv.textContent = 'ì¶”ì„¸: ë™ì¼';
          }
        } else {
          trendDiv.textContent = '';
          notificationStatusDiv.textContent = '';
        }
      } catch (e) {
        outputDiv.textContent = 'ì˜¤ë¥˜: ' + e.message;
        trendDiv.textContent = '';
        notificationStatusDiv.textContent = '';
      }
    }

    applyBtn.addEventListener('click', () => {
      currentTimeframe = timeframeSelect.value;
      currentShortMA = parseInt(shortMASelect.value);
      currentLongMA = parseInt(longMASelect.value);

      fetchAndShow(currentTimeframe, currentShortMA, currentLongMA);

      if (autoRefreshInterval) {
        clearInterval(autoRefreshInterval);
      }
      autoRefreshInterval = setInterval(() => {
        fetchAndShow(currentTimeframe, currentShortMA, currentLongMA);
      }, 5000);
    });
  </script>
</body>
</html>