<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>ASCII Zoo Keeper</title>
  <style>
    body { 
      font-family: 'Segoe UI Emoji', sans-serif;
      background: #222;
      color: #fff;
      text-align: center;
      margin: 0;
      padding: 0;
    }
    h1 { margin-top: 20px; }
    #score { font-size: 1.5em; margin: 10px; }
    #board { 
      display: inline-grid; 
      grid-template-columns: repeat(6, 50px); 
      grid-gap: 3px; 
      margin-top: 20px;
      user-select: none;
    }
    .cell {
      width: 50px; height: 50px; 
      background: #444;
      border-radius: 8px;
      font-size: 2em;
      display: flex; align-items: center; justify-content: center;
      cursor: pointer;
      transition: background 0.1s;
    }
    .selected { background: #fb0; color: #222; }
  </style>
</head>
<body>
  <h1>ASCII Zoo Keeper 🦁🐼🐸</h1>
  <div id="score">점수: 0</div>
  <div id="board"></div>
  <button onclick="restart()">다시 시작</button>
  <script>
    const animals = ["🐶", "🐱", "🐵", "🦁", "🐸", "🐼"];
    const N = 6; // 보드 크기
    let board = [];
    let selected = null;
    let score = 0;

    function randomAnimal() {
      return animals[Math.floor(Math.random() * animals.length)];
    }

    function makeBoard() {
      board = [];
      for (let y = 0; y < N; y++) {
        let row = [];
        for (let x = 0; x < N; x++) {
          row.push(randomAnimal());
        }
        board.push(row);
      }
      // 시작부터 매치가 있으면 다시 생성
      while (findMatches().length > 0) {
        for (let y = 0; y < N; y++)
          for (let x = 0; x < N; x++)
            board[y][x] = randomAnimal();
      }
    }

    function drawBoard() {
      const boardDiv = document.getElementById('board');
      boardDiv.innerHTML = '';
      for (let y = 0; y < N; y++) {
        for (let x = 0; x < N; x++) {
          const cell = document.createElement('div');
          cell.className = 'cell' + ((selected && selected.x === x && selected.y === y) ? ' selected' : '');
          cell.textContent = board[y][x];
          cell.onclick = () => selectCell(x, y);
          boardDiv.appendChild(cell);
        }
      }
      document.getElementById('score').textContent = `점수: ${score}`;
    }

    function adjacent(a, b) {
      return Math.abs(a.x - b.x) + Math.abs(a.y - b.y) === 1;
    }

    function selectCell(x, y) {
      if (selected) {
        if (selected.x === x && selected.y === y) {
          selected = null;
        } else if (adjacent(selected, {x, y})) {
          swap(selected, {x, y});
          if (findMatches().length > 0) {
            resolveMatches();
          } else {
            swap(selected, {x, y}); // 되돌리기
          }
          selected = null;
        } else {
          selected = {x, y};
        }
      } else {
        selected = {x, y};
      }
      drawBoard();
    }

    function swap(a, b) {
      const tmp = board[a.y][a.x];
      board[a.y][a.x] = board[b.y][b.x];
      board[b.y][b.x] = tmp;
    }

    function findMatches() {
      const matches = [];
      // 가로 검사
      for (let y = 0; y < N; y++) {
        let cnt = 1;
        for (let x = 1; x < N; x++) {
          if (board[y][x] === board[y][x-1]) {
            cnt++;
          } else {
            if (cnt >= 3) matches.push({y, x1:x-cnt, x2:x-1});
            cnt = 1;
          }
        }
        if (cnt >= 3) matches.push({y, x1:N-cnt, x2:N-1});
      }
      // 세로 검사
      for (let x = 0; x < N; x++) {
        let cnt = 1;
        for (let y = 1; y < N; y++) {
          if (board[y][x] === board[y-1][x]) {
            cnt++;
          } else {
            if (cnt >= 3) matches.push({x, y1:y-cnt, y2:y-1, vertical:true});
            cnt = 1;
          }
        }
        if (cnt >= 3) matches.push({x, y1:N-cnt, y2:N-1, vertical:true});
      }
      return matches;
    }

    function resolveMatches() {
      let matched, anyMatch = false;
      do {
        matched = Array.from(Array(N), () => Array(N).fill(false));
        for (const m of findMatches()) {
          anyMatch = true;
          if (m.vertical) {
            for (let y = m.y1; y <= m.y2; y++) matched[y][m.x] = true;
          } else {
            for (let x = m.x1; x <= m.x2; x++) matched[m.y][x] = true;
          }
        }
        // 점수 계산 및 제거
        let removed = 0;
        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            if (matched[y][x]) {
              board[y][x] = null;
              removed++;
            }
          }
        }
        score += removed * 10;
        // 아래로 내리기
        for (let x = 0; x < N; x++) {
          let col = [];
          for (let y = N-1; y >= 0; y--) {
            if (board[y][x]) col.push(board[y][x]);
          }
          while (col.length < N) col.push(randomAnimal());
          for (let y = N-1; y >= 0; y--) board[y][x] = col[N-1-y];
        }
      } while (findMatches().length > 0);
      drawBoard();
    }

    function restart() {
      score = 0;
      selected = null;
      makeBoard();
      drawBoard();
    }

    // 초기화
    restart();
  </script>
</body>
</html>